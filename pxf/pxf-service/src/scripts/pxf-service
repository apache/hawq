#!/bin/sh
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#
# pxf-service	start/stop/initialize/status the PXF instance
#


if [ -z $PXF_HOME ]; then
    parent_script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"
    env_script=$parent_script_dir/conf/pxf-env.sh
else
    env_script=$PXF_HOME/conf/pxf-env.sh
fi

# load pxf-env.sh script
if [ ! -f $env_script ]; then
	echo WARNING: failed to find $env_script
else
	source $env_script
fi

pxf_user=${PXF_USER:-pxf}
instance_port=${PXF_PORT:-51200}
instance_name=pxf-service

if [ -z $PXF_HOME ]; then
    # RPM based setup
    pxf_root=/usr/lib/pxf
    tomcat_root=/opt/apache-tomcat
    tomcat_templates=/opt/pxf/tomcat-templates
    instance_root=/var/pxf
    instance_owner=$pxf_user:$pxf_user
else
    # OSS/Source code based setup
    pxf_root=$PXF_HOME/lib
    tomcat_root=$PXF_HOME/apache-tomcat
    tomcat_templates=$PXF_HOME/tomcat-templates
    instance_root=$PXF_HOME
    instance_owner=$pxf_user
fi

curl=`which curl`

#
# createInstance creates a tomcat instance 
# configuration files 
#
function createInstance()
{
	mkdir -p $instance_root 
	mkdir -p $instance_root/$instance_name 
	cp -r $tomcat_root/* $instance_root/$instance_name/.

	if [ $? -gt 0 ]; then
		echo ERROR: instance creation failed
		return 1
	fi

	chown -R $instance_owner $instance_root
	chmod 700 $instance_root/$instance_name
	return 0
}

#
# configureInstance configures the tomcat instance
# based on pre-configured template files.
#
# specifically:
#	support up to 30,000 header fields
#	support up to 1MB size header
#	change connection timeout to 60 seconds
#	set port to 51200
#
function configureInstance()
{
	# copy configuration files into instance
	cp $tomcat_templates/bin/setenv.sh $instance_root/$instance_name/bin/setenv.sh
	cp $tomcat_templates/conf/catalina.properties $instance_root/$instance_name/conf/.
	cp $tomcat_templates/conf/server.xml $instance_root/$instance_name/conf/.
	cp $tomcat_templates/conf/web.xml $instance_root/$instance_name/conf/.
	
	# set port
	catalinaProperties=$instance_root/$instance_name/conf/catalina.properties
	cat $catalinaProperties | \
	sed "s|^[[:blank:]]*connector.http.port=.*$|connector.http.port=$instance_port|g" \
	> ${catalinaProperties}.tmp

	rm $catalinaProperties
	mv ${catalinaProperties}.tmp $catalinaProperties

	# set pid
	catalinaEnv=$instance_root/$instance_name/bin/setenv.sh
	cat $catalinaEnv | \
	sed -e "s|^[[:blank:]]*CATALINA_PID=.*$|CATALINA_PID=$PXF_RUNDIR/catalina.pid|g" | \
	sed -e "s|-Dpxf.log.dir=[^[:space:]^\"]*|-Dpxf.log.dir=$PXF_LOGDIR |g" | \
	sed -e "s|^[[:blank:]]*CATALINA_OUT=.*$|CATALINA_OUT=$PXF_LOGDIR/catalina.out|g" \
	> ${catalinaEnv}.tmp
	rm $catalinaEnv
	mv ${catalinaEnv}.tmp $catalinaEnv

	# set log directories
	catalinaLog=$instance_root/$instance_name/conf/logging.properties
	cat $catalinaLog | \
	sed "s|juli.FileHandler.directory\s*=.*$|juli.FileHandler.directory = $PXF_LOGDIR|g" \
	> ${catalinaLog}.tmp
	rm $catalinaLog
	mv ${catalinaLog}.tmp $catalinaLog

	return 0
}

#
# deployWebapp adds the pxf-webapp to the new instance's webapps folder
# and the custom loader to the instance's lib directory
#
function deployWebapp()
{
	cp $pxf_root/pxf.war $instance_root/$instance_name/webapps/ || return 1
	cp $pxf_root/pxf-service-*[0-9].jar $instance_root/$instance_name/lib/ || return 1

	return 0
}

#
# waitForTomcat waits for tomcat to finish loading
# for given attempts number.
#
function waitForTomcat()
{
	attempts=0
	max_attempts=$1 # number of attempts to connect 
	sleep_time=1 # sleep 1 second between attempts
	
	# wait until tomcat is up:
	echo Checking if tomcat is up and running...
	until [[ "`curl --silent --connect-timeout 1 -I http://localhost:${instance_port} | grep 'Coyote'`" != "" ]];
	do
		let attempts=attempts+1
		if [[ "$attempts" -eq "$max_attempts" ]]; then
			echo ERROR: PXF is down - tomcat is not running
			return 1
		fi
		echo "tomcat not responding, re-trying after ${sleep_time} second (attempt number ${attempts})"
		sleep $sleep_time
	done

	return 0
}

#
# checkWebapp checks if tomcat is up for $1 attempts and then
# verifies PXF webapp is functional
#
function checkWebapp()
{
	waitForTomcat $1 || return 1
	
	echo Checking if PXF webapp is up and running...
	curlResponse=$($curl -s "http://localhost:${instance_port}/pxf/v0")
	expectedResponse="Wrong version v0, supported version is v[0-9]+"
	
	if [[ $curlResponse =~ $expectedResponse ]]; then
		echo PXF webapp is up
		return 0
	fi
	
	echo ERROR: PXF webapp is inaccessible but tomcat is up. Check logs for more information
	return 1
}

# instanceExists returns 0 when the instance exists
# non zero otherwise
function instanceExists()
{
	if [ ! -d "$instance_root/$instance_name" ]; then
		return 1
	fi

	$instance_root/$instance_name/bin/catalina.sh version > /dev/null 2>&1
	return $?
}

# doInit handles the init command
function doInit()
{
	instanceExists
	if [ $? -eq 0 ]; then
		echo WARNING: instance already exists in $instance_root, nothing to do...
		return 0
	fi
	# Generate private classpath file only if user specified hadoop_home option
	# Otherwise use default file
    if [ ! -z $hadoop_home ]; then
        generatePrivateClasspath || return 1
    else
        if [ ! -z $hbase_home ]; then
            echo WARNING: hbase_home option will be ignored, please specify hadoop_home
        fi
        if [ ! -z $hive_home ]; then
            echo WARNING: hive_home option will be ignored, please specify hadoop_home
        fi
    fi
	createInstance || return 1
	configureInstance || return 1
	deployWebapp || return 1
	createLogsDir || return 1
	createRunDir  || return 1

}

#
# patchWebapp patches the webapp config files
# patch applied only if PXF_HOME is defined
#
function patchWebapp()
{
    if [ -z $PXF_HOME ]; then
        # webapp doesn't require patch
        return 0
    fi
    pushd $instance_root/$instance_name/webapps || return 1
    rm -rf pxf
    mkdir pxf
    cd pxf
    unzip -q ../pxf.war
    popd

    context_file=$instance_root/$instance_name/webapps/pxf/META-INF/context.xml
    cat $context_file | \
    sed  -e "s:classpathFiles=\"[a-zA-Z0-9\/\;.-]*\":classpathFiles=\"$PXF_HOME\/conf\/pxf-private.classpath\":" \
    -e "s:secondaryClasspathFiles=\"[a-zA-Z0-9\/\;.-]*\":secondaryClasspathFiles=\"$PXF_HOME\/conf\/pxf-public.classpath\":" > context.xml.tmp
    mv context.xml.tmp $context_file

    web_file=$instance_root/$instance_name/webapps/pxf/WEB-INF/web.xml
    cat $web_file | \
    sed "s:<param-value>.*pxf-log4j.properties<\/param-value>:<param-value>$PXF_HOME\/conf\/pxf-log4j.properties<\/param-value>:" > web.xml.tmp
    mv web.xml.tmp $web_file
}

function commandWebapp()
{
    command=$1
    pushd $instance_root
    sudo -u $pxf_user $instance_root/$instance_name/bin/catalina.sh $command
    if [ $? -ne 0 ]; then
        return 1
    fi
    popd
}

function createLogsDir()
{
    mkdir -p $PXF_LOGDIR
    chown -R $instance_owner $PXF_LOGDIR
    chmod 700 $PXF_LOGDIR
    return 0
}

function createRunDir()
{
    mkdir -p $PXF_RUNDIR
    chown -R $instance_owner $PXF_RUNDIR
    chmod 700 $PXF_RUNDIR
    return 0
}

function generatePrivateClasspath()
{
    echo "Generating private classpath file..."
    #Create intial version of the file
    sed -e "s|PXF_HOME|$PXF_HOME|g" $PXF_HOME/conf-templates/pxf-private.classpath.template > $PXF_HOME/conf/pxf-private.classpath
    #Make sure $hadoop_home is defined
    if [ -z $hadoop_home ]; then
        echo ERROR: cant generate private classpath without hadoop_home value
        return 1
    fi
    #Substitute HADOOP_HOME value
    sed -i -e "s|HADOOP_HOME|$hadoop_home|g" $PXF_HOME/conf/pxf-private.classpath
    if [ ! -z $hbase_home ]; then
        #Substitute HBASE_HOME if hbase_home was set
        sed -i -e "s|HBASE_HOME|$hbase_home|g" $PXF_HOME/conf/pxf-private.classpath
    else
        #Delete lines with HBASE_HOME if hbase_home wasn't set
        sed -i  "/HBASE_HOME/d" $PXF_HOME/conf/pxf-private.classpath
    fi
    if [ ! -z $hive_home ]; then
        #Substitute HIVE_HOME if hive_home was set
        sed -i -e "s|HIVE_HOME|$hive_home|g" $PXF_HOME/conf/pxf-private.classpath
    else
        #Delete lines with HIVE_HOME if hive_home wasn't set
        sed -i  "/HIVE_HOME/d" $PXF_HOME/conf/pxf-private.classpath
    fi
}

function printUsage()
{
    echo $"Usage: $0 {start|stop|restart|init --hadoop-home HADOOP_LOCATION [--hive-home HIVE_LOCATION --hbase-home HBASE_LOCATION]|status}"

}

function validateParameters()
{

    # validate curl
    which curl &> /dev/null
    if [ "$?" -ne "0" ]
    then
        echo "ERROR: curl is not installed, please install"
        exit 1
    fi

    # validate unzip
    which unzip &> /dev/null
    if [ "$?" -ne "0" ]
    then
        echo "ERROR: unzip is not installed, please install"
        exit 1
    fi

    # validate pxf user
    id $pxf_user  &> /dev/null;
    if [ "$?" -ne "0" ]
    then
        echo "ERROR: User $pxf_user doesn't exist. Please set valid user via \$PXF_USER variable"
        exit 1
    fi

    # validate JAVA_HOME
    if [ ! -x $JAVA_HOME/bin/java ]; then
        echo ERROR: \$JAVA_HOME is invalid
        exit 1
    fi

    return 0
}

# 
# doStart handles start command
# command is executed as the user $pxf_user
#
# after start, uses checkWebapp to verify the PXF webapp was loaded
# successfully
#
function doStart()
{
	instanceExists
	if [ $? -ne 0 ]; then
		echo ERROR: cant find PXF instance, maybe call init?
		return 1
	fi
	patchWebapp || return 1
	commandWebapp start || return 1
	checkWebapp 300 || return 1
}

#
# doStart handles stop command
# command is executed as the user $pxf_user
#
#
function doStop()
{
    instanceExists
    if [ $? -ne 0 ]; then
        echo "ERROR: can't find PXF instance, maybe call init?"
        return 1
    fi
    commandWebapp stop || return 1
}

function doStatus()
{
	checkWebapp 1 || return 1
}

command=$1

case "$command" in
	"init" )
		shift
		while [[ $# -gt 1 ]]
		do
			name="$1"
			value="$2"
			case $name in
				--hadoop-home)
				hadoop_home="$2"
				shift
				;;
				--hive-home)
                                hive_home="$2"
                                shift
                                ;;
				--hbase-home)
                                hbase_home="$2"
                                shift
                                ;;
				*)
                                echo "$name is an unknown option"
                                printUsage
                                exit 1
			esac
			shift
		done
		validateParameters
		doInit
		;;
	"start" )
		validateParameters
		doStart
		;;
	"stop" )
		validateParameters
		doStop
		;;
	"restart" )
		validateParameters
		doStop
		sleep 1s
		doStart
		;;
	"status" )
		validateParameters
		doStatus
		;;
	* )
		printUsage
		exit 2
		;;
esac

exit $?
