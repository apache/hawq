set enable_partition_rules = false;
set gp_enable_hash_partitioned_tables = true;
-- missing subpartition by
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
ERROR:  missing SUBPARTITION BY clause for subpartition specification
LINE 5: partition aa (subpartition cc, subpartition dd),
        ^
-- missing subpartition spec
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
(
partition aa ,
partition bb 
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
ERROR:  hash partition requires PARTITIONS clause or partition specification
LINE 4: subpartition by hash (d) 
                        ^
-- subpart spec conflict
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b) 
subpartition by hash (d) subpartition template (subpartition jjj)
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
ERROR:  subpartition configuration conflicts with subpartition template
LINE 4: subpartition by hash (d) subpartition template (subpartition...
                        ^
-- missing subpartition by
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
subpartition by hash (d)
(
partition aa (subpartition cc, subpartition dd (subpartition iii)),
partition bb (subpartition cc, subpartition dd)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
ERROR:  missing SUBPARTITION BY clause for subpartition specification (at depth 2)
LINE 6: partition aa (subpartition cc, subpartition dd (subpartition...
                                       ^
-- Test column lookup works
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash(doesnotexist)
partitions 3;
ERROR:  column "doesnotexist" does not exist in relation "ggg"
LINE 3: partition by hash(doesnotexist)
                     ^
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash(b)
partitions 3
subpartition by list(alsodoesntexist)
subpartition template (
subpartition aa values(1)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_3" for table "ggg"
ERROR:  column "alsodoesntexist" does not exist in relation "ggg_1_prt_1"
LINE 5: subpartition by list(alsodoesntexist)
                        ^
-- should work
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
drop table ggg cascade;
-- disable hash partitions
set gp_enable_hash_partitioned_tables = false;
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
ERROR:  PARTITION BY must specify RANGE or LIST
drop table ggg cascade;
ERROR:  table "ggg" does not exist
set gp_enable_hash_partitioned_tables = true;
-- should work
create table ggg (a char(1), b char(2), d char(3), e int)
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
subpartition template ( 
subpartition cc,
subpartition dd
), 
subpartition by hash (e) 
subpartition template ( 
subpartition ee,
subpartition ff
) 
(
partition aa,
partition bb
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ee" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ff" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ee" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ff" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ee" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ff" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ee" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ff" for table "ggg_1_prt_bb_2_prt_dd"
drop table ggg cascade;
-- should work
create table ggg (a char(1), b char(2), d char(3), e int)
distributed by (a)
partition by hash (b)
subpartition by hash (d),
subpartition by hash (e)
subpartition template ( 
subpartition ee,
subpartition ff
) 
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ee" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ff" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ee" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ff" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ee" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ff" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ee" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ff" for table "ggg_1_prt_bb_2_prt_dd"
drop table ggg cascade;
-- doesn't work because cannot have nested declaration in template
create table ggg (a char(1), b char(2), d char(3), e int)
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
subpartition template ( 
subpartition cc (subpartition ee, subpartition ff),
subpartition dd (subpartition ee, subpartition ff)
), 
subpartition by hash (e) 
(
partition aa,
partition bb
);
ERROR:  template cannot contain specification for child partition
drop table ggg cascade;
ERROR:  table "ggg" does not exist
--ERROR: Missing boundary specification in partition 'aa' of type LIST 
create table fff (a char(1), b char(2), d char(3)) distributed by
(a) partition by list (b) (partition aa ); 
ERROR:  missing boundary specification in partition "aa" of type LIST
LINE 2: (a) partition by list (b) (partition aa );
                                   ^
-- ERROR: Invalid use of RANGE boundary specification in partition
--   number 1 of type LIST
create table fff (a char(1), b char(2), d char(3)) distributed by (a)
partition by list (b) (start ('a') );
ERROR:  invalid boundary specification for LIST partition
LINE 2: partition by list (b) (start ('a') );
                               ^
-- should work
create table fff (a char(1), b char(2), d char(3)) distributed by (a)
partition by list (b) (partition aa values ('2'));
NOTICE:  CREATE TABLE will create partition "fff_1_prt_aa" for table "fff"
drop table fff cascade;
-- Invalid use of RANGE boundary specification in partition "cc" of 
-- type HASH (at depth 2)
create table ggg (a char(1), b char(2), d char(3), e int) distributed by (a)
partition by hash (b) subpartition by hash (d),
subpartition by hash (e) 
subpartition template ( subpartition ee, subpartition ff ) (
partition aa (subpartition cc, subpartition dd), partition bb
(subpartition cc start ('a') , subpartition dd) );
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ee" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ff" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ee" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ff" for table "ggg_1_prt_aa_2_prt_dd"
ERROR:  invalid use of RANGE boundary specification in partition "cc" of type HASH (at depth 2)
LINE 6: (subpartition cc start ('a') , subpartition dd) );
                         ^
-- this is subtly wrong -- it defines 4 partitions
-- the problem is the comma before "end", which causes us to
-- generate 2 anonymous partitions.
-- This is an error: 
-- ERROR:  invalid use of mixed named and unnamed RANGE boundary specifications
create table ggg (a char(1), b int, d char(3))
distributed by (a)
partition by range (b)
(
partition aa start ('2007'), end ('2008'),
partition bb start ('2008'), end ('2009')
);
ERROR:  invalid use of mixed named and unnamed RANGE boundary specifications
LINE 5: partition aa start ('2007'), end ('2008'),
                                     ^
create table ggg (a char(1), b int)
distributed by (a)
partition by range(b)
(
partition aa start ('2007'), end ('2008')
);
ERROR:  invalid use of mixed named and unnamed RANGE boundary specifications
LINE 5: partition aa start ('2007'), end ('2008')
                                     ^
drop table ggg cascade;
ERROR:  table "ggg" does not exist
create table ggg (a char(1), b date, d char(3))
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01'),
partition bb start (date '2008-01-01') end (date '2009-01-01')
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
drop table ggg cascade;
-- don't allow nonconstant expressions, even simple ones...
create table ggg (a char(1), b numeric, d numeric)
distributed by (a)
partition by range (b,d)
(
partition aa start (2007,1) end (2008,2+2),
partition bb start (2008,2) end (2009,3)
);
ERROR:  syntax error at or near "+"
LINE 5: partition aa start (2007,1) end (2008,2+2),
                                               ^
-- too many columns for RANGE partition
create table ggg (a char(1), b numeric, d numeric)
distributed by (a)
partition by range (b,d)
(
partition aa start (2007,1) end (2008,2),
partition bb start (2008,2) end (2009,3)
);
ERROR:  too many columns for RANGE partition -- only one column is allowed.
LINE 3: partition by range (b,d)
                     ^
drop table ggg cascade;
ERROR:  table "ggg" does not exist
-- demo starts here
-- nested subpartitions
create table ggg
 (a char(1),   b date,
  d char(3),  e numeric,
  f numeric,  g numeric,
  h numeric)
distributed by (a)
partition by hash(b)
partitions 2
subpartition by hash(d)
subpartitions 2,
subpartition by hash(e) subpartitions 2,
subpartition by hash(f) subpartitions 2,
subpartition by hash(g) subpartitions 2,
subpartition by hash(h) subpartitions 2;
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1" for table "ggg_1_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2" for table "ggg_1_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1" for table "ggg_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2" for table "ggg_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_1_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1" for table "ggg_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2" for table "ggg_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_1_2_prt_2_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1" for table "ggg_1_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2" for table "ggg_1_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1" for table "ggg_1_prt_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2" for table "ggg_1_prt_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_1_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1" for table "ggg_1_prt_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2" for table "ggg_1_prt_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_1_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_1_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_1_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_1_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_1"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_2_6_prt_1" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_2"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_2_6_prt_2" for table "ggg_1_prt_2_2_prt_2_3_prt_2_4_prt_2_5_prt_2"
drop table ggg cascade;
-- named, inline subpartitions
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
drop table ggg cascade;
-- subpartitions with templates
create table ggg (a char(1), b char(2), d char(3), e numeric)
distributed by (a)
partition by hash (b)
subpartition by hash (d) 
subpartition template ( 
subpartition cc,
subpartition dd
), 
subpartition by hash (e) 
subpartition template ( 
subpartition ee,
subpartition ff
) 
(
partition aa,
partition bb
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ee" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ff" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ee" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ff" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ee" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ff" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ee" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ff" for table "ggg_1_prt_bb_2_prt_dd"
drop table ggg cascade;
-- mixed inline subpartition declarations with templates
create table ggg (a char(1), b char(2), d char(3), e numeric)
distributed by (a)
partition by hash (b)
subpartition by hash (d) , 
subpartition by hash (e) 
subpartition template ( 
subpartition ee,
subpartition ff
) 
(
partition aa (subpartition cc, subpartition dd),
partition bb (subpartition cc, subpartition dd)
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ee" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_cc_3_prt_ff" for table "ggg_1_prt_aa_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ee" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_ff" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ee" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_cc_3_prt_ff" for table "ggg_1_prt_bb_2_prt_cc"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ee" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_ff" for table "ggg_1_prt_bb_2_prt_dd"
drop table ggg cascade;
-- basic list partition
create table ggg (a char(1), b char(2), d char(3))
distributed by (a)
partition by LIST (b)
(
partition aa values ('a', 'b', 'c', 'd'),
partition bb values ('e', 'f', 'g')
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
insert into ggg values ('x', 'a');
insert into ggg values ('x', 'b');
insert into ggg values ('x', 'c');
insert into ggg values ('x', 'd');
insert into ggg values ('x', 'e');
insert into ggg values ('x', 'f');
insert into ggg values ('x', 'g');
insert into ggg values ('x', 'a');
insert into ggg values ('x', 'b');
insert into ggg values ('x', 'c');
insert into ggg values ('x', 'd');
insert into ggg values ('x', 'e');
insert into ggg values ('x', 'f');
insert into ggg values ('x', 'g');
select * from ggg order by 1, 2;
 a | b  | d 
---+----+---
 x | a  | 
 x | a  | 
 x | b  | 
 x | b  | 
 x | c  | 
 x | c  | 
 x | d  | 
 x | d  | 
 x | e  | 
 x | e  | 
 x | f  | 
 x | f  | 
 x | g  | 
 x | g  | 
(14 rows)

-- ok
select * from ggg_1_prt_aa order by 1, 2;
 a | b  | d 
---+----+---
 x | a  | 
 x | a  | 
 x | b  | 
 x | b  | 
 x | c  | 
 x | c  | 
 x | d  | 
 x | d  | 
(8 rows)

select * from ggg_1_prt_bb order by 1, 2;
 a | b  | d 
---+----+---
 x | e  | 
 x | e  | 
 x | f  | 
 x | f  | 
 x | g  | 
 x | g  | 
(6 rows)

drop table ggg cascade;
-- documentation example - partition by list and range
CREATE TABLE rank (id int, rank int, year date, gender 
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01'),
start (date '2002-01-01'),
start (date '2003-01-01'),
start (date '2004-01-01'),
start (date '2005-01-01')
)
(
  partition boys values ('M'),
  partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_1" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_2" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_3" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_4" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_5" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_1" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_2" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_3" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_4" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_5" for table "rank_1_prt_girls"
insert into rank values (1, 1, date '2001-01-15', 'M');
insert into rank values (2, 1, date '2002-02-15', 'M');
insert into rank values (3, 1, date '2003-03-15', 'M');
insert into rank values (4, 1, date '2004-04-15', 'M');
insert into rank values (5, 1, date '2005-05-15', 'M');
insert into rank values (6, 1, date '2001-01-15', 'F');
insert into rank values (7, 1, date '2002-02-15', 'F');
insert into rank values (8, 1, date '2003-03-15', 'F');
insert into rank values (9, 1, date '2004-04-15', 'F');
insert into rank values (10, 1, date '2005-05-15', 'F');
select * from rank order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  1 |    1 | 01-15-2001 | M
  2 |    1 | 02-15-2002 | M
  3 |    1 | 03-15-2003 | M
  4 |    1 | 04-15-2004 | M
  5 |    1 | 05-15-2005 | M
  6 |    1 | 01-15-2001 | F
  7 |    1 | 02-15-2002 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
 10 |    1 | 05-15-2005 | F
(10 rows)

select * from rank_1_prt_boys order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  1 |    1 | 01-15-2001 | M
  2 |    1 | 02-15-2002 | M
  3 |    1 | 03-15-2003 | M
  4 |    1 | 04-15-2004 | M
  5 |    1 | 05-15-2005 | M
(5 rows)

select * from rank_1_prt_girls order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  6 |    1 | 01-15-2001 | F
  7 |    1 | 02-15-2002 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
 10 |    1 | 05-15-2005 | F
(5 rows)

select * from rank_1_prt_girls_2_prt_1 order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  6 |    1 | 01-15-2001 | F
(1 row)

select * from rank_1_prt_girls_2_prt_2 order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  7 |    1 | 02-15-2002 | F
(1 row)

drop table rank cascade;
-- range list hash combo
create table ggg (a char(1), b date, d char(3), e numeric)
distributed by (a)
partition by range (b)
subpartition by list(d),
subpartition by hash(e) subpartitions 3
(
partition aa 
start  (date '2007-01-01') 
end (date '2008-01-01') 
       (subpartition dd values ('1', '2', '3'), 
	    subpartition ee values ('4', '5', '6')),
partition bb
start  (date '2008-01-01') 
end (date '2009-01-01') 
       (subpartition dd values ('1', '2', '3'),
	    subpartition ee values ('4', '5', '6'))
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_ee" for table "ggg_1_prt_aa"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_1" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_2" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_dd_3_prt_3" for table "ggg_1_prt_aa_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_ee_3_prt_1" for table "ggg_1_prt_aa_2_prt_ee"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_ee_3_prt_2" for table "ggg_1_prt_aa_2_prt_ee"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa_2_prt_ee_3_prt_3" for table "ggg_1_prt_aa_2_prt_ee"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_ee" for table "ggg_1_prt_bb"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_1" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_2" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_dd_3_prt_3" for table "ggg_1_prt_bb_2_prt_dd"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_ee_3_prt_1" for table "ggg_1_prt_bb_2_prt_ee"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_ee_3_prt_2" for table "ggg_1_prt_bb_2_prt_ee"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2_prt_ee_3_prt_3" for table "ggg_1_prt_bb_2_prt_ee"
drop table ggg cascade;
-- demo ends here
-- LIST validation
-- duplicate partition name
CREATE TABLE rank (id int, rank int, year date, gender
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (gender)
(
  partition boys values ('M'),
  partition girls values ('a'),
  partition girls values ('b'),
  partition girls values ('c'),
  partition girls values ('d'),
  partition girls values ('e'),
  partition bob values ('M')
);
ERROR:  duplicate partition name for partition "girls"
LINE 7:   partition girls values ('b'),
          ^
-- duplicate values
CREATE TABLE rank (id int, rank int, year date, gender
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (rank,gender)
(
 values ((1, 'M')),
 values ((2, 'M')),
 values ((3, 'M')),
 values ((1, 'F')),
 partition ff values ((4, 'M')),
 partition bb values ((1, 'M'))
);
ERROR:  duplicate VALUES in partition "bb"
LINE 10:  partition bb values ((1, 'M'))
                       ^
-- RANGE validation
-- legal if end of aa not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01'),
partition bb start (date '2008-01-01') end (date '2009-01-01') 
every (interval '10 days'));
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_3" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_4" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_5" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_6" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_7" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_8" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_9" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_10" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_11" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_12" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_13" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_14" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_15" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_16" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_17" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_18" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_19" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_20" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_21" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_22" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_23" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_24" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_25" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_26" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_27" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_28" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_29" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_30" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_31" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_32" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_33" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_34" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_35" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_36" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_37" for table "ggg"
drop table ggg cascade;
-- bad - legal if end of aa not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01') inclusive,
partition bb start (date '2008-01-01') end (date '2009-01-01') 
every (interval '10 days'));
ERROR:  starting value of partition "bb_1" overlaps previous range
LINE 6: partition bb start (date '2008-01-01') end (date '2009-01-01...
                     ^
drop table ggg cascade;
ERROR:  table "ggg" does not exist
-- legal because start of bb not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01') inclusive,
partition bb start (date '2008-01-01') exclusive end (date '2009-01-01') 
every (interval '10 days'));
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_3" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_4" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_5" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_6" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_7" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_8" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_9" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_10" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_11" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_12" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_13" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_14" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_15" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_16" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_17" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_18" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_19" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_20" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_21" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_22" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_23" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_24" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_25" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_26" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_27" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_28" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_29" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_30" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_31" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_32" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_33" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_34" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_35" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_36" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb_37" for table "ggg"
drop table ggg cascade;
-- legal if end of aa not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition bb start (date '2008-01-01') end (date '2009-01-01'),
partition aa start (date '2007-01-01') end (date '2008-01-01')
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
drop table ggg cascade;
-- bad - legal if end of aa not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition bb start (date '2008-01-01') end (date '2009-01-01'),
partition aa start (date '2007-01-01') end (date '2008-01-01') inclusive
);
ERROR:  starting value of partition "bb" overlaps previous range
LINE 5: partition bb start (date '2008-01-01') end (date '2009-01-01...
                     ^
drop table ggg cascade;
ERROR:  table "ggg" does not exist
-- legal because start of bb not inclusive
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition bb start (date '2008-01-01') exclusive end (date '2009-01-01'),
partition aa start (date '2007-01-01') end (date '2008-01-01') inclusive
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
drop table ggg cascade;
-- validate aa - start greater than end
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition bb start (date '2008-01-01') end (date '2009-01-01'),
partition aa start (date '2007-01-01') end (date '2006-01-01')
);
ERROR:  START greater than END for partition "aa"
LINE 6: partition aa start (date '2007-01-01') end (date '2006-01-01...
                     ^
drop table ggg cascade;
ERROR:  table "ggg" does not exist
-- formerly we could not set end of first partition because next is before
-- but we can sort them now so this is legal.
create table ggg (a char(1), b date, d char(3)) 
distributed by (a)
partition by range (b)
(
partition bb start (date '2008-01-01') ,
partition aa start (date '2007-01-01') 
);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_bb" for table "ggg"
drop table ggg cascade;
-- test cross type coercion
-- int -> char(N)
create table ggg (i int, a char(1))
distributed by (i)
partition by list(a)
(partition aa values(1, 2));
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
drop table ggg cascade;
-- int -> numeric
create table ggg (i int, n numeric(20, 2))
distributed by (i)
partition by list(n)
(partition aa values(1.22, 4.1));
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_aa" for table "ggg"
drop table ggg cascade;
-- EVERY
--  the documentation example, rewritten with EVERY in a template
CREATE TABLE rank (id int,
rank int, year date, gender char(1))
DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01')
end (date '2006-01-01') every (interval '1 year')) (
partition boys values ('M'),
partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_1" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_2" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_3" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_4" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_5" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_1" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_2" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_3" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_4" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_5" for table "rank_1_prt_girls"
insert into rank values (1, 1, date '2001-01-15', 'M');
insert into rank values (2, 1, date '2002-02-15', 'M');
insert into rank values (3, 1, date '2003-03-15', 'M');
insert into rank values (4, 1, date '2004-04-15', 'M');
insert into rank values (5, 1, date '2005-05-15', 'M');
insert into rank values (6, 1, date '2001-01-15', 'F');
insert into rank values (7, 1, date '2002-02-15', 'F');
insert into rank values (8, 1, date '2003-03-15', 'F');
insert into rank values (9, 1, date '2004-04-15', 'F');
insert into rank values (10, 1, date '2005-05-15', 'F');
select * from rank order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  1 |    1 | 01-15-2001 | M
  2 |    1 | 02-15-2002 | M
  3 |    1 | 03-15-2003 | M
  4 |    1 | 04-15-2004 | M
  5 |    1 | 05-15-2005 | M
  6 |    1 | 01-15-2001 | F
  7 |    1 | 02-15-2002 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
 10 |    1 | 05-15-2005 | F
(10 rows)

select * from rank_1_prt_boys order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  1 |    1 | 01-15-2001 | M
  2 |    1 | 02-15-2002 | M
  3 |    1 | 03-15-2003 | M
  4 |    1 | 04-15-2004 | M
  5 |    1 | 05-15-2005 | M
(5 rows)

select * from rank_1_prt_girls order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  6 |    1 | 01-15-2001 | F
  7 |    1 | 02-15-2002 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
 10 |    1 | 05-15-2005 | F
(5 rows)

select * from rank_1_prt_girls_2_prt_1 order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  6 |    1 | 01-15-2001 | F
(1 row)

select * from rank_1_prt_girls_2_prt_2 order by 1, 2, 3, 4;
 id | rank |    year    | gender 
----+------+------------+--------
  7 |    1 | 02-15-2002 | F
(1 row)

drop table rank cascade;
-- integer ranges work too
create table ggg (id integer, a integer)
distributed by (id)
partition by range (a)
(start (1) end (10) every (1));
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_3" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_4" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_5" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_6" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_7" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_8" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_9" for table "ggg"
insert into ggg values (1, 1);
insert into ggg values (2, 2);
insert into ggg values (3, 3);
insert into ggg values (4, 4);
insert into ggg values (5, 5);
insert into ggg values (6, 6);
insert into ggg values (7, 7);
insert into ggg values (8, 8);
insert into ggg values (9, 9);
insert into ggg values (10, 10);
ERROR:  no partition for partitioning key  (seg1 localhost:12002 pid=29884)
select * from ggg order by 1, 2;
 id | a 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 5
  6 | 6
  7 | 7
  8 | 8
  9 | 9
(9 rows)

select * from ggg_1_prt_1 order by 1, 2;
 id | a 
----+---
  1 | 1
(1 row)

select * from ggg_1_prt_2 order by 1, 2;
 id | a 
----+---
  2 | 2
(1 row)

select * from ggg_1_prt_3 order by 1, 2;
 id | a 
----+---
  3 | 3
(1 row)

select * from ggg_1_prt_4 order by 1, 2;
 id | a 
----+---
  4 | 4
(1 row)

drop table ggg cascade;
-- hash tests
create table ggg (a char(1), b varchar(2), d varchar(2))
distributed by (a)
partition by hash(b)
partitions 3
(partition a, partition b, partition c);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_a" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_b" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_c" for table "ggg"
insert into ggg values (1,1,1);
insert into ggg values (2,2,1);
insert into ggg values (1,3,1);
insert into ggg values (2,2,3);
insert into ggg values (1,4,5);
insert into ggg values (2,2,4);
insert into ggg values (1,5,6);
insert into ggg values (2,7,3);
insert into ggg values (1,'a','b');
insert into ggg values (2,'c','c');
select * from ggg order by 1, 2, 3;
 a | b | d 
---+---+---
 1 | 1 | 1
 1 | 3 | 1
 1 | 4 | 5
 1 | 5 | 6
 1 | a | b
 2 | 2 | 1
 2 | 2 | 3
 2 | 2 | 4
 2 | 7 | 3
 2 | c | c
(10 rows)

--select * from ggg_1_prt_a order by 1, 2, 3;
--select * from ggg_1_prt_b order by 1, 2, 3;
--select * from ggg_1_prt_c order by 1, 2, 3;
drop table ggg cascade;
-- use multiple cols
create table ggg (a char(1), b varchar(2), d varchar(2))
distributed by (a)
partition by hash(b,d)
partitions 3
(partition a, partition b, partition c);
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_a" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_b" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_c" for table "ggg"
insert into ggg values (1,1,1);
insert into ggg values (2,2,1);
insert into ggg values (1,3,1);
insert into ggg values (2,2,3);
insert into ggg values (1,4,5);
insert into ggg values (2,2,4);
insert into ggg values (1,5,6);
insert into ggg values (2,7,3);
insert into ggg values (1,'a','b');
insert into ggg values (2,'c','c');
select * from ggg order by 1, 2, 3;
 a | b | d 
---+---+---
 1 | 1 | 1
 1 | 3 | 1
 1 | 4 | 5
 1 | 5 | 6
 1 | a | b
 2 | 2 | 1
 2 | 2 | 3
 2 | 2 | 4
 2 | 7 | 3
 2 | c | c
(10 rows)

--select * from ggg_1_prt_a order by 1, 2, 3;
--select * from ggg_1_prt_b order by 1, 2, 3;
--select * from ggg_1_prt_c order by 1, 2, 3;
drop table ggg cascade;
-- use multiple cols of different types and without a partition spec
create table ggg (a char(1), b varchar(2), d integer, e date)
distributed by (a)
partition by hash(b,d,e)
partitions 3;
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_1" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_2" for table "ggg"
NOTICE:  CREATE TABLE will create partition "ggg_1_prt_3" for table "ggg"
insert into ggg values (1,1,1,date '2001-01-15');
insert into ggg values (2,2,1,date '2001-01-15');
insert into ggg values (1,3,1,date '2001-01-15');
insert into ggg values (2,2,3,date '2001-01-15');
insert into ggg values (1,4,5,date '2001-01-15');
insert into ggg values (2,2,4,date '2001-01-15');
insert into ggg values (1,5,6,date '2001-01-15');
insert into ggg values (2,7,3,date '2001-01-15');
insert into ggg values (1,'a',33,date '2001-01-15');
insert into ggg values (2,'c',44,date '2001-01-15');
select * from ggg order by 1, 2, 3, 4;
 a | b | d  |     e      
---+---+----+------------
 1 | 1 |  1 | 01-15-2001
 1 | 3 |  1 | 01-15-2001
 1 | 4 |  5 | 01-15-2001
 1 | 5 |  6 | 01-15-2001
 1 | a | 33 | 01-15-2001
 2 | 2 |  1 | 01-15-2001
 2 | 2 |  3 | 01-15-2001
 2 | 2 |  4 | 01-15-2001
 2 | 7 |  3 | 01-15-2001
 2 | c | 44 | 01-15-2001
(10 rows)

--select * from ggg_1_prt_1 order by 1, 2, 3, 4;
--select * from ggg_1_prt_2 order by 1, 2, 3, 4;
--select * from ggg_1_prt_3 order by 1, 2, 3, 4;
drop table ggg cascade;
-- append only tests
create table foz (i int, d date) with (appendonly = true) distributed by (i)
partition by range (d) (start (date '2001-01-01') end (date '2005-01-01')
every(interval '1 year'));
NOTICE:  CREATE TABLE will create partition "foz_1_prt_1" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_2" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_3" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_4" for table "foz"
insert into foz select i, '2001-01-01'::date + ('1 day'::interval * i) from
generate_series(1, 1000) i;
select count(*) from foz;
 count 
-------
  1000
(1 row)

select count(*) from foz_1_prt_1;
 count 
-------
   364
(1 row)

select min(d), max(d) from foz;
    min     |    max     
------------+------------
 01-02-2001 | 09-28-2003
(1 row)

select min(d), max(d) from foz_1_prt_1;
    min     |    max     
------------+------------
 01-02-2001 | 12-31-2001
(1 row)

select min(d), max(d) from foz_1_prt_2;
    min     |    max     
------------+------------
 01-01-2002 | 12-31-2002
(1 row)

select min(d), max(d) from foz_1_prt_3;
    min     |    max     
------------+------------
 01-01-2003 | 09-28-2003
(1 row)

select min(d), max(d) from foz_1_prt_4;
 min | max 
-----+-----
     | 
(1 row)

drop table foz cascade;
-- copy test
create table foz (i int, d date) distributed by (i)
partition by range (d) (start (date '2001-01-01') end (date '2005-01-01')
every(interval '1 year'));
NOTICE:  CREATE TABLE will create partition "foz_1_prt_1" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_2" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_3" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_4" for table "foz"
COPY foz FROM stdin DELIMITER '|';
select * from foz_1_prt_1;
 i |     d      
---+------------
 2 | 10-10-2001
 1 | 01-02-2001
(2 rows)

select * from foz_1_prt_2;
 i |     d      
---+------------
 3 | 10-30-2002
(1 row)

select * from foz_1_prt_3;
 i |     d      
---+------------
 4 | 01-01-2003
(1 row)

select * from foz_1_prt_4;
 i |     d      
---+------------
 5 | 05-05-2004
(1 row)

-- Check behaviour of key for which there is no partition
COPY foz FROM stdin DELIMITER '|';
ERROR:  no partition for partitioning key
CONTEXT:  COPY foz, line 1: "6|2010-01-01"
drop table foz cascade;
-- Same test with append only
create table foz (i int, d date) with (appendonly = true) distributed by (i)
partition by range (d) (start (date '2001-01-01') end (date '2005-01-01')
every(interval '1 year'));
NOTICE:  CREATE TABLE will create partition "foz_1_prt_1" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_2" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_3" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_4" for table "foz"
COPY foz FROM stdin DELIMITER '|';
select * from foz_1_prt_1;
 i |     d      
---+------------
 1 | 01-02-2001
 2 | 10-10-2001
(2 rows)

select * from foz_1_prt_2;
 i |     d      
---+------------
 3 | 10-30-2002
(1 row)

select * from foz_1_prt_3;
 i |     d      
---+------------
 4 | 01-01-2003
(1 row)

select * from foz_1_prt_4;
 i |     d      
---+------------
 5 | 05-05-2004
(1 row)

-- Check behaviour of key for which there is no partition
COPY foz FROM stdin DELIMITER '|';
ERROR:  no partition for partitioning key
CONTEXT:  COPY foz, line 1: "6|2010-01-01"
drop table foz cascade;
-- complain if create table as select (CTAS)
CREATE TABLE rank1 (id int,
rank int, year date, gender char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table rank2 as select * from rank1
DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01')
end (date '2006-01-01') every (interval '1 year')) (
partition boys values ('M'),
partition girls values ('F')
);
ERROR:  Cannot create a partitioned table using CREATE TABLE AS SELECT
HINT:  Use CREATE TABLE...LIKE (followed by INSERT...SELECT) instead
-- like is ok
create table rank2 (like rank1)
DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01')
end (date '2006-01-01') every (interval '1 year')) (
partition boys values ('M'),
partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys" for table "rank2"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls" for table "rank2"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_1" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_2" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_3" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_4" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_5" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_1" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_2" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_3" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_4" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_5" for table "rank2_1_prt_girls"
drop table rank1 cascade;
drop table rank2 cascade;
-- alter table testing
create table hhh (a char(1), b date, d char(3))
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01') 
    with (appendonly=true),
partition bb start (date '2008-01-01') end (date '2009-01-01')
    with (appendonly=false)
);
NOTICE:  CREATE TABLE will create partition "hhh_1_prt_aa" for table "hhh"
NOTICE:  CREATE TABLE will create partition "hhh_1_prt_bb" for table "hhh"
-- already exists
alter table hhh add partition aa;
ERROR:  partition "aa" of relation "hhh" already exists
-- no partition spec
alter table hhh add partition cc;
ERROR:  missing boundary specification
-- overlaps
alter table hhh add partition cc start ('2008-01-01') end ('2010-01-01');
ERROR:  new partition overlaps existing partition "bb"
alter table hhh add partition cc end ('2008-01-01');
ERROR:  new partition overlaps existing partition
-- reversed (start > end)
alter table hhh add partition cc start ('2010-01-01') end ('2009-01-01');
ERROR:  START greater than END for partition "cc"
-- works
--alter table hhh add partition cc start ('2009-01-01') end ('2010-01-01');
alter table hhh add partition cc end ('2010-01-01');
NOTICE:  CREATE TABLE will create partition "hhh_1_prt_cc" for table "hhh"
-- works - anonymous partition MPP-3350
alter table hhh add partition end ('2010-02-01');
NOTICE:  CREATE TABLE will create partition "hhh_1_prt_r1081726955" for table "hhh"
-- MPP-3607 - ADD PARTITION with open intervals
create table no_end1 (aa int, bb int) partition by range (bb)
(partition foo start(3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "no_end1_1_prt_foo" for table "no_end1"
-- fail overlap
alter table no_end1 add partition baz end (4);
ERROR:  new partition overlaps existing partition
-- fail overlap (because prior partition has no end)
alter table no_end1 add partition baz start (5);
ERROR:  new partition overlaps existing partition
-- ok (terminates on foo start)
alter table no_end1 add partition baz start (2);
NOTICE:  CREATE TABLE will create partition "no_end1_1_prt_baz" for table "no_end1"
-- ok (because ends before baz start)
alter table no_end1 add partition baz2 end (1);
NOTICE:  CREATE TABLE will create partition "no_end1_1_prt_baz2" for table "no_end1"
create table no_start1 (aa int, bb int) partition by range (bb)
(partition foo end(3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "no_start1_1_prt_foo" for table "no_start1"
-- fail overlap (because next partition has no start)
alter table no_start1 add partition baz start (2);
ERROR:  new partition overlaps existing partition
-- fail overlap (because next partition has no start)
alter table no_start1 add partition baz end (1);
ERROR:  new partition overlaps existing partition
-- ok (starts on foo end)
alter table no_start1 add partition baz end (4);
NOTICE:  CREATE TABLE will create partition "no_start1_1_prt_baz" for table "no_start1"
-- ok (because starts after baz end)
alter table no_start1 add partition baz2 start (5);
NOTICE:  CREATE TABLE will create partition "no_start1_1_prt_baz2" for table "no_start1"
select tablename, partitionlevel, parentpartitiontablename,
partitionname, partitionrank, partitionboundary from pg_partitions
where tablename = 'no_start1' or tablename = 'no_end1' 
order by tablename, partitionrank;
 tablename | partitionlevel | parentpartitiontablename | partitionname | partitionrank |        partitionboundary        
-----------+----------------+--------------------------+---------------+---------------+---------------------------------
 no_end1   |              0 |                          | baz2          |             1 | PARTITION baz2  END (1)
 no_end1   |              0 |                          | baz           |             2 | PARTITION baz START (2) END (3)
 no_end1   |              0 |                          | foo           |             3 | PARTITION foo START (3)
 no_start1 |              0 |                          | foo           |             1 | PARTITION foo  END (3)
 no_start1 |              0 |                          | baz           |             2 | PARTITION baz START (3) END (4)
 no_start1 |              0 |                          | baz2          |             3 | PARTITION baz2 START (5)
(6 rows)

drop table no_end1;
drop table no_start1;
-- hash partitions cannot have default partitions
create table jjj (aa int, bb int) 
partition by hash(bb) 
(partition j1, partition j2);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j1" for table "jjj"
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j2" for table "jjj"
alter table jjj add default partition;
ERROR:  syntax error at or near ";"
LINE 1: alter table jjj add default partition;
                                             ^
drop table jjj cascade;
-- default partitions cannot have boundary specifications
create table jjj (aa int, bb date) 
partition by range(bb) 
(partition j1 end (date '2008-01-01'), 
partition j2 end (date '2009-01-01'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j1" for table "jjj"
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j2" for table "jjj"
-- must have a name
alter table jjj add default partition;
ERROR:  syntax error at or near ";"
LINE 1: alter table jjj add default partition;
                                             ^
alter table jjj add default partition for (rank(1));
ERROR:  Can only ADD a partition by name
-- cannot have boundary spec
alter table jjj add default partition j3 end (date '2010-01-01');
ERROR:  invalid use of boundary specification for DEFAULT partition "j3" of relation "jjj"
drop table jjj cascade;
-- only one default partition
create table jjj (aa int, bb date) 
partition by range(bb) 
(partition j1 end (date '2008-01-01'), 
partition j2 end (date '2009-01-01'),
default partition j3);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j3" for table "jjj"
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j1" for table "jjj"
NOTICE:  CREATE TABLE will create partition "jjj_1_prt_j2" for table "jjj"
alter table jjj add default partition j3 ;
ERROR:  partition "j3" of relation "jjj" already exists
alter table jjj add default partition j4 ;
ERROR:  DEFAULT partition "j3" for relation "jjj" already exists
-- cannot add if have default, must split
alter table jjj add partition j5 end (date '2010-01-01');
ERROR:  cannot add RANGE partition "j5" to relation "jjj" with DEFAULT partition "j3"
HINT:  need to SPLIT partition "j3"
drop table jjj cascade;
alter table hhh alter partition cc set tablespace foo_p;
ERROR:  tablespace "foo_p" does not exist
alter table hhh alter partition aa set tablespace foo_p;
ERROR:  tablespace "foo_p" does not exist
alter table hhh coalesce partition cc;
ERROR:  cannot COALESCE PARTITION for relation "hhh"
alter table hhh coalesce partition aa;
ERROR:  cannot COALESCE PARTITION for relation "hhh"
alter table hhh drop partition cc;
alter table hhh drop partition cc cascade;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh drop partition cc restrict;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh drop partition if exists cc;
NOTICE:  partition "cc" of relation "hhh" does not exist, skipping
-- fail (mpp-3265)
alter table hhh drop partition for (rank(0));
ERROR:  partition for rank 0 of relation "hhh" does not exist
alter table hhh drop partition for (rank(-55));
ERROR:  partition for rank -55 of relation "hhh" does not exist
alter table hhh drop partition for ('2001-01-01');
ERROR:  partition for value ('2001-01-01') of relation "hhh" does not exist
create table hhh_r1 (a char(1), b date, d char(3))
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01') 
             every (interval '1 month')
);
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_1" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_2" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_3" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_4" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_5" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_6" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_7" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_8" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_9" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_10" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_11" for table "hhh_r1"
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_aa_12" for table "hhh_r1"
create table hhh_l1 (a char(1), b date, d char(3))
distributed by (a)
partition by list (b)
(
partition aa values ('2007-01-01'),
partition bb values ('2008-01-01'),
partition cc values ('2009-01-01') 
);
NOTICE:  CREATE TABLE will create partition "hhh_l1_1_prt_aa" for table "hhh_l1"
NOTICE:  CREATE TABLE will create partition "hhh_l1_1_prt_bb" for table "hhh_l1"
NOTICE:  CREATE TABLE will create partition "hhh_l1_1_prt_cc" for table "hhh_l1"
-- must have name or value for list partition
alter table hhh_l1 drop partition;
ERROR:  missing name or value for DROP for relation "hhh_l1"
alter table hhh_l1 drop partition aa;
alter table hhh_l1 drop partition for ('2008-01-01');
NOTICE:  dropped partition "bb" for relation "hhh_l1"
-- if not specified, drop first range partition...
alter table hhh_r1 drop partition for ('2007-04-01');
NOTICE:  dropped partition "aa_4" for relation "hhh_r1"
alter table hhh_r1 drop partition;
NOTICE:  dropped partition "aa_1" for relation "hhh_r1"
alter table hhh_r1 drop partition;
NOTICE:  dropped partition "aa_2" for relation "hhh_r1"
alter table hhh_r1 drop partition;
NOTICE:  dropped partition "aa_3" for relation "hhh_r1"
alter table hhh_r1 drop partition;
NOTICE:  dropped partition "aa_5" for relation "hhh_r1"
alter table hhh_r1 drop partition;
NOTICE:  dropped partition "aa_6" for relation "hhh_r1"
-- more add partition tests
-- start before first partition (fail because start equal end)
alter table hhh_r1 add partition zaa start ('2007-07-01');
ERROR:  new partition overlaps existing partition
-- start before first partition (ok)
alter table hhh_r1 add partition zaa start ('2007-06-01');
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_zaa" for table "hhh_r1"
-- start > last (fail because start equal end)
alter table hhh_r1 add partition bb start ('2008-01-01') end ('2008-01-01') ;
ERROR:  START equal to END for partition "bb"
-- start > last (ok)
alter table hhh_r1 add partition bb start ('2008-01-01') 
end ('2008-02-01') inclusive;
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_bb" for table "hhh_r1"
-- start > last (fail because start == last end inclusive)
alter table hhh_r1 add partition cc start ('2008-02-01') end ('2008-03-01') ;
ERROR:  new partition overlaps existing partition "bb"
-- start > last (ok [and leave a gap])
alter table hhh_r1 add partition cc start ('2008-04-01') end ('2008-05-01') ;
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_cc" for table "hhh_r1"
-- overlap (fail)
alter table hhh_r1 add partition dd start ('2008-01-01') end ('2008-05-01') ;
ERROR:  new partition overlaps existing partition "bb"
-- new partition in "gap" (ok)
alter table hhh_r1 add partition dd start ('2008-03-01') end ('2008-04-01') ;
NOTICE:  CREATE TABLE will create partition "hhh_r1_1_prt_dd" for table "hhh_r1"
-- overlap all partitions (fail)
alter table hhh_r1 add partition ee start ('2006-01-01') end ('2009-01-01') ;
ERROR:  new partition overlaps existing partition
-- start before first partition (fail because end in "gap" [and overlaps])
alter table hhh_r1 add partition yaa start ('2007-05-01') end ('2007-07-01');
ERROR:  new partition overlaps existing partition
-- start before first partition (fail )
alter table hhh_r1 add partition yaa start ('2007-05-01') 
end ('2007-10-01') inclusive;
ERROR:  new partition overlaps existing partition "aa_10"
-- start before first partition (fail because end overlaps)
alter table hhh_r1 add partition yaa start ('2007-05-01') 
end ('2007-10-01') exclusive;
ERROR:  new partition overlaps existing partition
drop table hhh_r1 cascade;
drop table hhh_l1 cascade;
--  the documentation example, rewritten with EVERY in a template
--  and also with a default partition
CREATE TABLE rank (id int,
rank int, year date, gender char(1))
DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01')
end (date '2006-01-01') every (interval '1 year')) (
partition boys values ('M'),
partition girls values ('F'),
default partition neuter
);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_1" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_2" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_3" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_4" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_5" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_1" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_2" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_3" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_4" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_5" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter_2_prt_1" for table "rank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter_2_prt_2" for table "rank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter_2_prt_3" for table "rank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter_2_prt_4" for table "rank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_neuter_2_prt_5" for table "rank_1_prt_neuter"
insert into rank values (1, 1, date '2001-01-15', 'M');
insert into rank values (2, 1, date '2002-02-15', 'M');
insert into rank values (3, 1, date '2003-03-15', 'M');
insert into rank values (4, 1, date '2004-04-15', 'M');
insert into rank values (5, 1, date '2005-05-15', 'M');
insert into rank values (6, 1, date '2001-01-15', 'F');
insert into rank values (7, 1, date '2002-02-15', 'F');
insert into rank values (8, 1, date '2003-03-15', 'F');
insert into rank values (9, 1, date '2004-04-15', 'F');
insert into rank values (10, 1, date '2005-05-15', 'F');
select * from rank ;
 id | rank |    year    | gender 
----+------+------------+--------
  7 |    1 | 02-15-2002 | F
 10 |    1 | 05-15-2005 | F
  5 |    1 | 05-15-2005 | M
  2 |    1 | 02-15-2002 | M
  6 |    1 | 01-15-2001 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
  4 |    1 | 04-15-2004 | M
  1 |    1 | 01-15-2001 | M
  3 |    1 | 03-15-2003 | M
(10 rows)

alter table rank DROP partition boys restrict;
NOTICE:  dropped partition "boys" for relation "rank" and its children
select * from rank ;
 id | rank |    year    | gender 
----+------+------------+--------
  7 |    1 | 02-15-2002 | F
 10 |    1 | 05-15-2005 | F
  6 |    1 | 01-15-2001 | F
  8 |    1 | 03-15-2003 | F
  9 |    1 | 04-15-2004 | F
(5 rows)

-- MPP-3722: complain if for(value) matches the default partition 
alter table rank truncate partition for('N');
ERROR:  FOR expression matches DEFAULT partition "neuter" of relation "rank"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table rank DROP partition for('N');
ERROR:  FOR expression matches DEFAULT partition "neuter" of relation "rank"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table rank DROP partition if exists for('N');
ERROR:  FOR expression matches DEFAULT partition "neuter" of relation "rank"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table rank DROP default partition if exists ;
NOTICE:  dropped partition "neuter" for relation "rank" and its children
-- can't drop the final partition - must drop the table
alter table rank DROP partition girls;
ERROR:  cannot drop partition "girls" of relation "rank" -- only one remains
HINT:  Use DROP TABLE "rank" to remove the table and the final partition
-- MPP-4011: make FOR(value) work
alter table rank alter partition for ('F') add default partition def1;
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_def1" for table "rank_1_prt_girls"
alter table rank alter partition for ('F') 
truncate partition for ('2010-10-10');
ERROR:  FOR expression matches DEFAULT partition "def1" of partition "girls" of relation "rank"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table rank truncate partition for ('F');
NOTICE:  truncated partition "girls" for relation "rank" and its children
drop table rank cascade;
alter table hhh exchange partition cc with table nosuchtable with validation;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh exchange partition cc with table nosuchtable without validation;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh exchange partition aa with table nosuchtable with validation;
ERROR:  relation "nosuchtable" does not exist
alter table hhh exchange partition aa with table nosuchtable without validation;
ERROR:  relation "nosuchtable" does not exist
alter table hhh merge partition cc, partition dd;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh merge partition cc, partition dd into partition ee;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh merge partition aa, partition dd into partition ee;
ERROR:  partition "dd" of relation "hhh" does not exist
alter table hhh modify partition cc add values ('a');
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh modify partition cc drop values ('a');
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh modify partition aa add values ('a');
ERROR:  invalid use of LIST boundary specification in partition "aa" of type RANGE
alter table hhh modify partition aa drop values ('a');
ERROR:  invalid use of LIST boundary specification in partition "aa" of type RANGE
create table mmm_r1 (a char(1), b date, d char(3))
distributed by (a)
partition by range (b)
(
partition aa start (date '2007-01-01') end (date '2008-01-01')
             every (interval '1 month')
);
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_1" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_2" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_3" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_4" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_5" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_6" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_7" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_8" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_9" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_10" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_11" for table "mmm_r1"
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_aa_12" for table "mmm_r1"
create table mmm_l1 (a char(1), b char(1), d char(3))
distributed by (a)
partition by list (b)
(
partition aa values ('a', 'b', 'c'),
partition bb values ('d', 'e', 'f'),
partition cc values ('g', 'h', 'i')
);
NOTICE:  CREATE TABLE will create partition "mmm_l1_1_prt_aa" for table "mmm_l1"
NOTICE:  CREATE TABLE will create partition "mmm_l1_1_prt_bb" for table "mmm_l1"
NOTICE:  CREATE TABLE will create partition "mmm_l1_1_prt_cc" for table "mmm_l1"
alter table mmm_r1 drop partition for ('2007-03-01');
NOTICE:  dropped partition "aa_3" for relation "mmm_r1"
-- ok
alter table mmm_r1 add partition bb START ('2007-03-03') END ('2007-03-20');
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_bb" for table "mmm_r1"
-- fail
alter table mmm_r1 modify partition for (rank(-55)) start ('2007-03-02');
ERROR:  partition for rank -55 of relation "mmm_r1" does not exist
alter table mmm_r1 modify partition for ('2001-01-01') start ('2007-03-02');
ERROR:  partition for value ('2001-01-01') of relation "mmm_r1" does not exist
alter table mmm_r1 modify partition bb start ('2006-03-02');
ERROR:  cannot MODIFY RANGE partition "bb" for relation "mmm_r1" -- would overlap existing partition "aa_2"
alter table mmm_r1 modify partition bb start ('2011-03-02');
ERROR:  START greater than END for partition "bb"
alter table mmm_r1 modify partition bb end ('2006-03-02');
ERROR:  START greater than END for partition "bb"
alter table mmm_r1 modify partition bb end ('2011-03-02');
ERROR:  cannot MODIFY RANGE partition "bb" for relation "mmm_r1" -- would overlap existing partition "aa_4"
alter table mmm_r1 modify partition bb add values ('2011-03-02');
ERROR:  invalid use of LIST boundary specification in partition "bb" of type RANGE
alter table mmm_r1 modify partition bb drop values ('2011-03-02');
ERROR:  invalid use of LIST boundary specification in partition "bb" of type RANGE
--ok
alter table mmm_r1 modify partition bb START ('2007-03-02') END ('2007-03-22');
alter table mmm_r1 modify partition bb START ('2007-03-01') END ('2007-03-31');
alter table mmm_r1 modify partition bb START ('2007-03-02') END ('2007-03-22');
-- with default
alter table mmm_r1 add default partition def1;
NOTICE:  CREATE TABLE will create partition "mmm_r1_1_prt_def1" for table "mmm_r1"
-- now fail
alter table mmm_r1 modify partition bb START ('2007-03-01') END ('2007-03-31');
ERROR:  cannot MODIFY RANGE partition "bb" for relation "mmm_r1" to extend range -- would overlap DEFAULT partition "def1"
HINT:  need to SPLIT partition "def1"
-- still ok to reduce range
alter table mmm_r1 modify partition bb START ('2007-03-09') END ('2007-03-10');
-- fail
alter table mmm_l1 modify partition for (rank(1)) drop values ('k');
ERROR:  cannot find partition by RANK -- relation "mmm_l1" is LIST partitioned
alter table mmm_l1 modify partition for ('j') drop values ('k');
ERROR:  partition for value ('j') of relation "mmm_l1" does not exist
alter table mmm_l1 modify partition for ('a') drop values ('k');
ERROR:  cannot MODIFY LIST partition "aa" for relation "mmm_l1" -- DROP value not found
alter table mmm_l1 modify partition for ('a') drop values ('e');
ERROR:  cannot MODIFY LIST partition "aa" for relation "mmm_l1" -- found DROP value in partition "bb"
alter table mmm_l1 modify partition for ('a') add values ('e');
ERROR:  cannot MODIFY LIST partition "aa" for relation "mmm_l1" -- would overlap existing partition "bb"
alter table mmm_l1 modify partition for ('a') START ('2007-03-09') ;
ERROR:  invalid use of RANGE boundary specification in partition "aa" of type LIST
--ok
alter table mmm_l1 modify partition for ('a') drop values ('b');
alter table mmm_l1 modify partition for ('a') add values ('z');
-- with default
alter table mmm_l1 add default partition def1;
NOTICE:  CREATE TABLE will create partition "mmm_l1_1_prt_def1" for table "mmm_l1"
-- ok
alter table mmm_l1 modify partition for ('a') drop values ('c');
-- now fail
alter table mmm_l1 modify partition for ('a') add values ('y');
ERROR:  cannot MODIFY LIST partition "aa" for relation "mmm_l1" to ADD values -- would overlap DEFAULT partition "def1"
HINT:  need to SPLIT partition "def1"
-- XXX XXX: add some data 
drop table mmm_r1 cascade;
drop table mmm_l1 cascade;
alter table hhh rename partition cc to aa;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh rename partition aa to aa;
ERROR:  partition "aa" of relation "hhh" already exists
alter table hhh rename partition aa to "funky fresh";
alter table hhh rename partition "funky fresh" to aa;
-- use FOR PARTITION VALUE (with implicate date conversion)
alter table hhh rename partition for ('2007-01-01') to "funky fresh";
NOTICE:  renamed partition "aa" to "funky fresh" for relation "hhh"
alter table hhh rename partition for ('2007-01-01') to aa;
NOTICE:  renamed partition "funky fresh" to "aa" for relation "hhh"
alter table hhh set subpartition template ();
ERROR:  relation "hhh" does not have a level 1 subpartition template specification
alter table hhh split partition cc at ('a');
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh split partition cc at ('a') into (partition gg, partition hh);
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh split partition aa at ('a');
ERROR:  invalid input syntax for type date: "a"
alter table hhh truncate partition cc;
ERROR:  partition "cc" of relation "hhh" does not exist
alter table hhh truncate partition aa;
insert into hhh values('a', date '2007-01-02', 'b');
insert into hhh values('a', date '2007-02-01', 'b');
insert into hhh values('a', date '2007-03-01', 'b');
insert into hhh values('a', date '2007-04-01', 'b');
insert into hhh values('a', date '2007-05-01', 'b');
insert into hhh values('a', date '2007-06-01', 'b');
insert into hhh values('a', date '2007-07-01', 'b');
insert into hhh values('a', date '2007-08-01', 'b');
insert into hhh values('a', date '2007-09-01', 'b');
insert into hhh values('a', date '2007-10-01', 'b');
insert into hhh values('a', date '2007-11-01', 'b');
insert into hhh values('a', date '2007-12-01', 'b');
insert into hhh values('a', date '2008-01-02', 'b');
insert into hhh values('a', date '2008-02-01', 'b');
insert into hhh values('a', date '2008-03-01', 'b');
insert into hhh values('a', date '2008-04-01', 'b');
insert into hhh values('a', date '2008-05-01', 'b');
insert into hhh values('a', date '2008-06-01', 'b');
insert into hhh values('a', date '2008-07-01', 'b');
insert into hhh values('a', date '2008-08-01', 'b');
insert into hhh values('a', date '2008-09-01', 'b');
insert into hhh values('a', date '2008-10-01', 'b');
insert into hhh values('a', date '2008-11-01', 'b');
insert into hhh values('a', date '2008-12-01', 'b');
select * from hhh;
 a |     b      |  d  
---+------------+-----
 a | 01-02-2007 | b  
 a | 02-01-2007 | b  
 a | 03-01-2007 | b  
 a | 04-01-2007 | b  
 a | 05-01-2007 | b  
 a | 06-01-2007 | b  
 a | 07-01-2007 | b  
 a | 08-01-2007 | b  
 a | 09-01-2007 | b  
 a | 10-01-2007 | b  
 a | 11-01-2007 | b  
 a | 12-01-2007 | b  
 a | 01-02-2008 | b  
 a | 02-01-2008 | b  
 a | 03-01-2008 | b  
 a | 04-01-2008 | b  
 a | 05-01-2008 | b  
 a | 06-01-2008 | b  
 a | 07-01-2008 | b  
 a | 08-01-2008 | b  
 a | 09-01-2008 | b  
 a | 10-01-2008 | b  
 a | 11-01-2008 | b  
 a | 12-01-2008 | b  
(24 rows)

alter table hhh truncate partition aa;
select * from hhh;
 a |     b      |  d  
---+------------+-----
 a | 01-02-2008 | b  
 a | 02-01-2008 | b  
 a | 03-01-2008 | b  
 a | 04-01-2008 | b  
 a | 05-01-2008 | b  
 a | 06-01-2008 | b  
 a | 07-01-2008 | b  
 a | 08-01-2008 | b  
 a | 09-01-2008 | b  
 a | 10-01-2008 | b  
 a | 11-01-2008 | b  
 a | 12-01-2008 | b  
(12 rows)

alter table hhh truncate partition bb;
select * from hhh;
 a | b | d 
---+---+---
(0 rows)

insert into hhh values('a', date '2007-01-02', 'b');
insert into hhh values('a', date '2007-02-01', 'b');
insert into hhh values('a', date '2007-03-01', 'b');
insert into hhh values('a', date '2007-04-01', 'b');
insert into hhh values('a', date '2007-05-01', 'b');
insert into hhh values('a', date '2007-06-01', 'b');
insert into hhh values('a', date '2007-07-01', 'b');
insert into hhh values('a', date '2007-08-01', 'b');
insert into hhh values('a', date '2007-09-01', 'b');
insert into hhh values('a', date '2007-10-01', 'b');
insert into hhh values('a', date '2007-11-01', 'b');
insert into hhh values('a', date '2007-12-01', 'b');
insert into hhh values('a', date '2008-01-02', 'b');
insert into hhh values('a', date '2008-02-01', 'b');
insert into hhh values('a', date '2008-03-01', 'b');
insert into hhh values('a', date '2008-04-01', 'b');
insert into hhh values('a', date '2008-05-01', 'b');
insert into hhh values('a', date '2008-06-01', 'b');
insert into hhh values('a', date '2008-07-01', 'b');
insert into hhh values('a', date '2008-08-01', 'b');
insert into hhh values('a', date '2008-09-01', 'b');
insert into hhh values('a', date '2008-10-01', 'b');
insert into hhh values('a', date '2008-11-01', 'b');
insert into hhh values('a', date '2008-12-01', 'b');
select * from hhh;
 a |     b      |  d  
---+------------+-----
 a | 01-02-2007 | b  
 a | 02-01-2007 | b  
 a | 03-01-2007 | b  
 a | 04-01-2007 | b  
 a | 05-01-2007 | b  
 a | 06-01-2007 | b  
 a | 07-01-2007 | b  
 a | 08-01-2007 | b  
 a | 09-01-2007 | b  
 a | 10-01-2007 | b  
 a | 11-01-2007 | b  
 a | 12-01-2007 | b  
 a | 01-02-2008 | b  
 a | 02-01-2008 | b  
 a | 03-01-2008 | b  
 a | 04-01-2008 | b  
 a | 05-01-2008 | b  
 a | 06-01-2008 | b  
 a | 07-01-2008 | b  
 a | 08-01-2008 | b  
 a | 09-01-2008 | b  
 a | 10-01-2008 | b  
 a | 11-01-2008 | b  
 a | 12-01-2008 | b  
(24 rows)

-- truncate child partitions recursively
truncate table hhh;
select * from hhh;
 a | b | d 
---+---+---
(0 rows)

drop table hhh cascade;
-- default partitions
-- hash partitions cannot have default partitions
create table jjj (aa int, bb int) 
partition by hash(bb) 
(partition j1, partition j2, default partition j3);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  invalid use of DEFAULT partition for partition "j3" of type HASH
LINE 3: (partition j1, partition j2, default partition j3);
                                     ^
-- default partitions cannot have boundary specifications
create table jjj (aa int, bb date) 
partition by range(bb) 
(partition j1 end (date '2008-01-01'), 
partition j2 end (date '2009-01-01'), 
default partition j3 end (date '2010-01-01'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  invalid use of boundary specification for DEFAULT partition "j3"
LINE 5: default partition j3 end (date '2010-01-01'));
        ^
-- more than one default partition
create table jjj (aa int, bb date) 
partition by range(bb) 
(partition j1 end (date '2008-01-01'), 
partition j2 end (date '2009-01-01'), 
default partition j3,
default partition j4);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  multiple default partitions are not allowed
LINE 6: default partition j4);
        ^
-- check default
create table foz (i int, d date) distributed by (i)
partition by range (d) 
(
 default partition dsf,
 partition foo start (date '2001-01-01') end (date '2005-01-01')
               every(interval '1 year')
);
NOTICE:  CREATE TABLE will create partition "foz_1_prt_dsf" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_foo_1" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_foo_2" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_foo_3" for table "foz"
NOTICE:  CREATE TABLE will create partition "foz_1_prt_foo_4" for table "foz"
insert into foz values(1, '2003-04-01');
insert into foz values(2, '2010-04-01');
select * from foz;
 i |     d      
---+------------
 1 | 04-01-2003
 2 | 04-01-2010
(2 rows)

select * from foz_1_prt_dsf;
 i |     d      
---+------------
 2 | 04-01-2010
(1 row)

drop table foz cascade;
-- check for out of order partition definitions. We should order these correctly
-- and determine the appropriate boundaries.
create table d (i int, j int) distributed by (i) partition by range(j)
( start (10), start(5), start(50) end(60));
NOTICE:  CREATE TABLE will create partition "d_1_prt_1" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_2" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_3" for table "d"
insert into d values(1, 5);
insert into d values(1, 10);
insert into d values(1, 11);
insert into d values(1, 55);
insert into d values(1, 70);
ERROR:  no partition for partitioning key  (seg0 localhost:12001 pid=29883)
select * from d;
 i | j  
---+----
 1 |  5
 1 | 10
 1 | 11
 1 | 55
(4 rows)

select * from d_1_prt_1;
 i | j 
---+---
 1 | 5
(1 row)

select * from d_1_prt_2;
 i | j  
---+----
 1 | 10
 1 | 11
(2 rows)

select * from d_1_prt_3;
 i | j  
---+----
 1 | 55
(1 row)

drop table d cascade;
-- check for NULL support
-- hash
create table d (i int, j int) partition by hash(j) partitions 4;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "d_1_prt_1" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_2" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_3" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_4" for table "d"
insert into d values(1, NULL);
insert into d values(NULL, NULL);
drop table d cascade;
-- list
create table d (i int, j int) partition by list(j)
(partition a values(1, 2, NULL),
 partition b values(3, 4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "d_1_prt_a" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_b" for table "d"
insert into d values(1, 1);
insert into d values(1, 2);
insert into d values(1, NULL);
insert into d values(1, 3);
insert into d values(1, 4);
select * from d_1_prt_a;
 i | j 
---+---
 1 | 1
 1 | 2
 1 |  
(3 rows)

select * from d_1_prt_b;
 i | j 
---+---
 1 | 3
 1 | 4
(2 rows)

drop table d cascade;
--range
-- Reject NULL values
create table d (i int,  j int) partition by range(j)
(partition a start (1) end(10), partition b start(11) end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "d_1_prt_a" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_b" for table "d"
insert into d values (1, 1);
insert into d values (1, 2);
insert into d values (1, NULL);
ERROR:  no partition for partitioning key  (seg0 localhost:12001 pid=29883)
drop table  d cascade;
-- allow NULLs into the default partition
create table d (i int,  j int) partition by range(j)
(partition a start (1) end(10), partition b start(11) end(20),
default partition abc);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "d_1_prt_abc" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_a" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_b" for table "d"
insert into d values (1, 1);
insert into d values (1, 2);
insert into d values (1, NULL);
select * from d_1_prt_abc;
 i | j 
---+---
 1 |  
(1 row)

drop table  d cascade;
-- multicolumn list support
create table d (a int, b int, c int) distributed by (a) 
partition by list(b, c)
(partition a values(('1', '2'), ('3', '4')),
 partition b values(('100', '20')),
 partition c values(('1000', '1001'), ('1001', '1002'), ('1003', '1004')));
NOTICE:  CREATE TABLE will create partition "d_1_prt_a" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_b" for table "d"
NOTICE:  CREATE TABLE will create partition "d_1_prt_c" for table "d"
insert into d values(1, 1, 2);
insert into d values(1, 3, 4);
insert into d values(1, 100, 20);
insert into d values(1, 100, 2000);
ERROR:  no partition for partitioning key  (seg0 localhost:12001 pid=29883)
insert into d values(1, '1000', '1001'), (1, '1001', '1002'), (1, '1003', '1004');
insert into d values(1, 100, NULL);
ERROR:  no partition for partitioning key  (seg0 localhost:12001 pid=29883)
select * from d_1_prt_a;
 a | b | c 
---+---+---
 1 | 1 | 2
 1 | 3 | 4
(2 rows)

select * from d_1_prt_b;
 a |  b  | c  
---+-----+----
 1 | 100 | 20
(1 row)

select * from d_1_prt_c;
 a |  b   |  c   
---+------+------
 1 | 1000 | 1001
 1 | 1001 | 1002
 1 | 1003 | 1004
(3 rows)

drop table d cascade;
-- test multi value range partitioning
create table b (i int, j date) distributed by (i)
partition by range (i, j)
(start(1, '2008-01-01') end (10, '2009-01-01'),
 start(1, '2009-01-01') end(15, '2010-01-01'),
 start(15, '2010-01-01') end (30, '2011-01-01'),
 start(1, '2011-01-01') end (100, '2012-01-01')
);
ERROR:  too many columns for RANGE partition -- only one column is allowed.
LINE 2: partition by range (i, j)
                     ^
-- should work
insert into b values(1, '2008-06-11');
ERROR:  relation "b" does not exist
insert into b values(11, '2009-08-24');
ERROR:  relation "b" does not exist
insert into b values(25, '2010-01-22');
ERROR:  relation "b" does not exist
insert into b values(90, '2011-05-04');
ERROR:  relation "b" does not exist
-- shouldn't work
insert into b values(1, '2019-01-01');
ERROR:  relation "b" does not exist
insert into b values(91, '2008-05-05');
ERROR:  relation "b" does not exist
 
select * from b_1_prt_1;
ERROR:  relation "b_1_prt_1" does not exist
LINE 1: select * from b_1_prt_1;
                      ^
select * from b_1_prt_2;
ERROR:  relation "b_1_prt_2" does not exist
LINE 1: select * from b_1_prt_2;
                      ^
select * from b_1_prt_3;
ERROR:  relation "b_1_prt_3" does not exist
LINE 1: select * from b_1_prt_3;
                      ^
select * from b_1_prt_4;
ERROR:  relation "b_1_prt_4" does not exist
LINE 1: select * from b_1_prt_4;
                      ^
drop table b;
ERROR:  table "b" does not exist
-- try some different combinations
create table b (i int, n numeric(20, 2), t timestamp, s text)
distributed by (i)
partition by range(n, t, s)
(
start(2000.99, '2007-01-01 00:00:00', 'AAA')
  end (4000.95, '2007-02-02 15:00:00', 'BBB'),
start(2000.99, '2007-01-01 00:00:00', 'BBB')
  end (4000.95, '2007-02-02 16:00:00', 'CCC'),
start(4000.95, '2007-01-01 00:00:00', 'AAA')
  end (7000.95, '2007-02-02 15:00:00', 'BBB')
);
ERROR:  too many columns for RANGE partition -- only one column is allowed.
LINE 3: partition by range(n, t, s)
                     ^
-- should work
insert into b values(1, 2000.99, '2007-01-01 00:00:00', 'AAA');
ERROR:  relation "b" does not exist
insert into b values(2, 2000.99, '2007-01-01 00:00:00', 'BBB');
ERROR:  relation "b" does not exist
insert into b values(3, 4000.95, '2007-01-01 00:00:00', 'AAA');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-02-02 15:30:00', 'BBC');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-02-02 15:30:00', 'CC');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-02-02 16:00:00'::timestamp - 
					'1 second'::interval, 'BBZZZZZZZZZZ');
ERROR:  relation "b" does not exist
-- should fail
insert into b values(6, 3000, '2007-02-02 15:30:00', 'CCCCCCC');
ERROR:  relation "b" does not exist
insert into b values(4, 5000, '2007-01-01 12:00:00', 'BCC');
ERROR:  relation "b" does not exist
insert into b values(5, 8000, '2007-01-01 12:00:00', 'ZZZ');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-02-02 16:00:00', 'ABZZZZZZZZZZ');
ERROR:  relation "b" does not exist
insert into b values(6, 1000, '2007-02-02 16:00:00', 'ABZZZZZZZZZZ');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2006-02-02 16:00:00', 'ABZZZZZZZZZZ');
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-02-02 00:00:00', 'A');
ERROR:  relation "b" does not exist
-- NULL tests
insert into b default values;
ERROR:  relation "b" does not exist
insert into b values(6, 3000, '2007-01-01 12:00:00', NULL);
ERROR:  relation "b" does not exist
drop table b;
ERROR:  table "b" does not exist
-- check that we detect subpartitions partitioning a column that is already
-- a partitioning target
create table a (i int, b int)
distributed by (i)
partition by range (i)
subpartition by hash(b) subpartitions 3,
subpartition by hash(b) subpartitions 2
(start(1) end(100),
 start(100) end(1000)
);
NOTICE:  CREATE TABLE will create partition "a_1_prt_1" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_1" for table "a_1_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_2" for table "a_1_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_3" for table "a_1_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_1_3_prt_1" for table "a_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_1_3_prt_2" for table "a_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_2_3_prt_1" for table "a_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_2_3_prt_2" for table "a_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_3_3_prt_1" for table "a_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "a_1_prt_1_2_prt_3_3_prt_2" for table "a_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_1" for table "a_1_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_2" for table "a_1_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_3" for table "a_1_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_1_3_prt_1" for table "a_1_prt_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_1_3_prt_2" for table "a_1_prt_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_2_3_prt_1" for table "a_1_prt_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_2_3_prt_2" for table "a_1_prt_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_3_3_prt_1" for table "a_1_prt_2_2_prt_3"
NOTICE:  CREATE TABLE will create partition "a_1_prt_2_2_prt_3_3_prt_2" for table "a_1_prt_2_2_prt_3"
-- MPP-3988: allow same column in multiple partitioning keys at
-- different levels -- so this is legal again...
drop table if exists a;
-- Check multi level partition COPY
CREATE TABLE REGION (
                    R_REGIONKEY INTEGER not null,
                    R_NAME CHAR(25),
                    R_COMMENT VARCHAR(152)
                    )
distributed by (r_regionkey)
partition by hash (r_regionkey) partitions 1
subpartition by hash (r_name) subpartitions 3
,subpartition by hash (r_comment) subpartitions 2
(
partition p1(subpartition sp1,subpartition sp2,subpartition sp3)
);
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1" for table "region"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp1" for table "region_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp2" for table "region_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp3" for table "region_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp1_3_prt_1" for table "region_1_prt_p1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp1_3_prt_2" for table "region_1_prt_p1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp2_3_prt_1" for table "region_1_prt_p1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp2_3_prt_2" for table "region_1_prt_p1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp3_3_prt_1" for table "region_1_prt_p1_2_prt_sp3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_p1_2_prt_sp3_3_prt_2" for table "region_1_prt_p1_2_prt_sp3"
create unique index region_pkey on region(r_regionkey);
NOTICE:  building index for child partition "region_1_prt_p1"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp1"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp2"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp3"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp1_3_prt_1"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp1_3_prt_2"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp2_3_prt_2"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp2_3_prt_1"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp3_3_prt_1"
NOTICE:  building index for child partition "region_1_prt_p1_2_prt_sp3_3_prt_2"
copy region from stdin with delimiter '|';
-- Test indexes
set enable_seqscan to off;
select * from region where r_regionkey = 1;
 r_regionkey |          r_name           |            r_comment            
-------------+---------------------------+---------------------------------
           1 | AMERICA                   | hs use ironic, even requests. s
(1 row)

select * from region where r_regionkey = 2;
 r_regionkey |          r_name           |            r_comment            
-------------+---------------------------+---------------------------------
           2 | ASIA                      | ges. thinly even pinto beans ca
(1 row)

select * from region where r_regionkey = 3;
 r_regionkey |          r_name           |                   r_comment                   
-------------+---------------------------+-----------------------------------------------
           3 | EUROPE                    | ly final courts cajole furiously final excuse
(1 row)

select * from region where r_regionkey = 4;
 r_regionkey |          r_name           |                        r_comment                         
-------------+---------------------------+----------------------------------------------------------
           4 | MIDDLE EAST               | uickly special accounts cajole carefully blithely close 
(1 row)

select * from region where r_regionkey = 5;
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           5 | AUSTRALIA                 | sdf
(1 row)

select * from region where r_regionkey = 6;
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           6 | ANTARCTICA                | dsfdfg
(1 row)

-- Test indexes with insert
-- start_matchsubs
--
-- # Note: insert is different partition depending on endianess
--
-- m/ERROR:.*duplicate key violates unique constraint.*region_1_prt_p1_2_prt_sp\d+_3_prt_1_pkey/
-- s/sp\d+/SPSOMETHING/
--
-- end_matchsubs
insert into region values(7, 'abc', 'def');
select * from region where r_regionkey = '7';
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           7 | abc                       | def
(1 row)

-- test duplicate key. We shouldn't really allow primary keys on partitioned
-- tables since we cannot enfoce them. But since this insert maps to a 
-- single definitive partition, we can detect it.
insert into region values(7, 'abc', 'def');
ERROR:  duplicate key violates unique constraint "region_pkey_1_prt_p1_2_prt_sp1_3_prt_1"  (seg0 localhost:12001 pid=29883)
drop table region;
-- exchange
-- 1) test all sanity checking
-- policies are different
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) distributed by (j);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  distribution policy for "bar_p" must be the same as that for "foo_p"
drop table foo_p;
drop table bar_p;
-- random policy vs. hash policy
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) distributed randomly;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  distribution policy for "bar_p" must be the same as that for "foo_p"
drop table foo_p;
drop table bar_p;
-- different number of columns
create table foo_p (i int, j int, k text) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  relation "bar_p" must have the same number columns as relation "foo_p"
drop table foo_p;
drop table bar_p;
-- different types
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int8) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  type mismatch for attribute "j"
drop table foo_p;
drop table bar_p;
-- different column names
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, m int) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  relation "bar_p" must have the same column names and column order as "foo_p"
drop table foo_p;
drop table bar_p;
-- different owner 
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) distributed by (i);
set session authorization part_role;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  must be owner of relation foo_p
-- back to super user
\c -
alter table bar_p owner to part_role;
set session authorization part_role;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  must be owner of relation foo_p
\c -
-- owners should be the same, error out 
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  owner of "bar_p" must be the same as that of "foo_p"
drop table foo_p;
drop table bar_p;
drop role part_role;
-- with and without OIDs
-- MPP-8405: disallow OIDS on partitioned tables 
create table foo_p (i int, j int) with (oids = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
ERROR:  OIDS=TRUE is not allowed on partitioned tables. Use OIDS=FALSE
-- but disallow exchange if different oid settings
create table foo_p (i int, j int) with (oids = false) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) with (oids = true) distributed by (i);
NOTICE:  OIDS=TRUE is not recommended for user-created tables. Use OIDS=FALSE to prevent wrap-around of the OID counter
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  "foo_p" and "bar_p" must have same OIDs setting
drop table foo_p;
drop table bar_p;
-- non-partition table involved in inheritance
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table barparent(i int, j int) distributed by (i);
create table bar_p () inherits(barparent);
NOTICE:  Table has parent, setting distribution columns to match parent table
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  cannot exchange table "bar_p" as it inherits other table(s)
drop table foo_p;
drop table bar_p;
drop table barparent;
-- non-partition table involved in inheritance
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
create table barchild () inherits(bar_p);
NOTICE:  Table has parent, setting distribution columns to match parent table
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  cannot EXCHANGE table "bar_p" as it has child table(s)
drop table foo_p;
drop table barchild;
drop table bar_p;
-- rules on non-partition table
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
create table baz_p(i int, j int) distributed by (i);
create rule bar_baz as on insert to bar_p do instead insert into baz_p
  values(NEW.i, NEW.j);
alter table foo_p exchange partition for(rank(2)) with table bar_p;
ERROR:  cannot exchange table which has rules defined on it
drop table foo_p, bar_p, baz_p;
-- Should fail: A constraint on bar_p isn't shared by all the parts.  
-- Allowing this would make an inconsistent partitioned table.  Note
-- that it is possible to have a constraint that prevents rows from 
-- going into one or more parts.  This isn't a conflict, though prior
-- versions would fail because "a constraint on bar_p conflicts with
-- partitioning rule". 
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int check (j > 1000)) distributed by (i);
alter table foo_p exchange partition for(rank(2)) with table bar_p;
ERROR:  invalid constraint(s) found on "bar_p": "bar_p_j_check"
HINT:  drop the invalid constraints and retry
drop table foo_p, bar_p;
-- Should fail: A constraint on bar_p isn't shared by all the parts.
-- Allowing this would make an inconsistent partitioned table. 
-- Prior versions allowed this, so parts could have differing constraints
-- as long as they avoided the partition columns.
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int check (i > 1000), j int) distributed by (i);
alter table foo_p exchange partition for(rank(2)) with table bar_p;
ERROR:  invalid constraint(s) found on "bar_p": "bar_p_i_check"
HINT:  drop the invalid constraints and retry
drop table foo_p, bar_p;
-- Shouldn't fail: check constraint matches partition rule.
-- Note this test is slightly different from prior versions to get
-- in line with constraint consistency requirement.
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int check (j >= 2 and j < 3 ))
distributed by (i);
insert into bar_p values(100000, 2);
alter table foo_p exchange partition for(rank(2)) with table bar_p;
insert into bar_p values(200000, 2);
select * from bar_p;
   i    | j 
--------+---
 200000 | 2
(1 row)

drop table foo_p, bar_p;
-- permissions
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table foo_p (i int) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
grant select on foo_p to part_role;
revoke all on bar_p from part_role;
select has_table_privilege('part_role', 'foo_p_1_prt_6'::regclass, 'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'bar_p'::regclass, 'select');
 has_table_privilege 
---------------------
 f
(1 row)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select has_table_privilege('part_role', 'foo_p_1_prt_6'::regclass, 'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'bar_p'::regclass, 'select');
 has_table_privilege 
---------------------
 f
(1 row)

drop table foo_p;
drop table bar_p;
drop role part_role;
-- validation
create table foo_p (i int) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into bar_p values(6);
insert into bar_p values(100);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  exchange table contains a row which violates the partitioning specification of "foo_p"  (seg1 localhost:12002 pid=29892)
alter table foo_p exchange partition for(rank(6)) with table bar_p without
validation;
select * from foo_p;
  i  
-----
   6
 100
(2 rows)

drop table foo_p, bar_p;
-- basic test
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 |  
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

-- test that we got the dependencies right
drop table bar_p;
select * from foo_p;
 i | j 
---+---
 6 |  
(1 row)

drop table foo_p;
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
-- Should fail.  Prior releases didn't convey constraints out via exchange
-- but we do now, so the following tries to insert a value that can't go
-- in part 6.
insert into bar_p values(10, 10);
ERROR:  new row for relation "bar_p" violates check constraint "foo_p_1_prt_6_check"  (seg1 localhost:12002 pid=29892)
drop table foo_p;
select * from bar_p;
 i | j 
---+---
(0 rows)

-- Should succeed.  Conveyed constraint matches.
insert into bar_p values(6, 6);
select * from bar_p;
 i | j 
---+---
 6 | 6
(1 row)

drop table bar_p;
-- AO exchange with heap
create table foo_p (i int, j int) with(appendonly = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into foo_p values(1, 1), (2, 1), (3, 1);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 2 | 1
 6 | 6
 1 | 1
 3 | 1
(4 rows)

drop table bar_p;
drop table foo_p;
-- other way around
create table foo_p (i int, j int) with(appendonly = false) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) with(appendonly = true) distributed by (i);
insert into foo_p values(1, 1), (2, 1), (3, 2);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 1 | 1
 3 | 2
 2 | 1
 6 | 6
(4 rows)

drop table bar_p;
drop table foo_p;
-- exchange AO with AO
create table foo_p (i int, j int) with(appendonly = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) with(appendonly = true) distributed by (i);
insert into foo_p values(1, 2), (2, 3), (3, 4);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 1 | 2
 3 | 4
 2 | 3
 6 | 6
(4 rows)

drop table bar_p;
drop table foo_p;
-- exchange same table more than once
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 | 6
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
(0 rows)

select * from bar_p;
 i | j 
---+---
 6 | 6
(1 row)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 | 6
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

drop table foo_p;
drop table bar_p;
-- XXX: not yet: VALIDATE parameter
-- Check for overflow of circular data types like time
-- Should fail
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '24:00') EVERY (INTERVAL '1 hour')
);
ERROR:  END parameter not reached before type overflows
LINE 4:   start (time '00:00') end (time '24:00') EVERY (INTERVAL '1...
                                         ^
-- Should fail
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '23:59') EVERY (INTERVAL '1 hour')
);
ERROR:  END parameter not reached before type overflows
LINE 4:   start (time '00:00') end (time '23:59') EVERY (INTERVAL '1...
                                         ^
-- Should work
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '23:00') EVERY (INTERVAL '1 hour')
);
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_1" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_2" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_3" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_4" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_5" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_6" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_7" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_8" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_9" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_10" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_11" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_12" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_13" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_14" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_15" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_16" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_17" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_18" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_19" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_20" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_21" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_22" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_23" for table "time_tbl_hour_2"
drop table TIME_TBL_HOUR_2;
-- Check for every parameters that just don't make sense
create table hhh_r1 (a char(1), b date, d char(3)) 
distributed by (a) partition by range (b)
(                                                              
partition aa start (date '2007-01-01') end (date '2008-01-01') 
      every (interval '0 days')
);
ERROR:  EVERY parameter too small
LINE 5:       every (interval '0 days')
                              ^
create table foo_p (i int) distributed by(i)
partition by range(i)
(start (1) end (20) every(0));
ERROR:  EVERY parameter too small
LINE 3: (start (1) end (20) every(0));
                                  ^
-- Check for ambiguous EVERY parameters
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (0.6));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (0.6));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (0.3));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (0.3));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (1.3));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (1.3));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (10.9));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (10.9));
                                   ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '0.5 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: ...('2007-01-01') end ('2008-01-01') every (interval '0.5 days'...
                                                             ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '0.5 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: ...('2007-01-01') end ('2008-01-01') every (interval '0.5 days'...
                                                             ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '12 hours'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: ...('2007-01-01') end ('2008-01-01') every (interval '12 hours'...
                                                             ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '1.2 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: ...('2007-01-01') end ('2008-01-01') every (interval '1.2 days'...
                                                             ^
-- should work
create table foo_p (i int, j timestamp) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2007-01-05') every (interval '1.2 days'));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
drop table foo_p;
-- test inclusive/exclusive
CREATE TABLE supplier2(
                S_SUPPKEY INTEGER,
                S_NAME CHAR(25),
                S_ADDRESS VARCHAR(40),
                S_NATIONKEY INTEGER,
                S_PHONECHAR char(15),
                S_ACCTBAL decimal,
				S_COMMENT VARCHAR(100)
)
partition by range (s_nationkey)
(
partition p1 start(0) , 
partition p2 start(12) end(13), 
partition p3 end(20) inclusive, 
partition p4 start(20) exclusive , 
partition p5 start(22) end(25)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 's_suppkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p1" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p2" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p3" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p4" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p5" for table "supplier2"
-- Make sure they're correctly ordered
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false),
parrangestartincl,
pg_get_expr(parrangeend, parchildrelid, false),parrangeendincl 
from pg_partition_rule  where
paroid in (select oid from pg_partition where parrelid = 'supplier2'::regclass)
order by parruleord;
 parname | parruleord | pg_get_expr | parrangestartincl | pg_get_expr | parrangeendincl 
---------+------------+-------------+-------------------+-------------+-----------------
 p1      |          1 | 0           | t                 | 12          | f
 p2      |          2 | 12          | t                 | 13          | f
 p3      |          3 | 13          | t                 | 20          | t
 p4      |          4 | 20          | f                 | 22          | f
 p5      |          5 | 22          | t                 | 25          | f
(5 rows)

insert into supplier2 (s_suppkey, s_nationkey) select i, i 
from generate_series(1, 24) i;
select * from supplier2_1_prt_p1 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
         1 |        |           |           1 |             |           | 
         2 |        |           |           2 |             |           | 
         3 |        |           |           3 |             |           | 
         4 |        |           |           4 |             |           | 
         5 |        |           |           5 |             |           | 
         6 |        |           |           6 |             |           | 
         7 |        |           |           7 |             |           | 
         8 |        |           |           8 |             |           | 
         9 |        |           |           9 |             |           | 
        10 |        |           |          10 |             |           | 
        11 |        |           |          11 |             |           | 
(11 rows)

select * from supplier2_1_prt_p2 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        12 |        |           |          12 |             |           | 
(1 row)

select * from supplier2_1_prt_p3 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        13 |        |           |          13 |             |           | 
        14 |        |           |          14 |             |           | 
        15 |        |           |          15 |             |           | 
        16 |        |           |          16 |             |           | 
        17 |        |           |          17 |             |           | 
        18 |        |           |          18 |             |           | 
        19 |        |           |          19 |             |           | 
        20 |        |           |          20 |             |           | 
(8 rows)

select * from supplier2_1_prt_p4 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        21 |        |           |          21 |             |           | 
(1 row)

select * from supplier2_1_prt_p5 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        22 |        |           |          22 |             |           | 
        23 |        |           |          23 |             |           | 
        24 |        |           |          24 |             |           | 
(3 rows)

drop table supplier2;
-- mpp3238
create table foo_p (i int) partition by range (i)
(
 partition p1 start('1') ,
 partition p2 start('2639161') ,
 partition p3 start('5957166') ,
 partition p4 start('5981976') end('5994376') inclusive,
 partition p5 end('6000001')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p5" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, pg_get_expr(parrangeend, parchildrelid, false) as end,
 pg_get_expr(parlistvalues, parchildrelid, false) as list from 
 pg_partition_rule
 r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and 
 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord |  start  |   end   | list 
---------+------------+---------+---------+------
 p1      |          1 | 1       | 2639161 | 
 p2      |          2 | 2639161 | 5957166 | 
 p3      |          3 | 5957166 | 5981976 | 
 p4      |          4 | 5981976 | 5994376 | 
 p5      |          5 | 5994376 | 6000001 | 
(5 rows)

insert into foo_p values(5994400);
insert into foo_p values(1);
insert into foo_p values(6000002);
ERROR:  no partition for partitioning key  (seg1 localhost:12002 pid=29892)
insert into foo_p values(5994376);
drop table foo_p;
create table foo_p (i int) 
partition by range(i)
(partition p1 start(1) end(5),
 partition p2 start(10),
 partition p3 end(10) exclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, pg_get_expr(parrangeend, parchildrelid, false) as end,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord | start | end | list 
---------+------------+-------+-----+------
 p1      |          1 | 1     | 5   | 
 p2      |          3 | 10    |     | 
 p3      |          2 | 5     | 10  | 
(3 rows)

drop table foo_p;
create table foo_p (i int) 
partition by range(i)
(partition p1 start(1) end(5),
 partition p2 start(10) exclusive,
 partition p3 end(10) inclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, parrangestartincl,
 pg_get_expr(parrangeend, parchildrelid, false) as end,
 parrangeendincl,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord | start | parrangestartincl | end | parrangeendincl | list 
---------+------------+-------+-------------------+-----+-----------------+------
 p1      |          1 | 1     | t                 | 5   | f               | 
 p2      |          3 | 10    | f                 |     | f               | 
 p3      |          2 | 5     | t                 | 10  | t               | 
(3 rows)

insert into foo_p values(1), (5), (10);
drop table foo_p;
-- MPP-3264
-- mix AO with master HEAP and see if copy works
create table foo_p (i int)
partition by list(i)
(partition p1 values(1, 2, 3) with (appendonly = true),
 partition p2 values(4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
copy foo_p from stdin;
select * from foo_p;
 i 
---
 1
 3
 2
 4
(4 rows)

select * from foo_p_1_prt_p1;
 i 
---
 2
 1
 3
(3 rows)

select * from foo_p_1_prt_p2;
 i 
---
 4
(1 row)

drop table foo_p;
-- other way around
create table foo_p (i int) with(appendonly = true)
partition by list(i)
(partition p1 values(1, 2, 3) with (appendonly = false),
 partition p2 values(4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
copy foo_p from stdin;
select * from foo_p;
 i 
---
 1
 3
 2
 4
(4 rows)

select * from foo_p_1_prt_p1;
 i 
---
 1
 3
 2
(3 rows)

select * from foo_p_1_prt_p2;
 i 
---
 4
(1 row)

drop table foo_p;
-- MPP-3283
CREATE TABLE PARTSUPP (
PS_PARTKEY INTEGER,
PS_SUPPKEY INTEGER,
PS_AVAILQTY integer,
PS_SUPPLYCOST decimal,
PS_COMMENT VARCHAR(199)
)
partition by range (ps_suppkey)
subpartition by range (ps_partkey)
,subpartition by range (ps_supplycost) subpartition template (start('1')
end('1001') every(500))
(
partition p1 start('1') end('10001') every(5000)
(subpartition sp1 start('1') end('200001') every(66666)
)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
insert into partsupp values(1,2,3325,771.64,', even theodolites. regular, final
theodolites eat after the carefully pending foxes. furiously regular deposits
sleep slyly. carefully bold realms above the ironic dependencies haggle
careful');
copy partsupp from stdin with delimiter '|';
drop table partsupp;
--MPP-3285
CREATE TABLE LINEITEM (
                L_ORDERKEY INT8,
                L_PARTKEY INTEGER,
                L_SUPPKEY INTEGER,
                L_LINENUMBER integer,
                L_QUANTITY decimal,
                L_EXTENDEDPRICE decimal,
                L_DISCOUNT decimal,
                L_TAX decimal,
                L_RETURNFLAG CHAR(1),
                L_LINESTATUS CHAR(1),
                L_SHIPDATE date,
                L_COMMITDATE date,
                L_RECEIPTDATE date,
                L_SHIPINSTRUCT CHAR(25),
                L_SHIPMODE CHAR(10),
                L_COMMENT VARCHAR(44)
                )
partition by range (l_commitdate)
(
partition p1 start('1992-01-31') end('1998-11-01') every(interval '20 months')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'l_orderkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "lineitem_1_prt_p1_1" for table "lineitem"
NOTICE:  CREATE TABLE will create partition "lineitem_1_prt_p1_2" for table "lineitem"
NOTICE:  CREATE TABLE will create partition "lineitem_1_prt_p1_3" for table "lineitem"
NOTICE:  CREATE TABLE will create partition "lineitem_1_prt_p1_4" for table "lineitem"
NOTICE:  CREATE TABLE will create partition "lineitem_1_prt_p1_5" for table "lineitem"
copy lineitem from stdin with delimiter '|';
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, parrangestartincl,
 pg_get_expr(parrangeend, parchildrelid, false) as end,
 parrangeendincl,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'lineitem'::regclass order by 1;
 parname | parruleord |       start        | parrangestartincl |        end         | parrangeendincl | list 
---------+------------+--------------------+-------------------+--------------------+-----------------+------
 p1_1    |          1 | '01-31-1992'::date | t                 | '09-30-1993'::date | f               | 
 p1_2    |          2 | '09-30-1993'::date | t                 | '05-31-1995'::date | f               | 
 p1_3    |          3 | '05-31-1995'::date | t                 | '01-31-1997'::date | f               | 
 p1_4    |          4 | '01-31-1997'::date | t                 | '09-30-1998'::date | f               | 
 p1_5    |          5 | '09-30-1998'::date | t                 | '11-01-1998'::date | f               | 
(5 rows)

drop table lineitem;
-- Make sure ADD creates dependencies
create table i (i int) partition by range(i) (start (1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i_1_prt_1" for table "i"
NOTICE:  CREATE TABLE will create partition "i_1_prt_2" for table "i"
alter table i add partition foo2 start(40) end (50);
NOTICE:  CREATE TABLE will create partition "i_1_prt_foo2" for table "i"
drop table i;
create table i (i int) partition by range(i) (start (1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i_1_prt_1" for table "i"
NOTICE:  CREATE TABLE will create partition "i_1_prt_2" for table "i"
alter table i add partition foo2 start(40) end (50);
NOTICE:  CREATE TABLE will create partition "i_1_prt_foo2" for table "i"
alter table i drop partition foo2;
drop table i;
-- dumpability of partition info
create table i5 (i int) partition by RANGE(i) (start(1) exclusive end(10)
inclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i5_1_prt_1" for table "i5"
select tablename, partitiontablename,
partitionboundary from pg_partitions where
tablename = 'i5';
 tablename | partitiontablename |           partitionboundary            
-----------+--------------------+----------------------------------------
 i5        | i5_1_prt_1         | START (1) EXCLUSIVE END (10) INCLUSIVE
(1 row)

select pg_get_partition_def('i5'::regclass, true);
               pg_get_partition_def               
--------------------------------------------------
 PARTITION BY RANGE(i)                            
           (                                      
           START (1) EXCLUSIVE END (10) INCLUSIVE 
           )
(1 row)

drop table i5;
CREATE TABLE PARTSUPP (
PS_PARTKEY INTEGER,
PS_SUPPKEY INTEGER,
PS_AVAILQTY integer,
PS_SUPPLYCOST decimal,
PS_COMMENT VARCHAR(199)
)
partition by range (ps_suppkey)
subpartition by range (ps_partkey)
,subpartition by range (ps_supplycost) subpartition template (start('1')
end('1001') every(500))
(
partition p1 start('1') end('10001') every(5000)
(subpartition sp1 start('1') end('200001') every(66666)
)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
select tablename, partitiontablename,
partitionboundary from pg_partitions where
tablename = 'partsupp';
 tablename |           partitiontablename            |                       partitionboundary                       
-----------+-----------------------------------------+---------------------------------------------------------------
 partsupp  | partsupp_1_prt_p1_1                     | PARTITION p1_1 START (1) END (5001) EVERY (5000)
 partsupp  | partsupp_1_prt_p1_2                     | PARTITION p1_2 START (5001) END (10001) EVERY (5000)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1         | SUBPARTITION sp1_1 START (1) END (66667) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2         | SUBPARTITION sp1_2 START (66667) END (133333) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3         | SUBPARTITION sp1_3 START (133333) END (199999) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4         | SUBPARTITION sp1_4 START (199999) END (200001) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1         | SUBPARTITION sp1_1 START (1) END (66667) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2         | SUBPARTITION sp1_2 START (66667) END (133333) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3         | SUBPARTITION sp1_3 START (133333) END (199999) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4         | SUBPARTITION sp1_4 START (199999) END (200001) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
(26 rows)

select pg_get_partition_def('partsupp'::regclass, true);
                                 pg_get_partition_def                                  
---------------------------------------------------------------------------------------
 PARTITION BY RANGE(ps_suppkey)                                                        
           SUBPARTITION BY RANGE(ps_partkey)                                           
                   SUBPARTITION BY RANGE(ps_supplycost)                                
           (                                                                           
           PARTITION p1 START (1) END (10001) EVERY (5000)                             
                   (                                                                   
                   SUBPARTITION sp1 START (1) END (200001) EVERY (66666)               
                           (                                                           
                           START (1::numeric) END (1001::numeric) EVERY (500::numeric) 
                           )                                                           
                   )                                                                   
           )
(1 row)

drop table partsupp;
set gp_enable_hash_partitioned_tables = true;
create table i5 (i int, g text) partition by list(g) 
  subpartition by hash(i) subpartitions 3
(partition p1 values('foo', 'bar'), partition p2 values('foz')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p1" for table "i5"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p2" for table "i5"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p1_2_prt_1" for table "i5_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p1_2_prt_2" for table "i5_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p1_2_prt_3" for table "i5_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p2_2_prt_1" for table "i5_1_prt_p2"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p2_2_prt_2" for table "i5_1_prt_p2"
NOTICE:  CREATE TABLE will create partition "i5_1_prt_p2_2_prt_3" for table "i5_1_prt_p2"
select tablename, partitiontablename,
partitionboundary from pg_partitions where
tablename = 'i5';
 tablename | partitiontablename  |         partitionboundary         
-----------+---------------------+-----------------------------------
 i5        | i5_1_prt_p1         | PARTITION p1 VALUES('foo', 'bar')
 i5        | i5_1_prt_p2         | PARTITION p2 VALUES('foz')
 i5        | i5_1_prt_p1_2_prt_1 | 
 i5        | i5_1_prt_p1_2_prt_2 | 
 i5        | i5_1_prt_p1_2_prt_3 | 
 i5        | i5_1_prt_p2_2_prt_1 | 
 i5        | i5_1_prt_p2_2_prt_2 | 
 i5        | i5_1_prt_p2_2_prt_3 | 
(8 rows)

select pg_get_partition_def('i5'::regclass, true);
                pg_get_partition_def                 
-----------------------------------------------------
 PARTITION BY LIST(g)                                
           SUBPARTITION BY HASH(i) SUBPARTITIONS 3   
           (                                         
           PARTITION p1 VALUES('foo', 'bar')         
                   (                                 
                   ),                                
           PARTITION p2 VALUES('foz')                
                   (                                 
                   )                                 
           )
(1 row)

drop table i5;
set gp_enable_hash_partitioned_tables = false;
-- ALTER TABLE ALTER PARTITION tests
CREATE TABLE rank2 (id int, rank int,
year date, gender char(1),
usstate char(2))
DISTRIBUTED BY (id, gender, year, usstate)
partition by list (gender)
subpartition by range (year)
subpartition template (
subpartition jan01 start (date '2001-01-01'),
subpartition jan02 start (date '2002-01-01'),
subpartition jan03 start (date '2003-01-01'),
subpartition jan04 start (date '2004-01-01'),
subpartition jan05 start (date '2005-01-01')
),
subpartition by list (usstate)
subpartition template (
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
(
  partition boys values ('M'),
  partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys" for table "rank2"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls" for table "rank2"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan01" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan02" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan03" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan04" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan05" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan01_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan01_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan01_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan02_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan02_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan02_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan03_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan03_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan03_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan04_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan04_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan04_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan05_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan05_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan05_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan01" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan02" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan03" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan04" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan05" for table "rank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan01_3_prt_mass" for table "rank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan01_3_prt_cali" for table "rank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan01_3_prt_ohio" for table "rank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan02_3_prt_mass" for table "rank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan02_3_prt_cali" for table "rank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan02_3_prt_ohio" for table "rank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan03_3_prt_mass" for table "rank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan03_3_prt_cali" for table "rank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan03_3_prt_ohio" for table "rank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan04_3_prt_mass" for table "rank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan04_3_prt_cali" for table "rank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan04_3_prt_ohio" for table "rank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan05_3_prt_mass" for table "rank2_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan05_3_prt_cali" for table "rank2_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_girls_2_prt_jan05_3_prt_ohio" for table "rank2_1_prt_girls_2_prt_jan05"
-- and without subpartition templates...
CREATE TABLE rank3 (id int, rank int,
year date, gender char(1),
usstate char(2))
DISTRIBUTED BY (id, gender, year, usstate)
partition by list (gender)
subpartition by range (year),
subpartition by list (usstate)
(
  partition boys values ('M') 
(
subpartition jan01 start (date '2001-01-01') 
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan02 start (date '2002-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan03 start (date '2003-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan04 start (date '2004-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan05 start (date '2005-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
)
,
  partition girls values ('F')
(
subpartition jan01 start (date '2001-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan02 start (date '2002-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan03 start (date '2003-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan04 start (date '2004-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan05 start (date '2005-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
)
);
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys" for table "rank3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls" for table "rank3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan01" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan02" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan03" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan04" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan05" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan01_3_prt_mass" for table "rank3_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan01_3_prt_cali" for table "rank3_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan01_3_prt_ohio" for table "rank3_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan02_3_prt_mass" for table "rank3_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan02_3_prt_cali" for table "rank3_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan02_3_prt_ohio" for table "rank3_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan03_3_prt_mass" for table "rank3_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan03_3_prt_cali" for table "rank3_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan03_3_prt_ohio" for table "rank3_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan04_3_prt_mass" for table "rank3_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan04_3_prt_cali" for table "rank3_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan04_3_prt_ohio" for table "rank3_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan05_3_prt_mass" for table "rank3_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan05_3_prt_cali" for table "rank3_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan05_3_prt_ohio" for table "rank3_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan01" for table "rank3_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan02" for table "rank3_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan03" for table "rank3_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan04" for table "rank3_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan05" for table "rank3_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan01_3_prt_mass" for table "rank3_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan01_3_prt_cali" for table "rank3_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan01_3_prt_ohio" for table "rank3_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan02_3_prt_mass" for table "rank3_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan02_3_prt_cali" for table "rank3_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan02_3_prt_ohio" for table "rank3_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan03_3_prt_mass" for table "rank3_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan03_3_prt_cali" for table "rank3_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan03_3_prt_ohio" for table "rank3_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan04_3_prt_mass" for table "rank3_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan04_3_prt_cali" for table "rank3_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan04_3_prt_ohio" for table "rank3_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan05_3_prt_mass" for table "rank3_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan05_3_prt_cali" for table "rank3_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_girls_2_prt_jan05_3_prt_ohio" for table "rank3_1_prt_girls_2_prt_jan05"
-- ok
alter table rank2 truncate partition girls;
NOTICE:  truncated partition "girls" for relation "rank2" and its children
alter table rank2 alter partition girls truncate partition for (rank(1));
NOTICE:  truncated partition "jan01" for partition "girls" of relation "rank2" and its children
alter table rank2 alter partition girls alter partition 
for (rank(1)) truncate partition mass;
NOTICE:  truncated partition "mass" for partition "jan01" of partition "girls" of relation "rank2"
-- don't NOTIFY of children if cascade
alter table rank2 truncate partition girls cascade;
-- fail - no rank 100
alter table rank2 alter partition girls truncate partition for (rank(100));
ERROR:  partition for rank 100 of partition "girls" of relation "rank2" does not exist
-- fail - no funky
alter table rank2 alter partition girls alter partition 
for (rank(1)) truncate partition "funky";
ERROR:  partition "funky" of partition "jan01" of partition "girls" of relation "rank2" does not exist
-- fail - no funky (drop)
alter table rank2 alter partition girls alter partition 
for (rank(1)) drop partition "funky";
ERROR:  partition "funky" of partition "jan01" of partition "girls" of relation "rank2" does not exist
-- fail - missing name
alter table rank2 alter partition girls alter partition 
for (rank(1)) drop partition ;
ERROR:  missing name or value for DROP for partition "jan01" of partition "girls" of relation "rank2"
-- ok
alter table rank2 alter partition girls drop partition 
for (rank(1)) ;
NOTICE:  dropped partition "jan01" for partition "girls" of relation "rank2" and its children
-- ok , skipping
alter table rank2 alter partition girls drop partition if exists jan01;
NOTICE:  partition "jan01" of partition "girls" of relation "rank2" does not exist, skipping
-- ok until run out of partitions
alter table rank2 alter partition girls drop partition ;
NOTICE:  dropped partition "jan02" for partition "girls" of relation "rank2" and its children
alter table rank2 alter partition girls drop partition ;
NOTICE:  dropped partition "jan03" for partition "girls" of relation "rank2" and its children
alter table rank2 alter partition girls drop partition ;
NOTICE:  dropped partition "jan04" for partition "girls" of relation "rank2" and its children
alter table rank2 alter partition girls drop partition ;
ERROR:  cannot drop partition "jan05" of partition "girls" of relation "rank2" -- only one remains
HINT:  DROP the parent partition to remove the final partition
alter table rank2 alter partition girls drop partition ;
ERROR:  cannot drop partition "jan05" of partition "girls" of relation "rank2" -- only one remains
HINT:  DROP the parent partition to remove the final partition
-- ok, skipping
alter table rank2 alter partition girls drop partition if exists for (rank(5));
NOTICE:  partition for specified rank of partition "girls" of relation "rank2" does not exist, skipping
-- ok
alter table rank2 alter partition girls rename partition jan05 
to "funky fresh";
NOTICE:  renamed partition "jan05" to "funky fresh" for partition "girls" of relation "rank2"
alter table rank2 alter partition girls rename partition "funky fresh"
to jan05;
NOTICE:  renamed partition "funky fresh" to "jan05" for partition "girls" of relation "rank2"
-- fail , not exist
alter table rank2 alter partition girls alter partition jan05 rename
partition jan01 to foo;
ERROR:  partition "jan01" of partition "jan05" of partition "girls" of relation "rank2" does not exist
-- fail not exist
alter table rank2 alter partition girls alter partition jan05 alter
partition cali rename partition foo to bar;
ERROR:  partition "foo" of partition "cali" of partition "jan05" of partition "girls" of relation "rank2" does not exist
-- fail not partitioned
alter table rank2 alter partition girls alter partition jan05 alter
partition cali alter partition foo drop partition bar;
ERROR:  partition "cali" of partition "jan05" of partition "girls" of relation "rank2" is not partitioned
-- ADD PARTITION, with and without templates
-- fails for rank2 (due to template), works for rank3
alter table rank2
add partition neuter values ('N')
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition bar values ('AZ')));
ERROR:  subpartition configuration conflicts with subpartition template
alter table rank3
add partition neuter values ('N')
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition bar values ('AZ')));
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter" for table "rank3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_1" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_2" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_3" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_4" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_5" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_6" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_7" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_8" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_9" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_10" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_11" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_12" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_1_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_1"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_2_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_2"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_3_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_4_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_4"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_5_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_5"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_6_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_6"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_7_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_7"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_8_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_8"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_9_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_9"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_10_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_10"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_11_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_11"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_12_3_prt_bar" for table "rank3_1_prt_neuter_2_prt_foo_12"
-- fail , no subpartition spec for rank3, works for rank2
alter table rank2 alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01');
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan00" for table "rank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan00_3_prt_mass" for table "rank2_1_prt_boys_2_prt_jan00"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan00_3_prt_cali" for table "rank2_1_prt_boys_2_prt_jan00"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan00_3_prt_ohio" for table "rank2_1_prt_boys_2_prt_jan00"
alter table rank3 alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01');
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan00" for table "rank3_1_prt_boys"
ERROR:  no partitions specified at depth 3
-- work - create subpartition for rank3, fail for rank2
alter table rank2 alter partition boys
add partition jan99 start ('1999-01-01') end ('2000-01-01')
  (subpartition ariz values ('AZ'));
ERROR:  subpartition configuration conflicts with subpartition template
alter table rank3 alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01')
  (subpartition ariz values ('AZ'));
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan00" for table "rank3_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan00_3_prt_ariz" for table "rank3_1_prt_boys_2_prt_jan00"
-- works for both -- adding leaf partition doesn't conflict with template
alter table rank2 alter partition boys
alter partition jan00 
add partition haw values ('HI');
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_boys_2_prt_jan00_3_prt_haw" for table "rank2_1_prt_boys_2_prt_jan00"
alter table rank3 alter partition boys
alter partition jan00 
add partition haw values ('HI');
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_boys_2_prt_jan00_3_prt_haw" for table "rank3_1_prt_boys_2_prt_jan00"
alter table rank2 drop partition neuter;
ERROR:  partition "neuter" of relation "rank2" does not exist
alter table rank3 drop partition neuter;
NOTICE:  dropped partition "neuter" for relation "rank3" and its children
-- fail , no subpartition spec for rank3, work for rank2
alter table rank2
add default partition neuter ;
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter" for table "rank2"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan01" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan02" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan03" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan04" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan05" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan01_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan01_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan01_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan01_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan02_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan02_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan02_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan02_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan03_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan03_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan03_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan03_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan04_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan04_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan04_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan04_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan05_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan05_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan05_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_jan05_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_jan05"
alter table rank3
add default partition neuter ;
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter" for table "rank3"
ERROR:  no partitions specified at depth 2
alter table rank2
add default partition neuter 
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition ariz values ('AZ')));
ERROR:  partition "neuter" of relation "rank2" already exists
alter table rank3
add default partition neuter 
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition ariz values ('AZ')));
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter" for table "rank3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_1" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_2" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_3" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_4" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_5" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_6" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_7" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_8" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_9" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_10" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_11" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_12" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_1_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_1"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_2_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_2"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_3_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_3"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_4_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_4"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_5_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_5"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_6_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_6"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_7_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_7"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_8_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_8"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_9_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_9"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_10_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_10"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_11_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_11"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_foo_12_3_prt_ariz" for table "rank3_1_prt_neuter_2_prt_foo_12"
-- fail
alter table rank2
alter default partition add default partition def1 
(subpartition haw values ('HI'));
ERROR:  subpartition configuration conflicts with subpartition template
-- fail
alter table rank2
alter default partition alter default partition 
add default partition def2;
ERROR:  DEFAULT partition of partition "neuter" of relation "rank2" does not exist
-- work
alter table rank2
alter default partition add default partition def1;
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1" for table "rank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1_3_prt_mass" for table "rank2_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1_3_prt_cali" for table "rank2_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1_3_prt_ohio" for table "rank2_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1_3_prt_haw" for table "rank2_1_prt_neuter_2_prt_def1"
alter table rank2
alter default partition alter default partition 
add default partition def2;
NOTICE:  CREATE TABLE will create partition "rank2_1_prt_neuter_2_prt_def1_3_prt_def2" for table "rank2_1_prt_neuter_2_prt_def1"
alter table rank3
alter default partition add default partition def1 
(subpartition haw values ('HI'));
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_def1" for table "rank3_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_def1_3_prt_haw" for table "rank3_1_prt_neuter_2_prt_def1"
alter table rank3
alter default partition alter default partition 
add default partition def2;
NOTICE:  CREATE TABLE will create partition "rank3_1_prt_neuter_2_prt_def1_3_prt_def2" for table "rank3_1_prt_neuter_2_prt_def1"
drop table rank2 ;
drop table rank3 ;
-- **END** ALTER TABLE ALTER PARTITION tests
-- Test casting
create table f (i int) partition by range (i) (start(1::int) end(10::int));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
create table f (i bigint) partition by range (i) (start(1::int8)
end(1152921504606846976::int8) every(576460752303423488));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
NOTICE:  CREATE TABLE will create partition "f_1_prt_2" for table "f"
drop table f;
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end(10000::bigint));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end(10000::text));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
--should fail. bool -> numeric makes no sense
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end('f'::bool));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot coerce RANGE partition parameter (false) to column type (numeric)
-- see that grant and revoke cascade to children
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table granttest (i int, j int) partition by range(i) 
subpartition by list(j) subpartition template (values(1, 2, 3))
(start(1) end(4) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_1" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_2" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_3" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_1_2_prt_1" for table "granttest_1_prt_1"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_2_2_prt_1" for table "granttest_1_prt_2"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_3_2_prt_1" for table "granttest_1_prt_3"
select has_table_privilege('part_role', 'granttest'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

grant select on granttest to part_role;
select has_table_privilege('part_role', 'granttest'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3_2_prt_1'::regclass,'select');
 has_table_privilege 
---------------------
 t
(1 row)

grant insert on granttest to part_role;
select has_table_privilege('part_role', 'granttest'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

revoke all on granttest from part_role;
select has_table_privilege('part_role', 'granttest'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_1_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_2_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'granttest_1_prt_3_2_prt_1'::regclass,'insert');
 has_table_privilege 
---------------------
 f
(1 row)

drop table granttest;
drop role part_role;
-- deep inline + optional subpartition comma:
CREATE TABLE partsupp (
    ps_partkey integer,
    ps_suppkey integer,
    ps_availqty integer,
    ps_supplycost numeric,
    ps_comment character varying(199)
) distributed by (ps_partkey) PARTITION BY RANGE(ps_suppkey)
          SUBPARTITION BY RANGE(ps_partkey)
                  SUBPARTITION BY RANGE(ps_supplycost) 
          (
          PARTITION p1_1 START (1) END (1666667) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_2 START (1666667) END (3333333) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_3 START (3333333) END (4999999) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_4 START (4999999) END (5000001) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  )
          );
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_1" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_2" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_1_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_1_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_2_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_2_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_1" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_2" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_1_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_1_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_2_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_2_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_1" for table "partsupp_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_2" for table "partsupp_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_1_3_prt_1" for table "partsupp_1_prt_p1_3_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_1_3_prt_2" for table "partsupp_1_prt_p1_3_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_2_3_prt_1" for table "partsupp_1_prt_p1_3_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_3_2_prt_2_3_prt_2" for table "partsupp_1_prt_p1_3_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_1" for table "partsupp_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_2" for table "partsupp_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_1_3_prt_1" for table "partsupp_1_prt_p1_4_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_1_3_prt_2" for table "partsupp_1_prt_p1_4_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_2_3_prt_1" for table "partsupp_1_prt_p1_4_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_4_2_prt_2_3_prt_2" for table "partsupp_1_prt_p1_4_2_prt_2"
drop table partsupp;
-- Accept negative values trivially:
create table partition_g (i int) partition by range(i) (start((-1)) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partition_g_1_prt_1" for table "partition_g"
drop table partition_g;
create table partition_g (i int) partition by range(i) (start(-1) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partition_g_1_prt_1" for table "partition_g"
drop table partition_g;
CREATE TABLE orders (
    o_orderkey bigint,
    o_custkey integer,
    o_orderstatus character(1),
    o_totalprice numeric,
    o_orderdate date,
    o_orderpriority character(15),
    o_clerk character(15),
    o_shippriority integer,
    o_comment character varying(79)
)
WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) PARTITION BY RANGE(o_orderdate)
          SUBPARTITION BY RANGE(o_custkey)
                  SUBPARTITION BY RANGE(o_orderkey) 
          (
          PARTITION p1_1 START ('1992-01-01'::date) END ('1993-06-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_2 START ('1993-06-01'::date) END ('1994-11-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_3 START ('1994-11-01'::date) END ('1996-04-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_4 START ('1996-04-01'::date) END ('1997-09-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_5 START ('1997-09-01'::date) END ('1998-08-03'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  )
          );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'o_orderkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1" for table "orders_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2" for table "orders_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1" for table "orders_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2" for table "orders_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1" for table "orders_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2" for table "orders_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1" for table "orders_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2" for table "orders_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1" for table "orders_1_prt_p1_5"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2" for table "orders_1_prt_p1_5"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_5_2_prt_sp2"
drop table orders;
-- grammar bug: MPP-3361
create table i2 (i int) partition by range(i) (start(-2::int) end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
create table i2 (i int) partition by range(i) (start((-2)::int) end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
create table i2 (i int) partition by range(i) (start(cast ((-2)::bigint as int))
end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
CREATE TABLE partsupp (
    ps_partkey integer,
    ps_suppkey integer,
    ps_availqty integer,
    ps_supplycost numeric,
    ps_comment character varying(199)
) PARTITION BY RANGE(ps_supplycost)
          (
          PARTITION newpart START ((-10000)::numeric) EXCLUSIVE END (1::numeric)
,
          PARTITION p1 START (1::numeric) END (1001::numeric)
          );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_newpart" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1" for table "partsupp"
drop table partsupp;
-- MPP-3379
drop table if exists tmp_nation;
NOTICE:  table "tmp_nation" does not exist, skipping
CREATE TABLE tmp_nation (N_NATIONKEY INTEGER, N_NAME CHAR(25), N_REGIONKEY INTEGER, N_COMMENT VARCHAR(152))  
partition by range (n_nationkey) 
 (
partition p1 start('0')  WITH (appendonly=true,checksum=true,blocksize=1998848,compresslevel=4),  
partition p2 start('11') end('15') inclusive WITH (checksum=false,appendonly=true,blocksize=655360,compresslevel=4),
partition p3 start('15') exclusive end('19'), partition p4 start('19')  WITH (compresslevel=8,appendonly=true,checksum=false,blocksize=884736), 
partition p5 start('20')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n_nationkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p1" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p2" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p3" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p4" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p5" for table "tmp_nation"
delete from tmp_nation;
drop table tmp_nation;
-- SPLIT tests
-- basic sanity tests. All should pass.
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
insert into k select i from generate_series(1, 100) i;
alter table k split partition mydef at (20) into (partition mydef, 
partition foo);
ERROR:  AT clause cannot be used when splitting a default RANGE partition
drop table k;
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
insert into j select i from generate_series(1, 8) i;
alter table j split partition for(1) at (2, 3) into (partition fa, partition
fb);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_6076623"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fa" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fb" for table "j"
select * from j_1_prt_fa;
 i 
---
 1
 4
(2 rows)

select * from j_1_prt_fb;
 i 
---
 3
 2
(2 rows)

alter table j split partition for(5) at (6);
NOTICE:  exchanged partition "b" of relation "j" with relation "pg_temp_6076623"
NOTICE:  dropped partition "b" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_r968951306" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_r1280956441" for table "j"
select * from j;
 i 
---
 1
 3
 5
 7
 4
 2
 8
 6
(8 rows)

-- should fail
alter table j split partition for (1) at (100);
ERROR:  AT clause parameter is not a member of the target partition specification
drop table j;
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
-- should fail
alter table k split default partition start(30) end (300) into (partition mydef, partition mydef);
ERROR:  both INTO partitions already exist
alter table k split partition for(3) at (20);
ERROR:  AT clause parameter is not a member of the target partition specification
drop table k;
-- should work
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
insert into k select i from generate_series(1, 30) i;
alter table k split default partition start(15) end(20) into
(partition mydef, partition foo);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_6077293"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foo" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
select * from k_1_prt_foo;
 i  
----
 15
 17
 19
 16
 18
(5 rows)

alter table k split default partition start(22) exclusive end(25) inclusive
into (partition bar, partition mydef);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_6077293"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_bar" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
select * from k_1_prt_bar;
 i  
----
 24
 23
 25
(3 rows)

alter table k split partition bar at (23) into (partition baz, partition foz);
NOTICE:  exchanged partition "bar" of relation "k" with relation "pg_temp_6077293"
NOTICE:  dropped partition "bar" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_baz" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foz" for table "k"
select partitiontablename,partitionposition,partitionrangestart,
       partitionrangeend from pg_partitions where tablename = 'k'
	   order by partitionposition;
 partitiontablename | partitionposition | partitionrangestart | partitionrangeend 
--------------------+-------------------+---------------------+-------------------
 k_1_prt_mydef      |                 0 |                     | 
 k_1_prt_2          |                 2 | 1                   | 3
 k_1_prt_3          |                 3 | 3                   | 5
 k_1_prt_4          |                 4 | 5                   | 7
 k_1_prt_5          |                 5 | 7                   | 9
 k_1_prt_6          |                 6 | 9                   | 10
 k_1_prt_foo        |                 7 | 15                  | 20
 k_1_prt_baz        |                 8 | 22                  | 23
 k_1_prt_foz        |                 9 | 23                  | 25
(9 rows)

drop table k;
-- Test errors for default handling
create table k (i int) partition by range(i) (start(1) end(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
alter table k split partition mydef at (25) into (partition foo, partition
mydef);
ERROR:  AT clause cannot be used when splitting a default RANGE partition
drop table k;
create table k (i int) partition by list(i) (values(1), values(2),
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_1" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split default partition start(10) end(20);
ERROR:  cannot SPLIT DEFAULT PARTITION with LIST
HINT:  Use SPLIT with the AT clause instead.
drop table k;
-- Check that we support int2
CREATE TABLE myINT2_TBL(q1 int2)
 partition by range (q1)
 (start (1) end (3) every (1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'q1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "myint2_tbl_1_prt_1" for table "myint2_tbl"
NOTICE:  CREATE TABLE will create partition "myint2_tbl_1_prt_2" for table "myint2_tbl"
insert into myint2_tbl values(1), (2);
drop table myint2_tbl;
-- check that we don't allow updates of tuples such that they would move
-- between partitions
create table v (i int, j int) partition by range(j) (start(1) end(5)
 every(2));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "v_1_prt_1" for table "v"
NOTICE:  CREATE TABLE will create partition "v_1_prt_2" for table "v"
insert into v values(1, 1) ;
-- should work
update v set j = 2;
-- should fail
update v set j = 3;
ERROR:  moving tuple from partition "v_1_prt_1" to partition "v_1_prt_2" not supported  (seg0 localhost:12001 pid=29891)
drop table v;
-- test AO seg totals
--
-- Note: ignore partition tablenames due to endianess issues
--
create  or replace function ao_ptotal(relname text) returns float8 as $$
declare
  aosegname text;
  tupcount float8 := 0;
  rc int := 0;
begin

  execute 'select relname from pg_class where oid=(select segrelid from pg_class, pg_appendonly where relname=''' || relname || ''' and relid = pg_class.oid)' into aosegname;
  if aosegname > 0 then
	  execute 'select tupcount from pg_aoseg.' || aosegname into tupcount;
  end if;
  return tupcount;
end; $$ language plpgsql volatile;
create table ao_p (i int) with (appendonly = true)
 partition by range(i)
 (start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_1" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_2" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_3" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_4" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_5" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_6" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_7" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_8" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_9" for table "ao_p"
insert into ao_p values(1), (2), (3);
-- start_ignore
select partitiontablename, ao_ptotal(partitiontablename)
from pg_partitions where tablename = 'ao_p';
 partitiontablename | ao_ptotal 
--------------------+-----------
 ao_p_1_prt_1       |         1
 ao_p_1_prt_2       |         1
 ao_p_1_prt_3       |         1
 ao_p_1_prt_4       |          
 ao_p_1_prt_5       |          
 ao_p_1_prt_6       |          
 ao_p_1_prt_7       |          
 ao_p_1_prt_8       |          
 ao_p_1_prt_9       |          
(9 rows)

-- end_ignore
truncate ao_p;
-- start_ignore
select partitiontablename, ao_ptotal(partitiontablename)
from pg_partitions where tablename = 'ao_p';
 partitiontablename | ao_ptotal 
--------------------+-----------
 ao_p_1_prt_1       |          
 ao_p_1_prt_2       |          
 ao_p_1_prt_3       |          
 ao_p_1_prt_4       |          
 ao_p_1_prt_5       |          
 ao_p_1_prt_6       |          
 ao_p_1_prt_7       |          
 ao_p_1_prt_8       |          
 ao_p_1_prt_9       |          
(9 rows)

-- end_ignore
copy ao_p from stdin;
-- start_ignore
select partitiontablename, ao_ptotal(partitiontablename)
from pg_partitions where tablename = 'ao_p';
 partitiontablename | ao_ptotal 
--------------------+-----------
 ao_p_1_prt_1       |          
 ao_p_1_prt_2       |          
 ao_p_1_prt_3       |          
 ao_p_1_prt_4       |         1
 ao_p_1_prt_5       |         1
 ao_p_1_prt_6       |         1
 ao_p_1_prt_7       |          
 ao_p_1_prt_8       |          
 ao_p_1_prt_9       |          
(9 rows)

-- end_ignore
-- try SREH
copy ao_p from stdin log errors into ao_p_err segment reject limit 100;
NOTICE:  Error table "ao_p_err" does not exist. Auto generating an error table with the same name
WARNING:  The error table was created in the same transaction as this operation. It will get dropped if transaction rolls back even if bad rows are present
HINT:  To avoid this create the error table ahead of time using: CREATE TABLE <name> (cmdtime timestamp with time zone, relname text, filename text, linenum integer, bytenum integer, errmsg text, rawdata text, rawbytes bytea)
NOTICE:  Found 2 data formatting errors (2 or more input rows). Errors logged into error table "ao_p_err"
-- start_ignore
select partitiontablename, ao_ptotal(partitiontablename)
from pg_partitions where tablename = 'ao_p';
 partitiontablename | ao_ptotal 
--------------------+-----------
 ao_p_1_prt_1       |          
 ao_p_1_prt_2       |          
 ao_p_1_prt_3       |          
 ao_p_1_prt_4       |         1
 ao_p_1_prt_5       |         1
 ao_p_1_prt_6       |         2
 ao_p_1_prt_7       |         1
 ao_p_1_prt_8       |          
 ao_p_1_prt_9       |          
(9 rows)

-- end_ignore
drop table ao_p;
-- MPP-3591: make sure we get inclusive/exclusive right with every().
create table k (i int) partition by range(i)
(start(0) exclusive end(100) inclusive every(25));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_1" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
select partitiontablename, partitionboundary from pg_partitions
where tablename = 'k' order by 1;
 partitiontablename |             partitionboundary             
--------------------+-------------------------------------------
 k_1_prt_1          | START (0) EXCLUSIVE END (25) EVERY (25)
 k_1_prt_2          | START (25) END (50) EVERY (25)
 k_1_prt_3          | START (50) END (75) EVERY (25)
 k_1_prt_4          | START (75) END (100) INCLUSIVE EVERY (25)
(4 rows)

insert into k select i from generate_series(1, 100) i;
drop table k;
-- ADD and SPLIT must get inherit permissions of the partition they're
-- modifying
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table a (a int, b int, c int) partition by range(a) subpartition by
range(b) subpartition template (subpartition h start(1) end(10)) 
subpartition by range(c)
subpartition template(subpartition i start(1) end(10)) 
(partition g start(1) end(2));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "a_1_prt_g" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g_2_prt_h" for table "a_1_prt_g"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g_2_prt_h_3_prt_i" for table "a_1_prt_g_2_prt_h"
revoke all on a from public;
grant insert on a to part_role;
-- revoke it from one existing partition, to make sure we don't screw up
-- existing permissions
revoke all on a_1_prt_g_2_prt_h_3_prt_i from part_role;
alter table a add partition b start(40) end(50);
NOTICE:  CREATE TABLE will create partition "a_1_prt_b" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_b_2_prt_h" for table "a_1_prt_b"
NOTICE:  CREATE TABLE will create partition "a_1_prt_b_2_prt_h_3_prt_i" for table "a_1_prt_b_2_prt_h"
set session authorization part_role;
select has_table_privilege('part_role', 'a'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h_3_prt_i'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_g_2_prt_h_3_prt_i'::regclass,
'insert');
 has_table_privilege 
---------------------
 f
(1 row)

insert into a values(45, 5, 5);
-- didn't grant select
select has_table_privilege('part_role', 'a'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h_3_prt_i'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

\c -
drop table a;
create table a (i date) partition by range(i) 
(partition f start(date '2005-01-01') end (date '2009-01-01')
	every(interval '2 years'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "a_1_prt_f_1" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_f_2" for table "a"
revoke all on a from public;
grant insert on a to part_role;
alter table a split partition for(rank(1)) at (date '2006-01-01')
  into (partition f, partition g);
NOTICE:  exchanged partition "f_1" of relation "a" with relation "pg_temp_6079289"
NOTICE:  dropped partition "f_1" for relation "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_f" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g" for table "a"
alter table a add default partition mydef;
NOTICE:  CREATE TABLE will create partition "a_1_prt_mydef" for table "a"
alter table a split default partition start(date '2010-01-01') end(date
'2011-01-01') into(partition mydef, partition other);
NOTICE:  exchanged partition "mydef" of relation "a" with relation "pg_temp_6079289"
NOTICE:  dropped partition "mydef" for relation "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_other" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_mydef" for table "a"
set session authorization part_role;
select has_table_privilege('part_role', 'a'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_f'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_mydef'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_other'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

insert into a values('2005-05-05');
insert into a values('2006-05-05');
insert into a values('2010-10-10');
\c -
drop table a;
drop role part_role;
-- Check that when we split a default, the INTO clause must named the default
create table k (i date) partition by range(i) (start('2008-01-01')
end('2009-01-01') every(interval '1 month'), default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_7" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_8" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_9" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_10" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_11" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_12" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_13" for table "k"
alter table k split default partition start ('2009-01-01') end ('2009-02-01')
into (partition aa, partition nodate);
ERROR:  default partition name missing from INTO clause
alter table k split default partition start ('2009-01-01') end ('2009-02-01')
into (partition aa, partition default_part);
NOTICE:  exchanged partition "default_part" of relation "k" with relation "pg_temp_6079731"
NOTICE:  dropped partition "default_part" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_aa" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
-- check that it works without INTO
alter table k split default partition start ('2009-02-01') end ('2009-03-01');
NOTICE:  exchanged partition "default_part" of relation "k" with relation "pg_temp_6079731"
NOTICE:  dropped partition "default_part" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_r529603788" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
drop table k;
-- List too
create table k (i int) partition by list(i) (partition a values(1, 2),
partition b values(3, 4), default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_a" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_b" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split partition mydef at (5) into (partition foo, partition bar);
ERROR:  default partition name missing from INTO clause
alter table k split partition mydef at (5) into (partition foo, partition mydef);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_6080531"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foo" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split partition mydef at (10);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_6080531"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_r87139744" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
drop table k;
-- For LIST, make sure that we reject AT() clauses which match all parameters
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
 partition b values(5, 6, 7, 8));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
alter table j split partition for(1) at (1,2) into (partition fa, partition fb);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_6080971"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fa" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fb" for table "j"
alter table j split partition for(1) at (1,2) 
into (partition f1a, partition f1b); -- This has partition rules that overlaps
ERROR:  AT clause cannot contain all values in partition "fb"
drop table j;
-- Check that we can split LIST partitions that have a default partition
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8), default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_default_part" for table "j"
alter table j split partition for(1) at (1,2) into (partition f1a, partition
f1b);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_6081229"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1b" for table "j"
drop table j;
-- Make sure range can too
create table j (i int) partition by range(i) (partition a start(1) end(10),
default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_default_part" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
alter table j split partition for(1) at (5) into (partition f1a, partition f1b);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_6081511"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1b" for table "j"
drop table j;
-- MPP-3667 ADD PARTITION overlaps
create table mpp3621 (aa date, bb date) partition by range (bb)
(partition foo start('2008-01-01'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_foo" for table "mpp3621"
-- these are ok
alter table mpp3621 add partition a1 start ('2007-01-01') end ('2007-02-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a1" for table "mpp3621"
alter table mpp3621 add partition a2 start ('2007-02-01') end ('2007-03-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a2" for table "mpp3621"
alter table mpp3621 add partition a3 start ('2007-03-01') end ('2007-04-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a3" for table "mpp3621"
alter table mpp3621 add partition a4 start ('2007-09-01') end ('2007-10-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a4" for table "mpp3621"
alter table mpp3621 add partition a5 start ('2007-08-01') end ('2007-09-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a5" for table "mpp3621"
alter table mpp3621 add partition a6 start ('2007-04-01') end ('2007-05-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a6" for table "mpp3621"
alter table mpp3621 add partition a7 start ('2007-05-01') end ('2007-06-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a7" for table "mpp3621"
 -- was error due to startSearchpoint != endSearchpoint
alter table mpp3621 add partition a8 start ('2007-07-01') end ('2007-08-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a8" for table "mpp3621"
-- ok
alter table mpp3621 add partition a9 start ('2007-06-01') end ('2007-07-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a9" for table "mpp3621"
drop table mpp3621;
-- Check for MPP-3679
create table list_test (a text, b text) partition by list (a) (partition foo
values ('foo'), partition bar values ('bar'), default partition baz);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_foo" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_bar" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_baz" for table "list_test"
alter table list_test split default partition at ('baz') into (partition bing,
default partition);
NOTICE:  exchanged partition "baz" of relation "list_test" with relation "pg_temp_6082240"
NOTICE:  dropped partition "baz" for relation "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_bing" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_baz" for table "list_test"
drop table list_test;
-- MPP-3816: cannot drop column  which is the subject of partition config
create table list_test(a int, b int, c int) distributed by (a)
  partition by list(b) 
  subpartition by list(c) subpartition template(subpartition c values(2))
  (partition b values(1));
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_b" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_b_2_prt_c" for table "list_test_1_prt_b"
-- should fail
alter table list_test drop column b;
ERROR:  cannot drop partitioning column "b"
alter table list_test drop column c;
ERROR:  cannot drop partitioning column "c"
drop table list_test;
-- MPP-3678: allow exchange and split on tables with subpartitioning
CREATE TABLE rank (
id int,
rank int,
year int,
gender char(1),
count int ) 
DISTRIBUTED BY (id)
PARTITION BY LIST (gender)
SUBPARTITION BY RANGE (year)
SUBPARTITION TEMPLATE (
SUBPARTITION year1 START (2001),
SUBPARTITION year2 START (2002),
SUBPARTITION year3 START (2003),
SUBPARTITION year4 START (2004),
SUBPARTITION year5 START (2005),
SUBPARTITION year6 START (2006) END (2007) )
(PARTITION girls VALUES ('F'),
PARTITION boys VALUES ('M')
);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year1" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year2" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year3" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year4" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year5" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_year6" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year1" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year2" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year3" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year4" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year5" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year6" for table "rank_1_prt_boys"
alter table rank alter partition girls add default partition gfuture;
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_gfuture" for table "rank_1_prt_girls"
alter table rank alter partition boys add default partition bfuture;
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_bfuture" for table "rank_1_prt_boys"
insert into rank values(1, 1, 2007, 'M', 1);
insert into rank values(2, 2, 2008, 'M', 3);
select * from rank;
 id | rank | year | gender | count 
----+------+------+--------+-------
  2 |    2 | 2008 | M      |     3
  1 |    1 | 2007 | M      |     1
(2 rows)

alter table rank alter partition boys split default partition start ('2007')
end ('2008') into (partition bfuture, partition year7);
NOTICE:  exchanged partition "bfuture" of partition "boys" of relation "rank" with relation "pg_temp_6082656"
NOTICE:  dropped partition "bfuture" for partition "boys" of relation "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_year7" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_bfuture" for table "rank_1_prt_boys"
select * from rank_1_prt_boys_2_prt_bfuture;
 id | rank | year | gender | count 
----+------+------+--------+-------
  2 |    2 | 2008 | M      |     3
(1 row)

select * from rank_1_prt_boys_2_prt_year7;
 id | rank | year | gender | count 
----+------+------+--------+-------
  1 |    1 | 2007 | M      |     1
(1 row)

select * from rank;
 id | rank | year | gender | count 
----+------+------+--------+-------
  1 |    1 | 2007 | M      |     1
  2 |    2 | 2008 | M      |     3
(2 rows)

--exchange test
create table r (like rank);
NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
insert into rank values(3, 3, 2004, 'F', 100);
insert into r values(3, 3, 2004, 'F', 100000);
alter table rank alter partition girls exchange partition year4 with table r;
NOTICE:  exchanged partition "year4" of partition "girls" of relation "rank" with relation "r"
select * from rank_1_prt_girls_2_prt_year4;
 id | rank | year | gender | count  
----+------+------+--------+--------
  3 |    3 | 2004 | F      | 100000
(1 row)

select * from r;
 id | rank | year | gender | count 
----+------+------+--------+-------
  3 |    3 | 2004 | F      |   100
(1 row)

alter table rank alter partition girls exchange partition year4 with table r;
NOTICE:  exchanged partition "year4" of partition "girls" of relation "rank" with relation "r"
select * from rank_1_prt_girls_2_prt_year4;
 id | rank | year | gender | count 
----+------+------+--------+-------
  3 |    3 | 2004 | F      |   100
(1 row)

select * from r;
 id | rank | year | gender | count  
----+------+------+--------+--------
  3 |    3 | 2004 | F      | 100000
(1 row)

-- Split test
alter table rank alter partition girls split default partition start('2008')
  end('2020') into (partition years, partition gfuture);
NOTICE:  exchanged partition "gfuture" of partition "girls" of relation "rank" with relation "pg_temp_6082656"
NOTICE:  dropped partition "gfuture" for partition "girls" of relation "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_years" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_gfuture" for table "rank_1_prt_girls"
insert into rank values(4, 4, 2009, 'F', 100);
drop table rank;
drop table r;
-- MPP-4245: remove virtual subpartition templates when we drop the partitioned
-- table
create table bar_p (i int, j int) partition by range(i) subpartition by range(j)
subpartition template(start(1) end(10) every(1)) subpartition by range(i)
subpartition template(start(1) end(10) every(5)) (start(1) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1" for table "bar_p"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1_3_prt_1" for table "bar_p_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1_3_prt_2" for table "bar_p_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2_3_prt_1" for table "bar_p_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2_3_prt_2" for table "bar_p_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3_3_prt_1" for table "bar_p_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3_3_prt_2" for table "bar_p_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4_3_prt_1" for table "bar_p_1_prt_1_2_prt_4"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4_3_prt_2" for table "bar_p_1_prt_1_2_prt_4"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5_3_prt_1" for table "bar_p_1_prt_1_2_prt_5"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5_3_prt_2" for table "bar_p_1_prt_1_2_prt_5"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6_3_prt_1" for table "bar_p_1_prt_1_2_prt_6"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6_3_prt_2" for table "bar_p_1_prt_1_2_prt_6"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7_3_prt_1" for table "bar_p_1_prt_1_2_prt_7"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7_3_prt_2" for table "bar_p_1_prt_1_2_prt_7"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8_3_prt_1" for table "bar_p_1_prt_1_2_prt_8"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8_3_prt_2" for table "bar_p_1_prt_1_2_prt_8"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9_3_prt_1" for table "bar_p_1_prt_1_2_prt_9"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9_3_prt_2" for table "bar_p_1_prt_1_2_prt_9"
alter table bar_p alter partition for ('5') alter partition for ('5')
  drop partition for ('5');
insert into bar_p values(1, 1);
insert into bar_p values(5, 5);
ERROR:  no partition for partitioning key  (seg0 localhost:12001 pid=29907)
drop table bar_p;
select parrelid::regclass, * from pg_partition;
 parrelid | parrelid | parkind | parlevel | paristemplate | parnatts | paratts | parclass 
----------+----------+---------+----------+---------------+----------+---------+----------
(0 rows)

select * from pg_partition_rule;
 paroid | parchildrelid | parparentrule | parname | parisdefault | parruleord | parrangestartincl | parrangeendincl | parrangestart | parrangeend | parrangeevery | parlistvalues | parreloptions | partemplatespace 
--------+---------------+---------------+---------+--------------+------------+-------------------+-----------------+---------------+-------------+---------------+---------------+---------------+------------------
(0 rows)

-- MPP-4172
-- should fail
create table ggg (a char(1), b int)
distributed by (b)
partition by range(a)
(
partition aa start ('2006') end ('2009'), partition bb start ('2007') end
('2008')
);
ERROR:  value too long for type character(1)
-- MPP-4892 SET SUBPARTITION TEMPLATE
create table mpp4892 (a char, b int, d char)
partition by range (b)
subpartition by list (d)
subpartition template (
 subpartition sp1 values ('a'),
 subpartition sp2 values ('b'))
(
start (1) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1_2_prt_sp1" for table "mpp4892_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1_2_prt_sp2" for table "mpp4892_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2_2_prt_sp1" for table "mpp4892_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2_2_prt_sp2" for table "mpp4892_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3_2_prt_sp1" for table "mpp4892_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3_2_prt_sp2" for table "mpp4892_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4_2_prt_sp1" for table "mpp4892_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4_2_prt_sp2" for table "mpp4892_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5_2_prt_sp1" for table "mpp4892_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5_2_prt_sp2" for table "mpp4892_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6_2_prt_sp1" for table "mpp4892_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6_2_prt_sp2" for table "mpp4892_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7_2_prt_sp1" for table "mpp4892_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7_2_prt_sp2" for table "mpp4892_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8_2_prt_sp1" for table "mpp4892_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8_2_prt_sp2" for table "mpp4892_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9_2_prt_sp1" for table "mpp4892_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9_2_prt_sp2" for table "mpp4892_1_prt_9"
-- works
alter table mpp4892 add partition p1 end (11);
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1_2_prt_sp1" for table "mpp4892_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1_2_prt_sp2" for table "mpp4892_1_prt_p1"
-- complain about existing template
alter table mpp4892 add partition p3 end (13) (subpartition sp3 values ('c'));
ERROR:  subpartition configuration conflicts with subpartition template
-- remove template
alter table mpp4892 set	subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp4892"
-- should work (because the template is gone)
alter table mpp4892 add partition p3 end (13) (subpartition sp3 values ('c'));
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p3" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p3_2_prt_sp3" for table "mpp4892_1_prt_p3"
-- complain because the template is already gone
alter table mpp4892 set	subpartition template ();
ERROR:  relation "mpp4892" does not have a level 1 subpartition template specification
-- should work
alter table mpp4892 set subpartition template (subpartition sp3 values ('c'));
NOTICE:  adding level 1 subpartition template specification for relation "mpp4892"
-- should work
alter table mpp4892 add partition p4 end (15);
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p4" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p4_2_prt_sp3" for table "mpp4892_1_prt_p4"
drop table mpp4892;
-- make sure we do not allow overlapping range intervals
-- should fail
-- unordered elems
create table ttt (t int) partition by range(t) (
partition a start (1) end(10) inclusive,
partition c start(11) end(14),
partition b start(5) end(15)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 4: partition b start(5) end(15)
                    ^
-- should fail, this time it's ordered
create table ttt (t int) partition by range(t) (
partition a start (1) end(10) inclusive,
partition b start(5) end(15),
partition c start(11) end(14)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start(5) end(15),
                    ^
-- should fail
create table ttt (t date) partition by range(t) (
partition a start ('2005-01-01') end('2006-01-01') inclusive,
partition b start('2005-05-01') end('2005-06-11'),
partition c start('2006-01-01') exclusive end('2006-01-10')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start('2005-05-01') end('2005-06-11'),
                    ^
-- should fail
create table ttt (t char) partition by range(t) (
partition a start('a') end('f'),
partition b start('e') end('g')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start('e') end('g')
                    ^
-- Test locking behaviour. When creating, dropping, querying or adding indexes
-- partitioned tables, we want to lock only the master, not the children.
-- start_ignore
create view locktest as
select coalesce(
  case when relname like 'pg_toast%index' then 'toast index'
  	   when relname like 'pg_toast%' then 'toast table'
	   else relname end, 'dropped table'), 
mode,
locktype from 
pg_locks l left outer join pg_class c on (l.relation = c.oid),
pg_database d where relation is not null and l.database = d.oid and 
l.gp_segment_id = -1 and
d.datname = current_database() order by 1, 3, 2;
-- end_ignore
-- Partitioned table with toast table
begin;
-- creation
create table g (i int, t text) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "g_1_prt_1" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_2" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_3" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_4" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_5" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_6" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_7" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_8" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_9" for table "g"
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 g                          | AccessExclusiveLock | relation
 gp_distribution_policy     | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_depend                  | RowExclusiveLock    | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | AccessShareLock     | relation
 pg_partition               | RowExclusiveLock    | relation
 pg_partition_rule          | RowExclusiveLock    | relation
 pg_type                    | RowExclusiveLock    | relation
 toast index                | AccessExclusiveLock | relation
 toast table                | ShareLock           | relation
(15 rows)

commit;
-- drop
begin;
drop table g;
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 gp_distribution_policy     | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_depend                  | RowExclusiveLock    | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | RowExclusiveLock    | relation
 pg_partition_rule          | RowExclusiveLock    | relation
 pg_type                    | RowExclusiveLock    | relation
(14 rows)

commit;
-- AO table (ao segments, block directory won't exist after create)
begin;
-- creation
create table g (i int, t text, n numeric)
with (appendonly = true)
partition by list(i)
(values(1), values(2), values(3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "g_1_prt_1" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_2" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_3" for table "g"
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 g                          | AccessExclusiveLock | relation
 gp_distribution_policy     | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_appendonly              | RowExclusiveLock    | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_depend                  | RowExclusiveLock    | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | AccessShareLock     | relation
 pg_partition               | RowExclusiveLock    | relation
 pg_partition_rule          | RowExclusiveLock    | relation
 pg_type                    | RowExclusiveLock    | relation
 toast index                | AccessExclusiveLock | relation
 toast table                | ShareLock           | relation
(16 rows)

commit;
begin;
-- add a little data
insert into g values(1), (2), (3);
insert into g values(1), (2), (3);
insert into g values(1), (2), (3);
insert into g values(1), (2), (3);
insert into g values(1), (2), (3);
select * from locktest;
          coalesce          |        mode         |         locktype         
----------------------------+---------------------+--------------------------
 g                          | AccessExclusiveLock | append-only segment file
 g                          | AccessShareLock     | relation
 g                          | RowExclusiveLock    | relation
 g_1_prt_1                  | AccessExclusiveLock | append-only segment file
 g_1_prt_1                  | AccessShareLock     | relation
 g_1_prt_2                  | AccessExclusiveLock | append-only segment file
 g_1_prt_2                  | AccessShareLock     | relation
 g_1_prt_3                  | AccessExclusiveLock | append-only segment file
 g_1_prt_3                  | AccessShareLock     | relation
 gp_fastsequence            | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_class                   | AccessShareLock     | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_locks                   | AccessShareLock     | relation
(15 rows)

commit;
-- drop
begin;
drop table g;
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 gp_distribution_policy     | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_appendonly              | RowExclusiveLock    | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_depend                  | RowExclusiveLock    | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | RowExclusiveLock    | relation
 pg_partition_rule          | RowExclusiveLock    | relation
 pg_type                    | RowExclusiveLock    | relation
(17 rows)

commit;
-- Indexing
create table g (i int, t text) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "g_1_prt_1" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_2" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_3" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_4" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_5" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_6" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_7" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_8" for table "g"
NOTICE:  CREATE TABLE will create partition "g_1_prt_9" for table "g"
begin;
create index g_idx on g(i);
NOTICE:  building index for child partition "g_1_prt_1"
NOTICE:  building index for child partition "g_1_prt_2"
NOTICE:  building index for child partition "g_1_prt_3"
NOTICE:  building index for child partition "g_1_prt_4"
NOTICE:  building index for child partition "g_1_prt_5"
NOTICE:  building index for child partition "g_1_prt_6"
NOTICE:  building index for child partition "g_1_prt_7"
NOTICE:  building index for child partition "g_1_prt_8"
NOTICE:  building index for child partition "g_1_prt_9"
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 g                          | ShareLock           | relation
 g_idx                      | AccessExclusiveLock | relation
 locktest                   | AccessShareLock     | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | AccessShareLock     | relation
 pg_partition_rule          | AccessShareLock     | relation
 pg_type                    | RowExclusiveLock    | relation
(11 rows)

commit;
-- test select locking
begin;
select * from g where i = 1;
 i | t 
---+---
(0 rows)

select * from locktest;
          coalesce          |      mode       | locktype 
----------------------------+-----------------+----------
 g                          | AccessShareLock | relation
 g_1_prt_1                  | AccessShareLock | relation
 g_idx                      | AccessShareLock | relation
 locktest                   | AccessShareLock | relation
 pg_class                   | AccessShareLock | relation
 pg_class_oid_index         | AccessShareLock | relation
 pg_class_relname_nsp_index | AccessShareLock | relation
 pg_locks                   | AccessShareLock | relation
(8 rows)

commit;
begin;
-- insert locking
insert into g values(3, 'f');
select * from locktest;
          coalesce          |       mode       | locktype 
----------------------------+------------------+----------
 g                          | RowExclusiveLock | relation
 locktest                   | AccessShareLock  | relation
 pg_class                   | AccessShareLock  | relation
 pg_class_oid_index         | AccessShareLock  | relation
 pg_class_relname_nsp_index | AccessShareLock  | relation
 pg_locks                   | AccessShareLock  | relation
(6 rows)

commit;
-- delete locking
begin;
delete from g where i = 4;
select * from locktest;
          coalesce          |       mode       | locktype 
----------------------------+------------------+----------
 g                          | ExclusiveLock    | relation
 g_1_prt_4                  | ExclusiveLock    | relation
 g_idx                      | RowExclusiveLock | relation
 locktest                   | AccessShareLock  | relation
 pg_class                   | AccessShareLock  | relation
 pg_class_oid_index         | AccessShareLock  | relation
 pg_class_relname_nsp_index | AccessShareLock  | relation
 pg_locks                   | AccessShareLock  | relation
(8 rows)

commit;
-- drop index
begin;
drop table g;
select * from locktest;
          coalesce          |        mode         | locktype 
----------------------------+---------------------+----------
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 dropped table              | AccessExclusiveLock | relation
 gp_distribution_policy     | RowExclusiveLock    | relation
 locktest                   | AccessShareLock     | relation
 pg_class                   | AccessShareLock     | relation
 pg_class                   | RowExclusiveLock    | relation
 pg_class_oid_index         | AccessShareLock     | relation
 pg_class_relname_nsp_index | AccessShareLock     | relation
 pg_depend                  | RowExclusiveLock    | relation
 pg_locks                   | AccessShareLock     | relation
 pg_partition               | RowExclusiveLock    | relation
 pg_partition_rule          | RowExclusiveLock    | relation
 pg_type                    | RowExclusiveLock    | relation
(15 rows)

commit;
-- MPP-5159
-- Should fail -- missing partition spec and subpartition template follows the
-- partition declaration.
CREATE TABLE list_sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'),
  SUBPARTITION asia VALUES ('asia'),
  SUBPARTITION europe VALUES ('europe')
);
ERROR:  syntax error at or near ";"
LINE 9: );
         ^
-- MPP-5185
-- Should work
CREATE TABLE rank (id int, rank int, year date, gender
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01'),
start (date '2002-01-01'),
start (date '2003-01-01'),
start (date '2004-01-01'),
start (date '2005-01-01')
)
(
partition boys values ('M'),
partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_1" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_2" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_3" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_4" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_boys_2_prt_5" for table "rank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_1" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_2" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_3" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_4" for table "rank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_girls_2_prt_5" for table "rank_1_prt_girls"
alter table rank set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "rank"
-- nothing there
select * from pg_partition_templates;
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

alter table rank set subpartition template (default subpartition def2);
NOTICE:  adding level 1 subpartition template specification for relation "rank"
-- def2 is there
select * from pg_partition_templates;
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |     partitionboundary      
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------
 public     | rank      | def2          | range         |              1 |             1 |                 1 |                     |                     | f                       |                   | f                     |                      | t                  | DEFAULT SUBPARTITION def2 
(1 row)

alter table rank set subpartition template (default subpartition def2);
NOTICE:  replacing level 1 subpartition template specification for relation "rank"
-- Should still be there
select * from pg_partition_templates;
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |     partitionboundary      
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------
 public     | rank      | def2          | range         |              1 |             1 |                 1 |                     |                     | f                       |                   | f                     |                      | t                  | DEFAULT SUBPARTITION def2 
(1 row)

drop table rank;
-- MPP-5397
-- should be able to add partition after dropped a col
create table mpp_5397 (a int, b int, c int) 
  distributed by (a) 
  partition by range (b)  
  (partition a1 start (0) end (5), 
   partition a2 end (10),  
   partition a3 end(15));
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a1" for table "mpp_5397"
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a2" for table "mpp_5397"
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a3" for table "mpp_5397"
alter table mpp_5397 drop column c;
-- should work now
alter table mpp_5397 add partition z end (20);
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_z" for table "mpp_5397"
drop table mpp_5397;
-- MPP-4987 -- make sure we can't damage a partitioning configuration
-- MPP-8405: disallow OIDS on partitioned tables 
create table rank (i int, j int) with oids partition by range(j) (start(1) end(10)
every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "rank_1_prt_1" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_2" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_3" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_4" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_5" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_6" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_7" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_8" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_9" for table "rank"
ERROR:  OIDS=TRUE is not allowed on partitioned tables. Use OIDS=FALSE
-- this works
create table rank (i int, j int)  partition by range(j) (start(1) end(10)
every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "rank_1_prt_1" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_2" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_3" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_4" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_5" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_6" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_7" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_8" for table "rank"
NOTICE:  CREATE TABLE will create partition "rank_1_prt_9" for table "rank"
-- should all fail
alter table rank_1_prt_1 no inherit rank;
ERROR:  can't alter inheritance on "rank_1_prt_1"; it is a partitioned table or part thereof
create table rank2(like rank);
NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
alter table rank_1_prt_1 inherit rank2;
ERROR:  can't alter inheritance on "rank_1_prt_1"; it is a partitioned table or part thereof
alter table rank_1_prt_1 alter column i type bigint;
ERROR:  can't alter a column datatype of "rank_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank_1_prt_1 set without oids;
ERROR:  can't alter the oid setting of "rank_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank_1_prt_1 drop constraint rank_1_prt_1_check;
ERROR:  can't drop a constraint from "rank_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank add partition ppo end (22) with (oids = true);
NOTICE:  CREATE TABLE will create partition "rank_1_prt_ppo" for table "rank"
ERROR:  OIDS=TRUE is not allowed on partitioned tables. Use OIDS=FALSE
drop table rank, rank2;
-- MPP-5831, type cast in SPLIT
CREATE TABLE sg_cal_event_silvertail_hour (
caldt date NOT NULL,
calhr smallint NOT NULL,
ip character varying(128),
transactionid character varying(32),
transactiontime timestamp(2) without time zone
)
WITH (appendonly=true, compresslevel=5)
distributed by (ip) PARTITION BY RANGE(transactiontime)
(
PARTITION "P2009041607"
START ('2009-04-16 07:00:00'::timestamp without time zone)
END ('2009-04-16 08:00:00'::timestamp without time zone),
PARTITION "P2009041608"
START ('2009-04-16 08:00:00'::timestamp without time zone)
END ('2009-04-16 09:00:00'::timestamp without time zone),
DEFAULT PARTITION st_default
);
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_st_default" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_P2009041607" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_P2009041608" for table "sg_cal_event_silvertail_hour"
ALTER TABLE SG_CAL_EVENT_SILVERTAIL_HOUR SPLIT DEFAULT PARTITION
START ('2009-04-29 07:00:00'::timestamp) INCLUSIVE END ('2009-04-29
08:00:00'::timestamp) EXCLUSIVE INTO ( PARTITION P2009042907 ,
PARTITION st_default );
NOTICE:  exchanged partition "st_default" of relation "sg_cal_event_silvertail_hour" with relation "pg_temp_6088365"
NOTICE:  dropped partition "st_default" for relation "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_p2009042907" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_st_default" for table "sg_cal_event_silvertail_hour"
drop table sg_cal_event_silvertail_hour;
-- Make sure we inherit master's storage settings
create table foo_p (i int, j int, k text)
with (appendonly = true, compresslevel = 5)
partition by range(j) (start(1) end(10) every(1), default partition def);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_10" for table "foo_p"
insert into foo_p select i, i+1, repeat('fooo', 9000) from generate_series(1, 100) i;
alter table foo_p split default partition start (10) end(20) 
into (partition p10_20, partition def);
NOTICE:  exchanged partition "def" of relation "foo_p" with relation "pg_temp_6088657"
NOTICE:  dropped partition "def" for relation "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p10_20" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
select reloptions from pg_class where relname = 'foo_p_1_prt_p10_20';
            reloptions             
-----------------------------------
 {appendonly=true,compresslevel=5}
(1 row)

select count(distinct k) from foo_p;
 count 
-------
     1
(1 row)

drop table foo_p;
create table foo_p (i int, j int, k text)
partition by range(j) (start(1) end(10) every(1), default partition def
with(appendonly = true));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_10" for table "foo_p"
insert into foo_p select i, i+1, repeat('fooo', 9000) from generate_series(1, 100) i;
alter table foo_p split default partition start (10) end(20) 
into (partition p10_20, partition def);
NOTICE:  exchanged partition "def" of relation "foo_p" with relation "pg_temp_6089243"
NOTICE:  dropped partition "def" for relation "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p10_20" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
select reloptions from pg_class where relname = 'foo_p_1_prt_p10_20';
    reloptions     
-------------------
 {appendonly=true}
(1 row)

select reloptions from pg_class where relname = 'foo_p_1_prt_def';
    reloptions     
-------------------
 {appendonly=true}
(1 row)

select count(distinct k) from foo_p;
 count 
-------
     1
(1 row)

drop table foo_p;
-- MPP-5878 - display correct partition boundary 
create table mpp5878 (a int, b char, d char)
partition by list (b,d)
(
values (('a','b'),('c','d')),
values (('e','f'),('g','h'))
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5878_1_prt_1" for table "mpp5878"
NOTICE:  CREATE TABLE will create partition "mpp5878_1_prt_2" for table "mpp5878"
select partitionlistvalues from pg_partitions where tablename like 'mpp5878%';
                partitionlistvalues                 
----------------------------------------------------
 'a'::bpchar, 'b'::bpchar, 'c'::bpchar, 'd'::bpchar
 'e'::bpchar, 'f'::bpchar, 'g'::bpchar, 'h'::bpchar
(2 rows)

select partitionboundary from pg_partitions where tablename like 'mpp5878%';
        partitionboundary         
----------------------------------
 VALUES( ('a', 'b'),  ('c', 'd'))
 VALUES( ('e', 'f'),  ('g', 'h'))
(2 rows)

drop table mpp5878;
-- MPP-5941: work with many levels of templates
CREATE TABLE mpp5941 (a int, b date, c char, 
	   		 		 d char(4), e varchar(20), f timestamp)
partition by range (b)
subpartition by list (a) 
subpartition template ( 
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) ),
subpartition by list (e) 
subpartition template ( 
subpartition ll1 values ('Engineering'), 
subpartition ll2 values ('QA') ),
subpartition by list (c) 
subpartition template ( 
subpartition lll1 values ('M'), 
subpartition lll2 values ('F') )
(
  start (date '2007-01-01')
  end (date '2010-01-01') every (interval '1 year')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1" for table "mpp5941_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2" for table "mpp5941_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1" for table "mpp5941_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2" for table "mpp5941_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1" for table "mpp5941_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2" for table "mpp5941_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2"
-- just truncate for fun to see that everything is there
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
truncate partition for ('M');
NOTICE:  truncated partition "lll1" for partition "ll2" of partition "l1" of partition for value ('2008-01-01') of relation "mpp5941"
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) truncate partition for ('QA');
NOTICE:  truncated partition "ll2" for partition "l1" of partition for value ('2008-01-01') of relation "mpp5941" and its children
alter table mpp5941 alter partition for ('2008-01-01') 
truncate partition for (1);
NOTICE:  truncated partition "l1" for partition for value ('2008-01-01') of relation "mpp5941" and its children
alter table mpp5941 truncate partition for ('2008-01-01') ;
NOTICE:  truncated partition for value ('2008-01-01') for relation "mpp5941" and its children
truncate table mpp5941;
-- now look at the templates that we have
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | l1            |              1
 mpp5941   | l2            |              1
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(6 rows)

-- clear level 1
alter table mpp5941 set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(4 rows)

-- clear level 2
alter table mpp5941 alter partition for ('2008-01-01') 
set subpartition template ();
NOTICE:  dropped level 2 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(2 rows)

-- clear level 3
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1)
set subpartition template ();
NOTICE:  dropped level 3 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- no level 4 (error)
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
set subpartition template ();
ERROR:  relation "mpp5941" does not have a level 4 subpartition template specification
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- no level 5 (error)
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
alter partition for ('M')
set subpartition template ();
ERROR:  relation "mpp5941" does not have a level 5 subpartition template specification
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- set level 1 (error, because no templates for level 2, 3)
alter table mpp5941 set subpartition template (
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5941"
ERROR:  no partitions specified at depth 3
-- MPP-5992 - add deep templates correctly
-- Note: need to re-add the templates from deepest to shallowest,
-- because adding a template has a dependency on the existence of the
-- deeper template.
-- set level 3
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1)
set subpartition template (
subpartition lll1 values ('M'), 
subpartition lll2 values ('F') );
NOTICE:  adding level 3 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(2 rows)

-- set level 2
alter table mpp5941 alter partition for ('2008-01-01') 
set subpartition template (
subpartition ll1 values ('Engineering'), 
subpartition ll2 values ('QA') );
NOTICE:  adding level 2 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
(4 rows)

-- set level 1
alter table mpp5941 set subpartition template (
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | l1            |              1
 mpp5941   | l2            |              1
(6 rows)

drop table mpp5941;
-- MPP-5984
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (NULL)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot use NULL with range partition specification
LINE 6: partition nnull start (300) end (NULL)
                                    ^
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (NULL::int)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot use NULL with range partition specification
LINE 6: partition nnull start (300) end (NULL::int)
                                    ^
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition p1 start(1) end(10),
partition p2 start(10) end(20),
default partition def
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_def" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p2" for table "partsupp"
alter table partsupp split partition p2 at (NULL);
ERROR:  AT clause parameter is not a member of the target partition specification
alter table partsupp split default partition start(null) end(200);
NOTICE:  exchanged partition "def" of relation "partsupp" with relation "pg_temp_6091945"
NOTICE:  dropped partition "def" for relation "partsupp"
ERROR:  cannot use NULL with range partition specification
drop table partsupp;
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (400)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_nnull" for table "partsupp"
alter table partsupp add partition foo start(500) end(NULL);
ERROR:  cannot use NULL with range partition specification
drop table partsupp;
--MPP-6240
CREATE TABLE supplier_hybrid_part(
                S_SUPPKEY INTEGER,
                S_NAME CHAR(25),
                S_ADDRESS VARCHAR(40),
                S_NATIONKEY INTEGER,                S_PHONE CHAR(15),
                S_ACCTBAL decimal,
                S_COMMENT VARCHAR(101)
                )
partition by range (s_suppkey) 
subpartition by list (s_nationkey) subpartition template (
    values('22','21','17'),
    values('6','11','1','7','16','2') WITH (checksum=false,appendonly=true,blocksize=1171456,         compresslevel=3),
    values('18','20'),
    values('9','23','13') WITH (checksum=true,appendonly=true,blocksize=1335296,compresslevel=7),
    values('0','3','12','15','14','8','4','24','19','10','5')
)               
(               
partition p1 start('1') end('10001') every(10000)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 's_suppkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1" for table "supplier_hybrid_part"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_1" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_2" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_3" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_4" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_5" for table "supplier_hybrid_part_1_prt_p1"
select pg_get_partition_def('supplier_hybrid_part'::regclass, true);
                                                   pg_get_partition_def                                                    
---------------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(s_suppkey)                                                                                             
           SUBPARTITION BY LIST(s_nationkey)                                                                               
           (                                                                                                               
           PARTITION p1 START (1) END (10001) EVERY (10000)                                                                
                   (                                                                                                       
                   VALUES(22, 21, 17),                                                                                     
                   VALUES(6, 11, 1, 7, 16, 2) WITH (checksum=false, appendonly=true, blocksize=1171456, compresslevel=3),  
                   VALUES(18, 20),                                                                                         
                   VALUES(9, 23, 13) WITH (checksum=true, appendonly=true, blocksize=1335296, compresslevel=7),            
                   VALUES(0, 3, 12, 15, 14, 8, 4, 24, 19, 10, 5)                                                           
                   )                                                                                                       
           )
(1 row)

drop table supplier_hybrid_part;
-- MPP-3544
-- Domain
create domain domainvarchar varchar(5);
create domain domainnumeric numeric(8,2);
create domain domainint4 int4;
create domain domaintext text;
-- Test tables using domains
-- list
create table basictest1
           ( testint4 domainint4
           , testtext domaintext
           , testvarchar domainvarchar
           , testnumeric domainnumeric
           )
partition by LIST(testvarchar)
(
partition aa values ('aaaaa'),
partition bb values ('bbbbb'),
partition cc values ('ccccc')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'testint4' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_aa" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_bb" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_cc" for table "basictest1"
alter table basictest1 add partition dd values('ddddd');
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_dd" for table "basictest1"
insert into basictest1 values(1, 1, 'ddddd', 1);
insert into basictest1 values(1, 1, 'ccccc', 1);
insert into basictest1 values(1, 1, 'bbbbb', 1);
insert into basictest1 values(1, 1, 'aaaaa', 1);
drop table basictest1;
--range
create table basictest1 (testnumeric domainint4)
partition by range(testnumeric)
 (start(1) end(10) every(5));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'testnumeric' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_1" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_2" for table "basictest1"
insert into basictest1 values(1);
insert into basictest1 values(2);
alter table basictest1 add partition ff start(10) end(20);
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_ff" for table "basictest1"
insert into basictest1 values(10);
drop table basictest1;
drop domain domainvarchar, domainnumeric, domainint4, domaintext;
-- Test index inheritance with partitions
create table ti (i int not null, j int)
distributed by (i)
partition by range (j) 
(start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "ti_1_prt_1" for table "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_2" for table "ti"
create unique index ti_pkey on ti(i);
NOTICE:  building index for child partition "ti_1_prt_1"
NOTICE:  building index for child partition "ti_1_prt_2"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname | tablename  |    indexname    | tablespace |                             indexdef                              
------------+------------+-----------------+------------+-------------------------------------------------------------------
 public     | ti         | ti_pkey         |            | CREATE UNIQUE INDEX ti_pkey ON ti USING btree (i)
 public     | ti_1_prt_1 | ti_pkey_1_prt_1 |            | CREATE UNIQUE INDEX ti_pkey_1_prt_1 ON ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2 | ti_pkey_1_prt_2 |            | CREATE UNIQUE INDEX ti_pkey_1_prt_2 ON ti_1_prt_2 USING btree (i)
(3 rows)

create index ti_j_idx on ti using bitmap(j);
NOTICE:  building index for child partition "ti_1_prt_1"
NOTICE:  building index for child partition "ti_1_prt_2"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname | tablename  |    indexname     | tablespace |                             indexdef                              
------------+------------+------------------+------------+-------------------------------------------------------------------
 public     | ti         | ti_pkey          |            | CREATE UNIQUE INDEX ti_pkey ON ti USING btree (i)
 public     | ti_1_prt_1 | ti_pkey_1_prt_1  |            | CREATE UNIQUE INDEX ti_pkey_1_prt_1 ON ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2 | ti_pkey_1_prt_2  |            | CREATE UNIQUE INDEX ti_pkey_1_prt_2 ON ti_1_prt_2 USING btree (i)
 public     | ti         | ti_j_idx         |            | CREATE INDEX ti_j_idx ON ti USING bitmap (j)
 public     | ti_1_prt_1 | ti_j_idx_1_prt_1 |            | CREATE INDEX ti_j_idx_1_prt_1 ON ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2 | ti_j_idx_1_prt_2 |            | CREATE INDEX ti_j_idx_1_prt_2 ON ti_1_prt_2 USING bitmap (j)
(6 rows)

alter table ti add partition p3 start(3) end(10);
NOTICE:  CREATE TABLE will create partition "ti_1_prt_p3" for table "ti"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname |  tablename  |     indexname     | tablespace |                               indexdef                               
------------+-------------+-------------------+------------+----------------------------------------------------------------------
 public     | ti          | ti_pkey           |            | CREATE UNIQUE INDEX ti_pkey ON ti USING btree (i)
 public     | ti_1_prt_1  | ti_pkey_1_prt_1   |            | CREATE UNIQUE INDEX ti_pkey_1_prt_1 ON ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2  | ti_pkey_1_prt_2   |            | CREATE UNIQUE INDEX ti_pkey_1_prt_2 ON ti_1_prt_2 USING btree (i)
 public     | ti          | ti_j_idx          |            | CREATE INDEX ti_j_idx ON ti USING bitmap (j)
 public     | ti_1_prt_1  | ti_j_idx_1_prt_1  |            | CREATE INDEX ti_j_idx_1_prt_1 ON ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2  | ti_j_idx_1_prt_2  |            | CREATE INDEX ti_j_idx_1_prt_2 ON ti_1_prt_2 USING bitmap (j)
 public     | ti_1_prt_p3 | ti_1_prt_p3_i_key |            | CREATE UNIQUE INDEX ti_1_prt_p3_i_key ON ti_1_prt_p3 USING btree (i)
 public     | ti_1_prt_p3 | ti_1_prt_p3_j_key |            | CREATE INDEX ti_1_prt_p3_j_key ON ti_1_prt_p3 USING bitmap (j)
(8 rows)

alter table ti split partition p3 at (7) into (partition pnew1, partition pnew2);
NOTICE:  exchanged partition "p3" of relation "ti" with relation "pg_temp_6092845"
NOTICE:  dropped partition "p3" for relation "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_pnew1" for table "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_pnew2" for table "ti"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname |   tablename    |      indexname       | tablespace |                                  indexdef                                  
------------+----------------+----------------------+------------+----------------------------------------------------------------------------
 public     | ti             | ti_pkey              |            | CREATE UNIQUE INDEX ti_pkey ON ti USING btree (i)
 public     | ti_1_prt_1     | ti_pkey_1_prt_1      |            | CREATE UNIQUE INDEX ti_pkey_1_prt_1 ON ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2     | ti_pkey_1_prt_2      |            | CREATE UNIQUE INDEX ti_pkey_1_prt_2 ON ti_1_prt_2 USING btree (i)
 public     | ti             | ti_j_idx             |            | CREATE INDEX ti_j_idx ON ti USING bitmap (j)
 public     | ti_1_prt_1     | ti_j_idx_1_prt_1     |            | CREATE INDEX ti_j_idx_1_prt_1 ON ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2     | ti_j_idx_1_prt_2     |            | CREATE INDEX ti_j_idx_1_prt_2 ON ti_1_prt_2 USING bitmap (j)
 public     | ti_1_prt_pnew1 | ti_1_prt_pnew1_i_key |            | CREATE UNIQUE INDEX ti_1_prt_pnew1_i_key ON ti_1_prt_pnew1 USING btree (i)
 public     | ti_1_prt_pnew1 | ti_1_prt_pnew1_j_key |            | CREATE INDEX ti_1_prt_pnew1_j_key ON ti_1_prt_pnew1 USING bitmap (j)
 public     | ti_1_prt_pnew2 | ti_1_prt_pnew2_i_key |            | CREATE UNIQUE INDEX ti_1_prt_pnew2_i_key ON ti_1_prt_pnew2 USING btree (i)
 public     | ti_1_prt_pnew2 | ti_1_prt_pnew2_j_key |            | CREATE INDEX ti_1_prt_pnew2_j_key ON ti_1_prt_pnew2 USING bitmap (j)
(10 rows)

drop table ti;
-- MPP-6611, make sure rename works with default partitions
create table it (i int, j int) partition by range(i) 
subpartition by range(j) subpartition template(start(1) end(10) every(5))
(start(1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_1_2_prt_1" for table "it_1_prt_1"
NOTICE:  CREATE TABLE will create partition "it_1_prt_1_2_prt_2" for table "it_1_prt_1"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2_2_prt_1" for table "it_1_prt_2"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2_2_prt_2" for table "it_1_prt_2"
alter table it rename to newit;
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like 'newit%';
 schemaname |       tablename       
------------+-----------------------
 public     | newit
 public     | newit_1_prt_1
 public     | newit_1_prt_1_2_prt_1
 public     | newit_1_prt_1_2_prt_2
 public     | newit_1_prt_2
 public     | newit_1_prt_2_2_prt_1
 public     | newit_1_prt_2_2_prt_2
(7 rows)

alter table newit add default partition def;
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def" for table "newit"
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def_2_prt_1" for table "newit_1_prt_def"
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def_2_prt_2" for table "newit_1_prt_def"
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like 'newit%';
 schemaname |        tablename        
------------+-------------------------
 public     | newit
 public     | newit_1_prt_1
 public     | newit_1_prt_1_2_prt_1
 public     | newit_1_prt_1_2_prt_2
 public     | newit_1_prt_2
 public     | newit_1_prt_2_2_prt_1
 public     | newit_1_prt_2_2_prt_2
 public     | newit_1_prt_def_2_prt_1
 public     | newit_1_prt_def_2_prt_2
 public     | newit_1_prt_def
(10 rows)

alter table newit rename to anotherit;
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like
'anotherit%';
 schemaname |          tablename          
------------+-----------------------------
 public     | anotherit
 public     | anotherit_1_prt_1
 public     | anotherit_1_prt_1_2_prt_1
 public     | anotherit_1_prt_1_2_prt_2
 public     | anotherit_1_prt_2
 public     | anotherit_1_prt_2_2_prt_1
 public     | anotherit_1_prt_2_2_prt_2
 public     | anotherit_1_prt_def
 public     | anotherit_1_prt_def_2_prt_1
 public     | anotherit_1_prt_def_2_prt_2
(10 rows)

drop table anotherit;
-- test table constraint inheritance
create table it (i int) distributed by (i) partition by range(i) (start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename | indexname 
------------+-----------+-----------
(0 rows)

alter table it add primary key(i);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "it_pkey" for table "it"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "it_1_prt_1_pkey" for table "it_1_prt_1"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "it_1_prt_2_pkey" for table "it_1_prt_2"
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename  |    indexname    
------------+------------+-----------------
 public     | it         | it_pkey
 public     | it_1_prt_1 | it_1_prt_1_pkey
 public     | it_1_prt_2 | it_1_prt_2_pkey
(3 rows)

drop table it;
-- MPP-6297: test special WITH(tablename=...) syntax for dump/restore
-- original table was:
-- PARTITION BY RANGE(l_commitdate) 
-- (
--     PARTITION p1 
--       START ('1992-01-31'::date) END ('1995-04-30'::date) 
--       EVERY ('1 year 1 mon'::interval)
-- )
-- dump used to give a definition like this:
-- without the WITH(tablename=...), the vagaries of EVERY arithmetic
-- create >3 partitions
CREATE TABLE mpp6297 ( l_orderkey bigint,
l_commitdate date
)
distributed BY (l_orderkey) PARTITION BY RANGE(l_commitdate)
(
PARTITION p1_1 START ('1992-01-31'::date) END ('1993-02-28'::date)
EVERY ('1 year 1 mon'::interval)
,
PARTITION p1_2 START ('1993-02-28'::date) END ('1994-03-31'::date)
EVERY ('1 year 1 mon'::interval)
,
PARTITION p1_3 START ('1994-03-31'::date) END ('1995-04-30'::date)
EVERY ('1 year 1 mon'::interval)
);
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_3" for table "mpp6297"
-- should be a single partition def for p1 from 1/31 to 4/30, but
-- shows 4 partitions instead
select partitiontablename, partitionname, 
partitionrangestart, partitionrangeend, partitioneveryclause
from pg_partitions
where tablename like 'mpp6297%' order by partitionrank;
  partitiontablename  | partitionname | partitionrangestart | partitionrangeend  |    partitioneveryclause    
----------------------+---------------+---------------------+--------------------+----------------------------
 mpp6297_1_prt_p1_1   | p1_1          | '01-31-1992'::date  | '02-28-1993'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_2_1 | p1_2_1        | '02-28-1993'::date  | '03-28-1994'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_2_2 | p1_2_2        | '03-28-1994'::date  | '03-31-1994'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_3   | p1_3          | '03-31-1994'::date  | '04-30-1995'::date | '@ 1 year 1 mon'::interval
(4 rows)

select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                                               pg_get_partition_def                                                
-------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(l_commitdate)                                                                                  
           (                                                                                                       
           PARTITION p1 START ('01-31-1992'::date) END ('02-28-1993'::date) EVERY ('@ 1 year 1 mon'::interval),    
           PARTITION p1_2 START ('02-28-1993'::date) END ('03-31-1994'::date) EVERY ('@ 1 year 1 mon'::interval),  
           PARTITION p1_3 START ('03-31-1994'::date) END ('04-30-1995'::date) EVERY ('@ 1 year 1 mon'::interval)   
           )
(1 row)

drop table mpp6297;
-- when WITH(tablename=...) is specified, the EVERY is stored as an
-- attribute, but not expanded into additional partitions
CREATE TABLE mpp6297 ( l_orderkey bigint,
l_commitdate date
)
distributed BY (l_orderkey) PARTITION BY RANGE(l_commitdate)
(
PARTITION p1_1 START ('1992-01-31'::date) END ('1993-02-28'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_1'),
PARTITION p1_2 START ('1993-02-28'::date) END ('1994-03-31'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_2'),
PARTITION p1_3 START ('1994-03-31'::date) END ('1995-04-30'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_3')
);
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_3" for table "mpp6297"
-- should be a single partition def for p1 from 1/31 to 4/30, as intended
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                                             pg_get_partition_def                                              
---------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(l_commitdate)                                                                              
           (                                                                                                   
           PARTITION p1 START ('01-31-1992'::date) END ('04-30-1995'::date) EVERY ('@ 1 year 1 mon'::interval) 
           )
(1 row)

drop table mpp6297;
-- more with basic cases
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (10) every (1),
end (11)		
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_10" for table "mpp6297"
-- note that the partition from 10 to 11 is *not* part of every
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                    
           (                              
           START (1) END (10) EVERY (1),  
           START (10) END (11)            
           )
(1 row)

alter table mpp6297 drop partition for (rank(3));
-- note that the every clause splits into two parts: 1-3 and 4-10
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                    
           (                              
           START (1) END (3) EVERY (1),   
           START (4) END (10) EVERY (1),  
           START (10) END (11)            
           )
(1 row)

-- this isn't legal (but it would be nice)
alter table mpp6297 add partition start (3) end (4) every (1);
ERROR:  cannot specify EVERY when adding RANGE partition to relation "mpp6297"
-- this is legal but it doesn't fix the EVERY clause
alter table mpp6297 add partition start (3) end (4) ;
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_r1125348561" for table "mpp6297"
-- note that the every clause is still splits into two parts: 1-3 and
-- 4-10, because the new partition from 3 to 4 doesn't have an EVERY
-- attribute
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                    
           (                              
           START (1) END (3) EVERY (1),   
           START (3) END (4),             
           START (4) END (10) EVERY (1),  
           START (10) END (11)            
           )
(1 row)

drop table mpp6297;
-- similarly, we can merge adjacent EVERY clauses if they match
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) every (1),
start (5) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that there is only a single every from 1-10
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
          pg_get_partition_def          
----------------------------------------
 PARTITION BY RANGE(b)                  
           (                            
           START (1) END (10) EVERY (1) 
           )
(1 row)

drop table mpp6297;
-- we cannot merge adjacent EVERY clauses if inclusivity/exclusivity is wrong
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) every (1),
start (5) exclusive end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- two every clauses for this case
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def               
--------------------------------------------------
 PARTITION BY RANGE(b)                            
           (                                      
           START (1) END (5) EVERY (1),           
           START (5) EXCLUSIVE END (10) EVERY (1) 
           )
(1 row)

drop table mpp6297;
-- more fun with inclusivity/exclusivity (normal case)
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) inclusive end (10) exclusive every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that inclusive and exclusive attributes aren't listed here (because
-- default behavior)
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
          pg_get_partition_def          
----------------------------------------
 PARTITION BY RANGE(b)                  
           (                            
           START (1) END (10) EVERY (1) 
           )
(1 row)

drop table mpp6297;
-- more fun with inclusivity/exclusivity (abnormal case)
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) exclusive end (10) inclusive every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that inclusive and exclusive attributes are listed here 
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                    pg_get_partition_def                    
------------------------------------------------------------
 PARTITION BY RANGE(b)                                      
           (                                                
           START (1) EXCLUSIVE END (10) INCLUSIVE EVERY (1) 
           )
(1 row)

alter table mpp6297 drop partition for (rank(3));
-- note that the every clause splits into two parts: 1-3 and 4-10 (and
-- inclusive/exclusive is listed correctly)
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def                
---------------------------------------------------
 PARTITION BY RANGE(b)                             
           (                                       
           START (1) EXCLUSIVE END (3) EVERY (1),  
           START (4) END (10) INCLUSIVE EVERY (1)  
           )
(1 row)

drop table mpp6297;
-- we cannot merge adjacent EVERY clauses, even though the
-- inclusivity/exclusivity matches, because it is different from the
-- normal start inclusive/end exclusive
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) inclusive every (1),
start (5) exclusive end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- two every clauses for this case
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def                
---------------------------------------------------
 PARTITION BY RANGE(b)                             
           (                                       
           START (1) END (5) INCLUSIVE EVERY (1),  
           START (5) EXCLUSIVE END (10) EVERY (1)  
           )
(1 row)

drop table mpp6297;
-- MPP-6589: SPLITting an "open" ended partition (ie, no start or end)
CREATE TABLE mpp6589a
(
  id bigint,
  day_dt date
)
DISTRIBUTED BY (id)
PARTITION BY RANGE(day_dt)
          (
          PARTITION p20090312  END ('2009-03-12'::date)
          );
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090312" for table "mpp6589a"
select pg_get_partition_def('mpp6589a'::regclass,true);
                  pg_get_partition_def                   
---------------------------------------------------------
 PARTITION BY RANGE(day_dt)                              
           (                                             
           PARTITION p20090312  END ('03-12-2009'::date) 
           )
(1 row)

-- should work
ALTER TABLE mpp6589a 
SPLIT PARTITION p20090312 AT( '20090310' ) 
INTO( PARTITION p20090309, PARTITION p20090312_tmp);
NOTICE:  exchanged partition "p20090312" of relation "mpp6589a" with relation "pg_temp_6096471"
NOTICE:  dropped partition "p20090312" for relation "mpp6589a"
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090309" for table "mpp6589a"
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090312_tmp" for table "mpp6589a"
select pg_get_partition_def('mpp6589a'::regclass,true);
                                 pg_get_partition_def                                  
---------------------------------------------------------------------------------------
 PARTITION BY RANGE(day_dt)                                                            
           (                                                                           
           PARTITION p20090309  END ('03-10-2009'::date),                              
           PARTITION p20090312_tmp START ('03-10-2009'::date) END ('03-12-2009'::date) 
           )
(1 row)

drop table mpp6589a;
CREATE TABLE mpp6589i(a int, b int) 
partition by range (b) (start (1) end (3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6589i_1_prt_1" for table "mpp6589i"
select pg_get_partition_def('mpp6589i'::regclass,true);
    pg_get_partition_def     
-----------------------------
 PARTITION BY RANGE(b)       
           (                 
           START (1) END (3) 
           )
(1 row)

-- should fail (overlap)
ALTER TABLE mpp6589i ADD PARTITION start (2);
ERROR:  new partition overlaps existing partition
-- should fail (overlap) (not a real overlap, but a "point" hole)
ALTER TABLE mpp6589i ADD PARTITION start (3) exclusive;
ERROR:  new partition overlaps existing partition
-- should work - make sure can add an open-ended final partition
ALTER TABLE mpp6589i ADD PARTITION start (3);
NOTICE:  CREATE TABLE will create partition "mpp6589i_1_prt_r409226384" for table "mpp6589i"
select pg_get_partition_def('mpp6589i'::regclass,true);
     pg_get_partition_def      
-------------------------------
 PARTITION BY RANGE(b)         
           (                   
           START (1) END (3),  
           START (3)           
           )
(1 row)

DROP TABLE mpp6589i;
-- test open-ended SPLIT
CREATE TABLE mpp6589b
(
  id bigint,
  day_dt date
)
DISTRIBUTED BY (id)
PARTITION BY RANGE(day_dt)
          (
          PARTITION p20090312  START ('2008-03-12'::date)
          );
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090312" for table "mpp6589b"
select pg_get_partition_def('mpp6589b'::regclass,true);
                   pg_get_partition_def                   
----------------------------------------------------------
 PARTITION BY RANGE(day_dt)                               
           (                                              
           PARTITION p20090312 START ('03-12-2008'::date) 
           )
(1 row)

-- should work
ALTER TABLE mpp6589b 
SPLIT PARTITION p20090312 AT( '20090310' ) 
INTO( PARTITION p20090309, PARTITION p20090312_tmp);
NOTICE:  exchanged partition "p20090312" of relation "mpp6589b" with relation "pg_temp_6096811"
NOTICE:  dropped partition "p20090312" for relation "mpp6589b"
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090309" for table "mpp6589b"
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090312_tmp" for table "mpp6589b"
select pg_get_partition_def('mpp6589b'::regclass,true);
                                pg_get_partition_def                                 
-------------------------------------------------------------------------------------
 PARTITION BY RANGE(day_dt)                                                          
           (                                                                         
           PARTITION p20090309 START ('03-12-2008'::date) END ('03-10-2009'::date),  
           PARTITION p20090312_tmp START ('03-10-2009'::date)                        
           )
(1 row)

drop table mpp6589b;
-- MPP-7191, MPP-7193: partitioned tables - fully-qualify storage type
-- if not specified (and not a template)
CREATE TABLE mpp5992 (a int, b date, c char,
                     d char(4), e varchar(20), f timestamp)
WITH (orientation=column,appendonly=true)
partition by range (b)
subpartition by list (a)
subpartition template (
subpartition l1 values (1,2,3,4,5),
subpartition l2 values (6,7,8,9,10) ),
subpartition by list (e)
subpartition template (
subpartition ll1 values ('Engineering'),
subpartition ll2 values ('QA') ),
subpartition by list (c)
subpartition template (
subpartition lll1 values ('M'),
subpartition lll2 values ('F') )
(
  start (date '2007-01-01')
  end (date '2010-01-01') every (interval '1 year')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1" for table "mpp5992_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2" for table "mpp5992_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1" for table "mpp5992_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2" for table "mpp5992_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1" for table "mpp5992_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2" for table "mpp5992_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2"
-- Delete subpartition template
alter table mpp5992 alter partition for ('2008-01-01')
set subpartition template ();
NOTICE:  dropped level 2 subpartition template specification for relation "mpp5992"
alter table mpp5992 alter partition for ('2008-01-01')
alter partition for (1)
set subpartition template ();
NOTICE:  dropped level 3 subpartition template specification for relation "mpp5992"
alter table mpp5992 set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp5992"
-- Add subpartition template
alter table mpp5992 alter partition for ('2008-01-01')
alter partition for (1)
set subpartition template ( subpartition lll1 values ('M'),
subpartition lll2 values ('F'));
NOTICE:  adding level 3 subpartition template specification for relation "mpp5992"
alter table mpp5992 alter partition for ('2008-01-01')
set subpartition template (
subpartition ll1 values ('Engineering'),
subpartition ll2 values ('QA')
);
NOTICE:  adding level 2 subpartition template specification for relation "mpp5992"
alter table mpp5992 
set subpartition template (subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5992"
alter table mpp5992 
set subpartition template (subpartition l1 values (1,2,3), 
subpartition l2 values (4,5,6), subpartition l3 values (7,8,9,10));
NOTICE:  replacing level 1 subpartition template specification for relation "mpp5992"
select * from pg_partition_templates where tablename='mpp5992';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition |       partitionlistvalues        | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |           partitionboundary            
------------+-----------+---------------+---------------+----------------+---------------+-------------------+----------------------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------------
 public     | mpp5992   | lll1          | list          |              3 |               |                 1 | 'M'::bpchar                      |                     |                         |                   |                       |                      | f                  | SUBPARTITION lll1 VALUES('M')
 public     | mpp5992   | lll2          | list          |              3 |               |                 2 | 'F'::bpchar                      |                     |                         |                   |                       |                      | f                  | SUBPARTITION lll2 VALUES('F')
 public     | mpp5992   | ll1           | list          |              2 |               |                 1 | 'Engineering'::character varying |                     |                         |                   |                       |                      | f                  | SUBPARTITION ll1 VALUES('Engineering')
 public     | mpp5992   | ll2           | list          |              2 |               |                 2 | 'QA'::character varying          |                     |                         |                   |                       |                      | f                  | SUBPARTITION ll2 VALUES('QA')
 public     | mpp5992   | l1            | list          |              1 |               |                 1 | 1, 2, 3                          |                     |                         |                   |                       |                      | f                  | SUBPARTITION l1 VALUES(1, 2, 3)
 public     | mpp5992   | l2            | list          |              1 |               |                 2 | 4, 5, 6                          |                     |                         |                   |                       |                      | f                  | SUBPARTITION l2 VALUES(4, 5, 6)
 public     | mpp5992   | l3            | list          |              1 |               |                 3 | 7, 8, 9, 10                      |                     |                         |                   |                       |                      | f                  | SUBPARTITION l3 VALUES(7, 8, 9, 10)
(7 rows)

-- Now we can add a new partition
alter table mpp5992 
add partition foo1 
start (date '2011-01-01') 
end (date '2012-01-01'); -- should inherit from parent storage option
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2"
alter table mpp5992 
add partition foo2 
start (date '2012-01-01') 
end (date '2013-01-01') WITH (orientation=column,appendonly=true);
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2"
alter table mpp5992 
add partition foo3 
start (date '2013-01-01') end (date '2014-01-01') WITH (appendonly=true);
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2"
select pg_get_partition_def('mpp5992'::regclass,true, true);
                                                                            pg_get_partition_def                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(b)                                                                                                                                                      
           SUBPARTITION BY LIST(a)                                                                                                                                          
                   SUBPARTITION BY LIST(e)                                                                                                                                  
                           SUBPARTITION BY LIST(c)                                                                                                                          
           (                                                                                                                                                                
           START ('01-01-2007'::date) END ('01-01-2008'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_1', orientation=column, appendonly=true )        
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_1_2_prt_l1', orientation=column, appendonly=true )                                  
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_1_2_prt_l2', orientation=column, appendonly=true )                                 
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   ),                                                                                                                                                       
           START ('01-01-2008'::date) END ('01-01-2009'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_2', orientation=column, appendonly=true )        
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_2_2_prt_l1', orientation=column, appendonly=true )                                  
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_2_2_prt_l2', orientation=column, appendonly=true )                                 
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   ),                                                                                                                                                       
           START ('01-01-2009'::date) END ('01-01-2010'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_3', orientation=column, appendonly=true )        
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_3_2_prt_l1', orientation=column, appendonly=true )                                  
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_3_2_prt_l2', orientation=column, appendonly=true )                                 
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1', orientation=column, appendonly=true )               
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2', orientation=column, appendonly=true )                        
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )     
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   ),                                                                                                                                                       
           PARTITION foo1 START ('01-01-2011'::date) END ('01-01-2012'::date) WITH (tablename='mpp5992_1_prt_foo1', appendonly=false )                                      
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1', appendonly=false )                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1', appendonly=false )                               
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll2', appendonly=false )                     
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2', appendonly=false )                                        
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll2', appendonly=false )                     
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2', appendonly=false )                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1', appendonly=false )                               
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll2', appendonly=false )                     
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2', appendonly=false )                                        
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll2', appendonly=false )                     
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3', appendonly=false )                                                    
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1', appendonly=false )                               
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll2', appendonly=false )                     
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2', appendonly=false )                                        
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll1', appendonly=false ),                    
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll2', appendonly=false )                     
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   ),                                                                                                                                                       
           PARTITION foo2 START ('01-01-2012'::date) END ('01-01-2013'::date) WITH (tablename='mpp5992_1_prt_foo2', orientation=column, appendonly=true )                   
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1', orientation=column, appendonly=true )                                     
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1', orientation=column, appendonly=true )            
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2', orientation=column, appendonly=true )                     
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2', orientation=column, appendonly=true )                                     
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1', orientation=column, appendonly=true )            
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2', orientation=column, appendonly=true )                     
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3', orientation=column, appendonly=true )                                 
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                        
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1', orientation=column, appendonly=true )            
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2', orientation=column, appendonly=true )                     
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll1', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                       
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll2', orientation=column, appendonly=true )  
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                        
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   ),                                                                                                                                                       
           PARTITION foo3 START ('01-01-2013'::date) END ('01-01-2014'::date) WITH (tablename='mpp5992_1_prt_foo3', orientation=row , appendonly=true )                     
                   (                                                                                                                                                        
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1', orientation=row , appendonly=true )                                       
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1', orientation=row , appendonly=true )              
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation=row , appendonly=true )    
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2', orientation=row , appendonly=true )                       
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation=row , appendonly=true )    
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2', orientation=row , appendonly=true )                                       
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1', orientation=row , appendonly=true )              
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation=row , appendonly=true )    
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2', orientation=row , appendonly=true )                       
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation=row , appendonly=true )    
                                   )                                                                                                                                        
                           ),                                                                                                                                               
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3', orientation=row , appendonly=true )                                   
                           (                                                                                                                                                
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1', orientation=row , appendonly=true )              
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll2', orientation=row , appendonly=true )    
                                   ),                                                                                                                                       
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2', orientation=row , appendonly=true )                       
                                   (                                                                                                                                        
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll1', orientation=row , appendonly=true ),   
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll2', orientation=row , appendonly=true )    
                                   )                                                                                                                                        
                           )                                                                                                                                                
                   )                                                                                                                                                        
           )
(1 row)

drop table mpp5992;
-- MPP-10223: split subpartitions
CREATE TABLE MPP10223pk
(
rnc VARCHAR(100),
wbts VARCHAR(100),
axc VARCHAR(100),
vptt VARCHAR(100),
vcct VARCHAR(100),
agg_level CHAR(5),
period_start_time TIMESTAMP WITH TIME ZONE,
load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
interval INTEGER,
totcellsegress double precision,
totcellsingress double precision,
 
  CONSTRAINT "axc_vcct1_atmvcct_pk_test2" 
PRIMARY KEY (rnc,wbts,axc,vptt,vcct,agg_level,period_start_time)
)
 
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
 
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
       SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
       SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                              END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION daypart    VALUES ('day')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_future" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_endpart" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p_future" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100622" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100623" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100624" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100625" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100626" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p_endpart" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p_future" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100622" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100623" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100624" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100625" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100626" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p_endpart" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_pkey" for table "mpp10223pk"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_min15part_pkey" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_min15part_2_prt_p_future_pkey" for table "mpp10223pk_1_prt_min15part_2_prt_p_future"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_min15part_2_prt_p_endpart_pkey" for table "mpp10223pk_1_prt_min15part_2_prt_p_endpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_pkey" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p_future_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p_future"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p20100622_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p20100622"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p20100623_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p20100623"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p20100624_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p20100624"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p20100625_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p20100625"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p20100626_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p20100626"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_hourpart_2_prt_p_endpart_pkey" for table "mpp10223pk_1_prt_hourpart_2_prt_p_endpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_pkey" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p_future_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p_future"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p20100622_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p20100622"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p20100623_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p20100623"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p20100624_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p20100624"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p20100625_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p20100625"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p20100626_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p20100626"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_daypart_2_prt_p_endpart_pkey" for table "mpp10223pk_1_prt_daypart_2_prt_p_endpart"
-- MPP-10421: works -- can re-use name for non-DEFAULT partitions, and
-- primary key problems fixed
ALTER TABLE MPP10223pk
 ALTER PARTITION min15part 
SPLIT PARTITION  P_FUTURE AT ('2010-06-25') 
INTO (PARTITION P20010101, PARTITION P_FUTURE);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10223pk" with relation "pg_temp_6101612"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p20010101" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_min15part_2_prt_p20010101_pkey" for table "mpp10223pk_1_prt_min15part_2_prt_p20010101"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_future" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10223pk_1_prt_min15part_2_prt_p_future_pkey1" for table "mpp10223pk_1_prt_min15part_2_prt_p_future"
drop table mpp10223pk;
-- rebuild the table without a primary key
CREATE TABLE MPP10223
(
rnc VARCHAR(100),
wbts VARCHAR(100),
axc VARCHAR(100),
vptt VARCHAR(100),
vcct VARCHAR(100),
agg_level CHAR(5),
period_start_time TIMESTAMP WITH TIME ZONE,
load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
interval INTEGER,
totcellsegress double precision,
totcellsingress double precision
)
 
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
 
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
       SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
       SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                              END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION daypart    VALUES ('day')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_future" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_endpart" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p_future" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100622" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100623" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100624" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100625" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100626" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p_endpart" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p_future" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100622" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100623" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100624" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100625" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100626" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p_endpart" for table "mpp10223_1_prt_daypart"
-- this works
ALTER TABLE MPP10223
 ALTER PARTITION min15part 
SPLIT PARTITION  P_FUTURE AT ('2010-06-25') 
INTO (PARTITION P20010101, PARTITION P_FUTURE2);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10223" with relation "pg_temp_6102954"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p20010101" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_future2" for table "mpp10223_1_prt_min15part"
select pg_get_partition_def('mpp10223'::regclass,true);
                                                                            pg_get_partition_def                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY LIST(agg_level)                                                                                                                                               
           SUBPARTITION BY RANGE(period_start_time)                                                                                                                         
           (                                                                                                                                                                
           PARTITION min15part VALUES('15min')                                                                                                                              
                   (                                                                                                                                                        
                   SUBPARTITION p_future2 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone),  
                   SUBPARTITION p20010101 START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)   
                   ),                                                                                                                                                       
           PARTITION hourpart VALUES('hour ')                                                                                                                               
                   (                                                                                                                                                        
                   SUBPARTITION p_future START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone),   
                   SUBPARTITION p20100622 START ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone) END ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100623 START ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone) END ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100624 START ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100625 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100626 START ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone),  
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)   
                   ),                                                                                                                                                       
           PARTITION daypart VALUES('day  ')                                                                                                                                
                   (                                                                                                                                                        
                   SUBPARTITION p_future START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone),   
                   SUBPARTITION p20100622 START ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone) END ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100623 START ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone) END ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100624 START ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100625 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone),  
                   SUBPARTITION p20100626 START ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone),  
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)   
                   )                                                                                                                                                        
           )
(1 row)

drop table mpp10223;
-- simpler version
create table mpp10223b (a int, b int , d int)
partition by range (b)
subpartition by range (d)
(partition p1 start (1) end (10)
(subpartition sp2 start (20) end (30)));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1" for table "mpp10223b"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp2" for table "mpp10223b_1_prt_p1"
-- MPP-10421: allow re-use sp2 for non-DEFAULT partition
alter table mpp10223b alter partition p1 
split partition for (rank(1) ) at (25)
into (partition sp2, partition sp3);
NOTICE:  exchanged partition "sp2" of partition "p1" of relation "mpp10223b" with relation "pg_temp_6103856"
NOTICE:  dropped partition "sp2" for partition "p1" of relation "mpp10223b"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp2" for table "mpp10223b_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp3" for table "mpp10223b_1_prt_p1"
select pg_get_partition_def('mpp10223b'::regclass,true);
                   pg_get_partition_def                   
----------------------------------------------------------
 PARTITION BY RANGE(b)                                    
           SUBPARTITION BY RANGE(d)                       
           (                                              
           PARTITION p1 START (1) END (10)                
                   (                                      
                   SUBPARTITION sp3 START (25) END (30),  
                   SUBPARTITION sp2 START (20) END (25)   
                   )                                      
           )
(1 row)

drop table mpp10223b;
-- MPP-10480: dump templates (but don't use "foo")
create table MPP10480 (a int, b int, d int)
partition by range (b)
subpartition by range(d)
subpartition template (start (1) end (10) every (1))
(start (20) end (30) every (1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_1" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_2" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_3" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_4" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_5" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_6" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_7" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_8" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_9" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_1" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_2" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_3" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_4" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_5" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_6" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_7" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_8" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_9" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_1" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_2" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_3" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_4" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_5" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_6" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_7" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_8" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_9" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_1" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_2" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_3" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_4" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_5" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_6" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_7" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_8" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_9" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_1" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_2" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_3" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_4" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_5" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_6" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_7" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_8" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_9" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_1" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_2" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_3" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_4" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_5" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_6" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_7" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_8" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_9" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_1" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_2" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_3" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_4" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_5" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_6" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_7" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_8" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_9" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_1" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_2" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_3" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_4" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_5" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_6" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_7" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_8" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_9" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_1" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_2" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_3" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_4" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_5" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_6" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_7" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_8" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_9" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_1" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_2" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_3" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_4" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_5" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_6" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_7" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_8" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_9" for table "mpp10480_1_prt_10"
select pg_get_partition_template_def('MPP10480'::regclass, true, true);
                    pg_get_partition_template_def                    
---------------------------------------------------------------------
 ALTER TABLE mpp10480                                                
 SET SUBPARTITION TEMPLATE                                           
           (                                                         
           START (1) END (2) EVERY (1) WITH (tablename='mpp10480'),  
           START (2) END (3) EVERY (1) WITH (tablename='mpp10480'),  
           START (3) END (4) EVERY (1) WITH (tablename='mpp10480'),  
           START (4) END (5) EVERY (1) WITH (tablename='mpp10480'),  
           START (5) END (6) EVERY (1) WITH (tablename='mpp10480'),  
           START (6) END (7) EVERY (1) WITH (tablename='mpp10480'),  
           START (7) END (8) EVERY (1) WITH (tablename='mpp10480'),  
           START (8) END (9) EVERY (1) WITH (tablename='mpp10480'),  
           START (9) END (10) EVERY (1) WITH (tablename='mpp10480')  
           )                                                         
 
(1 row)

drop table MPP10480;
-- MPP-10421: fix SPLIT of partitions with PRIMARY KEY constraint/indexes
CREATE TABLE mpp10321a
(
        rnc VARCHAR(100),
        wbts VARCHAR(100),
        axc VARCHAR(100),
        vptt VARCHAR(100),
        vcct VARCHAR(100),
        agg_level CHAR(5),
        period_start_time TIMESTAMP WITH TIME ZONE,
        load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
        interval INTEGER,
        totcellsegress double precision,
        totcellsingress double precision,
  CONSTRAINT "mpp10321a_pk"
PRIMARY KEY (rnc,wbts,axc,vptt,vcct,agg_level,period_start_time)
)
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
         SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
         SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
          SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
          SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                 END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part" for table "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart" for table "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_future" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_endpart" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart_2_prt_p20100622" for table "mpp10321a_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart_2_prt_p_endpart" for table "mpp10321a_1_prt_hourpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_pkey" for table "mpp10321a"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_min15part_pkey" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_min15part_2_prt_p_future_pkey" for table "mpp10321a_1_prt_min15part_2_prt_p_future"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_min15part_2_prt_p_endpart_pkey" for table "mpp10321a_1_prt_min15part_2_prt_p_endpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_hourpart_pkey" for table "mpp10321a_1_prt_hourpart"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_hourpart_2_prt_p20100622_pkey" for table "mpp10321a_1_prt_hourpart_2_prt_p20100622"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_hourpart_2_prt_p_endpart_pkey" for table "mpp10321a_1_prt_hourpart_2_prt_p_endpart"
ALTER TABLE mpp10321a
ALTER PARTITION min15part
SPLIT PARTITION  P_FUTURE AT ('2010-06-25')
INTO (PARTITION P20010101, PARTITION P_FUTURE);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10321a" with relation "pg_temp_6107833"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p20010101" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_min15part_2_prt_p20010101_pkey" for table "mpp10321a_1_prt_min15part_2_prt_p20010101"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_future" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "mpp10321a_1_prt_min15part_2_prt_p_future_pkey1" for table "mpp10321a_1_prt_min15part_2_prt_p_future"
DROP TABLE mpp10321a;
-- test for default partition with boundary spec
create table bhagp_range (a int, b int) 
distributed by (a) 
partition by range (b) 
( 
  default partition x 
  start (0) inclusive 
  end (2) exclusive 
  every (1) 
);
ERROR:  invalid use of boundary specification for DEFAULT partition "x"
LINE 5:   default partition x 
          ^
create table bhagp_list (a int, b int) 
distributed by (a) 
partition by list (b) 
( 
  default partition x 
  values (1,2)
);
ERROR:  invalid use of boundary specification for DEFAULT partition "x"
LINE 5:   default partition x 
          ^
-- more coverage tests
-- bad partition by type
create table cov1 (a int, b int)
distributed by (a)
partition by (b)
(
start (1) end (10) every (1)
);
ERROR:  PARTITION BY must specify RANGE or LIST
-- bad partition by type
create table cov1 (a int, b int)
distributed by (a)
partition by funky (b)
(
start (1) end (10) every (1)
);
ERROR:  PARTITION BY must specify RANGE or LIST
drop table cov1;
ERROR:  table "cov1" does not exist
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
(
start (1) end (10) every (1)
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_1" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_2" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_3" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_4" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_5" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_6" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_7" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_8" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_9" for table "cov1"
-- syntax error
alter table cov1 drop partition for (funky(1));
ERROR:  syntax error at or near ")"
LINE 1: alter table cov1 drop partition for (funky(1));
                                                     ^
-- no rank for default
alter table cov1 drop default partition for (rank(1));
ERROR:  Cannot specify a name, rank, or value for a DEFAULT partition in this context
-- no default
alter table cov1 drop default partition;
ERROR:  DEFAULT partition of relation "cov1" does not exist
-- cannot add except by name
alter table cov1 add partition for (rank(1));
ERROR:  Can only ADD a partition by name
-- bad template
alter table cov1 set subpartition template (values (1,2) (values (2,3)));
ERROR:  template cannot contain specification for child partition
-- create and drop default partition in one statement!
alter table cov1 add default partition def1, drop default partition;
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_def1" for table "cov1"
NOTICE:  dropped partition "def1" for relation "cov1"
drop table cov1;
set gp_enable_hash_partitioned_tables = true;
-- not hash
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
partitions 3
(
start (1) end (10) every (1)
);
ERROR:  PARTITIONS clause requires a HASH partition
LINE 3: partition by range (b)
                     ^
-- not hash
create table cov1 (a int, b int, d int)
distributed by (a)
partition by range (b)
subpartition by range (d)
subpartitions 3
(
start (1) end (10) every (1)
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_1" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_2" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_3" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_4" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_5" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_6" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_7" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_8" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_9" for table "cov1"
ERROR:  SUBPARTITIONS clause requires a HASH partition (at depth 2)
LINE 4: subpartition by range (d)
                        ^
set gp_enable_hash_partitioned_tables = false;
-- not hash
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
partitions 3
(
start (1) end (10) every (1)
);
ERROR:  syntax error at or near "3"
LINE 4: partitions 3
                   ^
-- not hash
create table cov1 (a int, b int, d int)
distributed by (a)
partition by range (b)
subpartition by range (d)
subpartitions 3
(
start (1) end (10) every (1)
);
ERROR:  syntax error at or near "3"
LINE 5: subpartitions 3
                      ^
-- legal?!?! 
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
(
start () end(2)  
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_1" for table "cov1"
-- no start, just end!
select * from pg_partitions where tablename = 'cov1';
 schemaname | tablename | partitionschemaname | partitiontablename | partitionname | parentpartitiontablename | parentpartitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary | parenttablespace | partitiontablespace 
------------+-----------+---------------------+--------------------+---------------+--------------------------+---------------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------+------------------+---------------------
 public     | cov1      | public              | cov1_1_prt_1       |               |                          |                     | range         |              0 |             1 |                 1 |                     |                     | t                       | 2                 | f                     |                      | f                  |  END (2)          | pg_default       | pg_default
(1 row)

drop table cov1;
-- every 5 (1) now disallowed...
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
(
start (1) end(20) every 5 (1)
);
ERROR:  syntax error at or near "5"
LINE 5: start (1) end(20) every 5 (1)
                                ^
drop table if exists cov1;
NOTICE:  table "cov1" does not exist, skipping
create table cov1 (a int, b int)
distributed by (a)
partition by list (b)
(
partition p1 values (1,2,3,4,5,6,7,8)
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p1" for table "cov1"
-- bad split
alter table cov1 split partition p1 at (5,50);
ERROR:  AT clause parameter is not a member of the target partition specification
-- good split
alter table cov1 split partition p1 at (5,6,7) 
into (partition p1, partition p2);
NOTICE:  exchanged partition "p1" of relation "cov1" with relation "pg_temp_6108887"
NOTICE:  dropped partition "p1" for relation "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p1" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p2" for table "cov1"
select partitionboundary from pg_partitions where tablename = 'cov1';
         partitionboundary          
------------------------------------
 PARTITION p1 VALUES(1, 2, 3, 4, 8)
 PARTITION p2 VALUES(5, 6, 7)
(2 rows)

drop table cov1;
-- MPP-11120
--  ADD PARTITION didn't explicitly specify the distribution policy in the
-- CreateStmt distributedBy field and as such we followed the behaviour encoded
-- in transformDistributedBy(). Unfortunately, it chooses to set the
-- distribution policy to that of the primary key if the distribution policy
-- is not explicitly set.
create table test_table (
	a	int,
	b	int,
	c	int,
	primary key (a,b,c)
)
distributed by (a)
partition by range (b)
(
	default partition default_partition,
	partition p1 start (1) end (2)
);
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_default_partition" for table "test_table"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_p1" for table "test_table"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_pkey" for table "test_table"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_prt_default_partition_pkey" for table "test_table_1_prt_default_partition"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_prt_p1_pkey" for table "test_table_1_prt_p1"
insert into test_table values(1,2,3);
select * from test_table; -- expected: (1,2,3)
 a | b | c 
---+---+---
 1 | 2 | 3
(1 row)

delete from test_table where a=1 and b=2 and c=3; -- this should delete the row in test_table
select * from test_table; -- expected, no rows
 a | b | c 
---+---+---
(0 rows)

insert into test_table values(1,2,3); -- reinsert data
-- all partitions should have same distribution policy
select relname, attrnums as distribution_attributes from
gp_distribution_policy p, pg_class c
where p.localoid = c.oid and relname like 'test_table%' order by p.localoid;
              relname               | distribution_attributes 
------------------------------------+-------------------------
 test_table                         | {1}
 test_table_1_prt_default_partition | {1}
 test_table_1_prt_p1                | {1}
(3 rows)

alter table test_table split default partition
        start (3)
	end (4)
	into (partition p2, partition default_partition);
NOTICE:  exchanged partition "default_partition" of relation "test_table" with relation "pg_temp_6109109"
NOTICE:  dropped partition "default_partition" for relation "test_table"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_p2" for table "test_table"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_prt_p2_pkey" for table "test_table_1_prt_p2"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_default_partition" for table "test_table"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_prt_default_partition_pkey1" for table "test_table_1_prt_default_partition"
select relname, attrnums as distribution_attributes from
gp_distribution_policy p, pg_class c where p.localoid = c.oid and 
relname like 'test_table%' order by p.localoid;
              relname               | distribution_attributes 
------------------------------------+-------------------------
 test_table                         | {1}
 test_table_1_prt_p1                | {1}
 test_table_1_prt_p2                | {1}
 test_table_1_prt_default_partition | {1}
(4 rows)

delete from test_table where a=1 and b=2 and c=3; -- this should delete the row in test_table
select * from test_table; -- expected, no rows! But we see the row. Wrong results!
 a | b | c 
---+---+---
(0 rows)

alter table test_table drop partition default_partition;
alter table test_table add partition foo start(10) end(20);
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_foo" for table "test_table"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_prt_foo_pkey" for table "test_table_1_prt_foo"
select relname, attrnums as distribution_attributes from
gp_distribution_policy p, pg_class c where p.localoid = c.oid and
relname like 'test_table%' order by p.localoid;
       relname        | distribution_attributes 
----------------------+-------------------------
 test_table           | {1}
 test_table_1_prt_p1  | {1}
 test_table_1_prt_p2  | {1}
 test_table_1_prt_foo | {1}
(4 rows)

drop table test_table;
-- MPP-6979: EXCHANGE partitions - fix namespaces if they differ
-- new schema
create schema mpp6979dummy;
create table mpp6979part(a int, b int) 
partition by range(b) 
(
start (1) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_1" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_2" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_3" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_4" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_5" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_6" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_7" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_8" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_9" for table "mpp6979part"
-- append-only table in new schema 
create table mpp6979dummy.mpp6979tab(like mpp6979part) with (appendonly=true);
NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
-- check that table and all parts in public schema
select schemaname, tablename, partitionschemaname, partitiontablename
from pg_partitions 
where tablename like ('mpp6979%');
 schemaname |  tablename  | partitionschemaname | partitiontablename  
------------+-------------+---------------------+---------------------
 public     | mpp6979part | public              | mpp6979part_1_prt_1
 public     | mpp6979part | public              | mpp6979part_1_prt_2
 public     | mpp6979part | public              | mpp6979part_1_prt_3
 public     | mpp6979part | public              | mpp6979part_1_prt_4
 public     | mpp6979part | public              | mpp6979part_1_prt_5
 public     | mpp6979part | public              | mpp6979part_1_prt_6
 public     | mpp6979part | public              | mpp6979part_1_prt_7
 public     | mpp6979part | public              | mpp6979part_1_prt_8
 public     | mpp6979part | public              | mpp6979part_1_prt_9
(9 rows)

-- note that we have heap partitions in public, and ao table in mpp6979dummy
select nspname, relname, relstorage from pg_class pc, pg_namespace ns 
where
pc.relnamespace=ns.oid and relname like ('mpp6979%');
   nspname    |       relname       | relstorage 
--------------+---------------------+------------
 public       | mpp6979part_1_prt_1 | h
 public       | mpp6979part_1_prt_2 | h
 public       | mpp6979part_1_prt_3 | h
 public       | mpp6979part_1_prt_4 | h
 public       | mpp6979part_1_prt_5 | h
 public       | mpp6979part_1_prt_6 | h
 public       | mpp6979part_1_prt_7 | h
 public       | mpp6979part_1_prt_8 | h
 public       | mpp6979part_1_prt_9 | h
 public       | mpp6979part         | h
 mpp6979dummy | mpp6979tab          | a
(11 rows)

-- exchange the partition with the ao table.  
-- Now we have an ao partition and mpp6979tab is heap!
alter table mpp6979part exchange partition for (rank(1)) 
with table mpp6979dummy.mpp6979tab;
-- after the exchange, all partitions are still in public
select schemaname, tablename, partitionschemaname, partitiontablename
from pg_partitions 
where tablename like ('mpp6979%');
 schemaname |  tablename  | partitionschemaname | partitiontablename  
------------+-------------+---------------------+---------------------
 public     | mpp6979part | public              | mpp6979part_1_prt_1
 public     | mpp6979part | public              | mpp6979part_1_prt_2
 public     | mpp6979part | public              | mpp6979part_1_prt_3
 public     | mpp6979part | public              | mpp6979part_1_prt_4
 public     | mpp6979part | public              | mpp6979part_1_prt_5
 public     | mpp6979part | public              | mpp6979part_1_prt_6
 public     | mpp6979part | public              | mpp6979part_1_prt_7
 public     | mpp6979part | public              | mpp6979part_1_prt_8
 public     | mpp6979part | public              | mpp6979part_1_prt_9
(9 rows)

-- the rank 1 partition is ao, but still in public, and 
-- table mpp6979tab is now heap, but still in mpp6979dummy
select nspname, relname, relstorage from pg_class pc, pg_namespace ns 
where
pc.relnamespace=ns.oid and relname like ('mpp6979%');
   nspname    |       relname       | relstorage 
--------------+---------------------+------------
 public       | mpp6979part_1_prt_2 | h
 public       | mpp6979part_1_prt_3 | h
 public       | mpp6979part_1_prt_4 | h
 public       | mpp6979part_1_prt_5 | h
 public       | mpp6979part_1_prt_6 | h
 public       | mpp6979part_1_prt_7 | h
 public       | mpp6979part_1_prt_8 | h
 public       | mpp6979part_1_prt_9 | h
 public       | mpp6979part         | h
 public       | mpp6979part_1_prt_1 | a
 mpp6979dummy | mpp6979tab          | h
(11 rows)

drop table mpp6979part;
drop table mpp6979dummy.mpp6979tab;
drop schema mpp6979dummy;
-- MPP-7898:
drop table if exists r cascade; --ignore
NOTICE:  table "r" does not exist, skipping
drop table if exists s cascade; --ignore
NOTICE:  table "s" does not exist, skipping
create table s 
    (a int, b text) 
    distributed by (a);
    
insert into s values 
    (1, 'one');
-- Try to create a table that mixes inheritance and partitioning.
-- Correct behavior: ERROR
create table r 
    ( c int, d int) 
    inherits (s)
    partition by range(d) 
    (
        start (0) 
        end (2) 
        every (1)
    );
ERROR:  cannot mix inheritance with partitioning
 -- If (incorrectly) the previous statement works, the next one is 
 -- likely to fail with in unexpected internal error.  This is residual 
 -- issue MPP-7898.
insert into r values 
    (0, 'from r', 0, 0);
ERROR:  relation "r" does not exist
    
drop table if exists s cascade; --ignore
drop table if exists r cascade; --ignore
NOTICE:  table "r" does not exist, skipping
create table r 
    ( a int, b text, c int, d int ) 
    distributed by (a)
    partition by range(d) 
    (
        start (0) 
        end (2) 
        every (1)
    );
NOTICE:  CREATE TABLE will create partition "r_1_prt_1" for table "r"
NOTICE:  CREATE TABLE will create partition "r_1_prt_2" for table "r"
 
insert into r values 
    (0, 'from r', 0, 0);
create table s 
    ( a int, b text, c int, d int ) 
    distributed by (a);
    
insert into s values 
    (1, 'from s', 555, 555);
create table t
    ( )
    inherits (s)
    distributed by (a);
insert into t values
    (0, 'from t', 666, 666);
-- Try to exchange in the child and parent.  
-- Correct behavior: ERROR in both cases.
alter table r exchange partition for (1) with table t;
ERROR:  cannot exchange table "t" as it inherits other table(s)
alter table r exchange partition for (1) with table s;
ERROR:  cannot EXCHANGE table "s" as it has child table(s)
drop table t cascade; --ignore
drop table s cascade; --ignore
drop table r cascade; --ignore
-- MPP-7898 end.
-- ( MPP-13750 
CREATE TABLE s (id int, date date, amt decimal(10,2), units int) 
DISTRIBUTED BY (id) 
PARTITION BY RANGE (date) 
( START (date '2008-01-01') INCLUSIVE 
   END (date '2008-01-02') EXCLUSIVE 
   EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "s_1_prt_1" for table "s"
create index s_i on s(amt) 
  where (id > 1)
  ;
NOTICE:  building index for child partition "s_1_prt_1"
create index s_j on s(units)
  where (id <= 1)
  ;
NOTICE:  building index for child partition "s_1_prt_1"
create index s_i_expr on s(log(units));
NOTICE:  building index for child partition "s_1_prt_1"
alter table s add partition s_test 
    start(date '2008-01-03') end (date '2008-01-05');
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test" for table "s"
alter table s split partition for (date '2008-01-03') at (date '2008-01-04')
  into (partition s_test, partition s_test2);
NOTICE:  exchanged partition "s_test" of relation "s" with relation "pg_temp_6110116"
NOTICE:  dropped partition "s_test" for relation "s"
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test" for table "s"
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test2" for table "s"
select 
    relname, 
    (select count(distinct content) - 1 
     from gp_segment_configuration) - count(*) as missing, 
    count(distinct relid) oid_count 
from (
    select gp_execution_segment(), oid, relname 
    from gp_dist_random('pg_class') 
    ) seg_class(segid, relid, relname) 
where relname ~ '^s_' 
group by relname; 
          relname          | missing | oid_count 
---------------------------+---------+-----------
 s_1_prt_1                 |       0 |         1
 s_1_prt_s_test2_amt_key   |       0 |         1
 s_1_prt_s_test_key1       |       0 |         1
 s_1_prt_s_test_units_key1 |       0 |         1
 s_i_1_prt_1               |       0 |         1
 s_i_expr_1_prt_1          |       0 |         1
 s_j                       |       0 |         1
 s_1_prt_s_test            |       0 |         1
 s_1_prt_s_test2           |       0 |         1
 s_1_prt_s_test2_key       |       0 |         1
 s_1_prt_s_test2_units_key |       0 |         1
 s_1_prt_s_test_amt_key1   |       0 |         1
 s_i                       |       0 |         1
 s_i_expr                  |       0 |         1
 s_j_1_prt_1               |       0 |         1
(15 rows)

drop table s cascade;
--   MPP-13750 )
-- MPP-13806 start
drop table if exists mpp13806;
NOTICE:  table "mpp13806" does not exist, skipping
 CREATE TABLE mpp13806 (id int, date date, amt decimal(10,2))
 DISTRIBUTED BY (id)
 PARTITION BY RANGE (date)
 ( START (date '2008-01-01') INCLUSIVE
	END (date '2008-01-05') EXCLUSIVE
	EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_1" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_2" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_3" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_4" for table "mpp13806"
 
-- Adding unbound partition right before the start  used to fail
alter table mpp13806 add partition test end (date '2008-01-01') exclusive;
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_test" for table "mpp13806"
 
drop table if exists mpp13806;
 CREATE TABLE mpp13806 (id int, date date, amt decimal(10,2))
 DISTRIBUTED BY (id)
 PARTITION BY RANGE (date)
 ( START (date '2008-01-01') EXCLUSIVE
	END (date '2008-01-05') EXCLUSIVE
	EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_1" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_2" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_3" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_4" for table "mpp13806"
-- For good measure, test the opposite case
alter table mpp13806 add partition test end (date '2008-01-01') inclusive;
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_test" for table "mpp13806"
drop table mpp13806;
-- MPP-13806 end
-- MPP-14471 start
-- No unenforceable PK/UK constraints!  (UNIQUE INDEXes still allowed; tested above)
drop table if exists tc cascade;
NOTICE:  table "tc" does not exist, skipping
drop table if exists cc cascade;
NOTICE:  table "cc" does not exist, skipping
drop table if exists at cascade;
NOTICE:  table "at" does not exist, skipping
create table tc
    (a int, b int, c int, primary key(a) )
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key
HINT:  Include column "b" in the PRIMARY KEY constraint or create a part-wise UNIQUE index after creating the table instead.
create table cc
    (a int primary key, b int, c int)
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key
HINT:  Include column "b" in the PRIMARY KEY constraint or create a part-wise UNIQUE index after creating the table instead.
create table at
    (a int, b int, c int)
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
NOTICE:  CREATE TABLE will create partition "at_1_prt_d" for table "at"
NOTICE:  CREATE TABLE will create partition "at_1_prt_2" for table "at"
NOTICE:  CREATE TABLE will create partition "at_1_prt_3" for table "at"
alter table at
    add primary key (a);
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key of relation "at".
HINT:  Include the partition key or create a part-wise UNIQUE index instead.
-- MPP-14471 end
-- MPP-17606 (using table "at" from above)
alter table at
    alter column b
	type numeric;
ERROR:  cannot alter type of a column used in a partitioning key
	
-- MPP-17606 end
-- MPP-17707 start
create table mpp17707
( d int, p int ,x text)
with (appendonly = true)
distributed by (d)
partition by range (p)
(start (0) end (3) every (2));
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_1" for table "mpp17707"
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_2" for table "mpp17707"
-- Create a expression index on the partitioned table
create index idx_abc on mpp17707(upper(x));
NOTICE:  building index for child partition "mpp17707_1_prt_1"
NOTICE:  building index for child partition "mpp17707_1_prt_2"
-- split partition 1 of table
alter table mpp17707 split partition for (0) at (1)
	into (partition x1, partition x2);
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_x1" for table "mpp17707"
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_x2" for table "mpp17707"
-- MPP-17707 end
-- MPP-17814 start
drop table if exists plst2 cascade;
NOTICE:  table "plst2" does not exist, skipping
-- positive; bug was that it failed whereas it should succeed
create table plst2
    (            
        a integer not null,
        b integer not null,
        c integer
    )                                                                                                                   
    distributed by (b) 
    partition by list (a,c)
    (
        partition p1 values ( (1, 2), (3, 4) ),
        partition p2 values ( (5, 6) ),
        partition p3 values ( (2, 1) )
    );
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p1" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p2" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p3" for table "plst2"
drop table if exists plst2 cascade;
--negative; test legitimate failure
create table plst2
    (            
        a integer not null,
        b integer not null,
        c integer
    )                                                                                                                   
    distributed by (b) 
    partition by list (a,c)
    (
        partition p1 values ( (1, 2), (3, 4) ),
        partition p2 values ( (5, 6) ),
        partition p3 values ( (1, 2) )
    );
ERROR:  duplicate VALUES in partition "p3"
LINE 12:         partition p3 values ( (1, 2) )
                              ^
-- postive; make sure inner part duplicates are accepted and quietly removed.
drop table if exists plst2;
NOTICE:  table "plst2" does not exist, skipping
create table plst2
    ( a int, b int)
    distributed by (a)
    partition by list (a, b) 
        (
            partition p0 values ((1,2), (3,4)),
            partition p1 values ((4,3), (2,1)),
            partition p2 values ((4,4),(5,5),(4,4),(5,5),(4,4),(5,5)),
            partition p3 values ((4,5),(5,6))
        );
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p0" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p1" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p2" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p3" for table "plst2"
-- positive; make sure legitimate alters work.
alter table plst2 add partition p4 values ((5,4),(6,5));
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p4" for table "plst2"
alter table plst2 add partition p5 values ((7,8),(7,8));
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p5" for table "plst2"
select conrelid::regclass, consrc  
from pg_constraint 
where conrelid in (
    select parchildrelid::regclass
    from pg_partition_rule
    where paroid in (
        select oid 
        from pg_partition 
        where parrelid = 'plst2'::regclass
        )
    );
    conrelid    |                      consrc                      
----------------+--------------------------------------------------
 plst2_1_prt_p0 | (((a = 1) AND (b = 2)) OR ((a = 3) AND (b = 4)))
 plst2_1_prt_p1 | (((a = 4) AND (b = 3)) OR ((a = 2) AND (b = 1)))
 plst2_1_prt_p2 | (((a = 4) AND (b = 4)) OR ((a = 5) AND (b = 5)))
 plst2_1_prt_p3 | (((a = 4) AND (b = 5)) OR ((a = 5) AND (b = 6)))
 plst2_1_prt_p4 | (((a = 5) AND (b = 4)) OR ((a = 6) AND (b = 5)))
 plst2_1_prt_p5 | ((a = 7) AND (b = 8))
(6 rows)

-- negative; make sure conflicting alters fail.
alter table plst2 add partition p6 values ((7,8),(2,1));
ERROR:  new partition definition overlaps existing partition "p5" of relation "plst2"
drop table if exists plst2;
-- MPP-17814 end
-- MPP-18441
create table s_heap (i1 int, t1 text, t2 text, i2 int, i3 int, n1 numeric, b1 bool)
partition by list (t1)
     (partition abc values('abc0', 'abc1', 'abc2'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_abc" for table "s_heap"
insert into s_heap (t1, i1, i2, i3, n1, b1) select 'abc0', 1, 1, 1, 2.3, true
    from generate_series(1, 5);
alter table s_heap drop column t2;
alter table s_heap drop column i3;
-- create co table for exchange
create table s_heap_ex_abc (i1 int, t1 text, f1 float, i2 int, n1 numeric, b1 bool)
    WITH (appendonly=true, orientation=column, compresstype=quicklz);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
alter table s_heap_ex_abc drop column f1;
insert into s_heap_ex_abc select 1, 'abc1', 2, 2, true from generate_series(1, 5);
-- exchange partition
alter table s_heap exchange partition abc with table s_heap_ex_abc;
alter table s_heap exchange partition abc with table s_heap_ex_abc;
drop table s_heap, s_heap_ex_abc;
-- MPP-18441 end
-- MPP-18443
create table s_heap (i1 int, t1 text, i2 int , i3 int, n1 numeric,b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def" for table "s_heap"
insert into s_heap(t1, i1, i2, i3, n1, b1)
    select 'def0', 1, 1, 1, 2.3 , true from generate_series(1, 5);
alter table s_heap drop column i3;
create index s_heap_index on s_heap (i2);
NOTICE:  building index for child partition "s_heap_1_prt_def"
alter table s_heap split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap" with relation "pg_temp_1597730"
NOTICE:  dropped partition "def" for relation "s_heap"
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def5" for table "s_heap"
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def0" for table "s_heap"
select * from s_heap_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
(5 rows)

drop table s_heap;
-- MPP-18443 end
-- MPP-18445
NOTICE:  table "s_heap_ao" does not exist, skipping
create table s_heap_ao ( i1 int, t1 text, i2 int , i3 int, n1 numeric,b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9')
        with (appendonly=true, orientation=row));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def" for table "s_heap_ao"
insert into s_heap_ao(t1, i1, i2, i3, n1, b1)
    select 'def4', 1, 1, 1, 2.3, true from generate_series(1, 2);
insert into s_heap_ao(t1, i1, i2, i3, n1, b1)
    select 'def5', 1, 1, 1, 2.3, true from generate_series(1, 2);
alter table s_heap_ao drop column i3;
create index s_heap_ao_index on s_heap_ao (i2);
NOTICE:  building index for child partition "s_heap_ao_1_prt_def"
alter table s_heap_ao split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap_ao" with relation "pg_temp_1598038"
NOTICE:  dropped partition "def" for relation "s_heap_ao"
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def5" for table "s_heap_ao"
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def0" for table "s_heap_ao"
select * from s_heap_ao_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def4 |  1 | 2.3 | t
  1 | def4 |  1 | 2.3 | t
(2 rows)

drop table s_heap_ao;
-- MPP-18445 end
-- MPP-18456
NOTICE:  table "s_heap_co" does not exist, skipping
create table s_heap_co (i1 int, t1 text, i2 int, i3 int, n1 numeric, b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9')
        with (appendonly=true, orientation=column));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def" for table "s_heap_co"
insert into s_heap_co(t1, i1, i2, i3, n1, b1)
    select 'def4', 1,1, 1, 2.3, true from generate_series(1, 2);
insert into s_heap_co(t1, i1, i2, i3, n1, b1)
    select 'def5', 1,1, 1, 2.3, true from generate_series(1, 2);
alter table s_heap_co drop column i3;
create index s_heap_co_index on s_heap_co (i2);
NOTICE:  building index for child partition "s_heap_co_1_prt_def"
alter table s_heap_co split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap_co" with relation "pg_temp_1598358"
NOTICE:  dropped partition "def" for relation "s_heap_co"
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def5" for table "s_heap_co"
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def0" for table "s_heap_co"
select * from s_heap_co_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def4 |  1 | 2.3 | t
  1 | def4 |  1 | 2.3 | t
(2 rows)

drop table s_heap_co;
-- MPP-18456 end
-- MPP-18457, MPP-18415
CREATE TABLE non_ws_phone_leads (
    lead_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    source_system_lead_id character varying(60) NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_event_type_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_site_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_date_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_time_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_phone_number_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    duration_second smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_program_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_call_status_key integer NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_phone_department_set_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_phone_channel_set_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_phone_provider_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768),
    dim_phone_ad_set_key smallint NOT NULL ENCODING (compresstype=quicklz,compresslevel=1,blocksize=32768)
)
WITH (appendonly=true, compresstype=quicklz, orientation=column) DISTRIBUTED BY (dim_site_key ,dim_date_key) PARTITION BY RANGE(dim_date_key) 
          (
          PARTITION p_max START (2451545) END (9999999) WITH (tablename='non_ws_phone_leads_1_prt_p_max', orientation=column, appendonly=true ) 
                    COLUMN lead_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN source_system_lead_id ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_event_type_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_site_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_date_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_time_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_number_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN duration_second ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_program_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_call_status_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_department_set_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_channel_set_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_provider_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_ad_set_key ENCODING (compresstype=quicklz, compresslevel=1, blocksize=32768)
          );
NOTICE:  CREATE TABLE will create partition "non_ws_phone_leads_1_prt_p_max" for table "non_ws_phone_leads"
INSERT INTO non_ws_phone_leads VALUES (63962490, 'CA6qOEyxOmNJUQC7', 5058, 999901, 2455441, 40435, 999904, 207, 79, 2, 9901, 9901, 1, 9901);
CREATE TABLE dim_phone_numbers (
    dim_phone_number_key integer NOT NULL,
    media_tracker_description character varying(40) NOT NULL,
    formatted_phone_number character varying(20) NOT NULL,
    source_system_phone_number_id character varying(100) NOT NULL,
    last_modified_date timestamp without time zone NOT NULL
) DISTRIBUTED BY (dim_phone_number_key);
ALTER TABLE ONLY dim_phone_numbers
    ADD CONSTRAINT dim_phone_numbers_pk1 PRIMARY KEY (dim_phone_number_key);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "dim_phone_numbers_pkey" for table "dim_phone_numbers"
INSERT INTO dim_phone_numbers VALUES (999902, 'test', '800-123-4568', '8001234568', '2012-09-25 13:34:35.037637');
INSERT INTO dim_phone_numbers VALUES (999904, 'test', '(800) 123-4570', '8001234570', '2012-09-25 13:34:35.148104');
INSERT INTO dim_phone_numbers VALUES (999903, 'test', '(800) 123-4569', '8001234569', '2012-09-25 13:34:35.093523');
INSERT INTO dim_phone_numbers VALUES (999901, 'test', '(800)123-4567', '8001234567', '2012-09-25 13:34:34.781042');
INSERT INTO dim_phone_numbers SELECT gs.*, dim_phone_numbers.media_tracker_description, dim_phone_numbers.formatted_phone_number, dim_phone_numbers.source_system_phone_number_id, dim_phone_numbers.last_modified_date FROM dim_phone_numbers, generate_series(1,100000) gs WHERE dim_phone_numbers.dim_phone_number_key = 999901;
ANALYZE dim_phone_numbers;  
-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Equality condition with constant on one distribution key
-- Redistribute over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Equality conditions with constants on all distribution keys
-- Redistribute over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Broadcast over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Join condition uses functions
-- Broadcast over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY + 1 = DPN.DIM_PHONE_NUMBER_KEY + 1
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Equality condition with constant on one distribution key
-- Redistribute over Append
-- Accessing a varchar in the SELECT clause should cause a SIGSEGV
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY, source_system_lead_id
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441;
 duration_second | dim_program_key | dim_site_key | dim_date_key | source_system_lead_id 
-----------------+-----------------+--------------+--------------+-----------------------
             207 |              79 |       999901 |      2455441 | CA6qOEyxOmNJUQC7
(1 row)

DROP TABLE non_ws_phone_leads;
DROP TABLE dim_phone_numbers;
-- Equality condition with a constant expression on one distribution key
drop table if exists foo_p;
drop table if exists bar;
create table foo_p( a int, b int, k int, t text, p int) distributed by (a,b) partition by range(p) ( start(0) end(10) every (2), default partition other);
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_other" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
create table bar( a int, b int, k int, t text, p int) distributed by (a);
insert into foo_p select i, i % 10, i , i || 'SOME NUMBER SOME NUMBER', i % 10 from generate_series(1, 1000) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 100) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 10000) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 10000) i;
analyze foo_p;
analyze bar;
set optimizer_segments = 3;
set optimizer_nestloop_factor = 1.0;
explain select foo_p.b, foo_p.t from foo_p left outer join bar on foo_p.a = bar.k  where foo_p.t is not null and foo_p.a = (array[1])[1];
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=361.83..471.40 rows=2234 width=36)
   ->  Hash Left Join  (cost=361.83..471.40 rows=2234 width=36)
         Hash Cond: public.foo_p.a = bar.k
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..53.73 rows=1 width=34)
               Hash Key: ('{1}'::integer[])[1]
               ->  Append  (cost=0.00..22.50 rows=1 width=34)
                     ->  Seq Scan on foo_p  (cost=0.00..22.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_other foo_p  (cost=0.00..0.00 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_2 foo_p  (cost=0.00..6.24 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_3 foo_p  (cost=0.00..6.24 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_4 foo_p  (cost=0.00..6.24 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_5 foo_p  (cost=0.00..6.24 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_6 foo_p  (cost=0.00..6.24 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
         ->  Hash  (cost=333.92..333.92 rows=1117 width=4)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..333.92 rows=1117 width=4)
                     Hash Key: bar.k
                     ->  Seq Scan on bar  (cost=0.00..289.25 rows=1117 width=4)
                           Filter: k = ('{1}'::integer[])[1]
(26 rows)

reset optimizer_segments;
drop table if exists foo_p;
drop table if exists bar;
-- MPP-18457, MPP-18415 end
-- MPP-18359
drop view if exists redundantly_named_part cascade;
NOTICE:  view "redundantly_named_part" does not exist, skipping
create view redundantly_named_part(tableid, partid, partname) as
	with 
		dups(paroid, partname) as 
		(
			select paroid, parname
			from pg_partition_rule 
			where parname is not null 
			group by paroid, parname 
			having count(*) > 1
		),
		parts(tableid, partid, paroid, partname) as
		(
			select p.parrelid, r.parchildrelid, r.paroid, r.parname
			from pg_partition p, pg_partition_rule r
			where not p.paristemplate and
				p.oid = r.paroid
		)
	select p.tableid::regclass, p.partid::regclass, p.partname
	from parts p, dups d
	where 
		p.paroid = d.paroid and
		p.partname = d.partname;
drop table if exists pnx;
NOTICE:  table "pnx" does not exist, skipping
create table pnx 
    (x int , y text)
    distributed randomly
    partition by list (y)
        ( 
            partition a values ('x1', 'x2'),
            partition c values ('x3', 'x4')
        );
NOTICE:  CREATE TABLE will create partition "pnx_1_prt_a" for table "pnx"
NOTICE:  CREATE TABLE will create partition "pnx_1_prt_c" for table "pnx"
insert into pnx values
    (1,'x1'),
    (2,'x2'),
    (3,'x3'), 
    (4,'x4');
select tableoid::regclass, * 
from pnx;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 2 | x2
 pnx_1_prt_c | 4 | x4
 pnx_1_prt_a | 1 | x1
 pnx_1_prt_c | 3 | x3
(4 rows)

alter table pnx
    split partition a at ('x1')
    into (partition b, partition c);
ERROR:  cannot split into an existing partition
select * 
from redundantly_named_part;
 tableid |   partid   | partname 
---------+------------+----------
 at      | at_1_prt_2 | 
 at      | at_1_prt_3 | 
(2 rows)

select tableoid::regclass, * 
from pnx;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 2 | x2
 pnx_1_prt_c | 4 | x4
 pnx_1_prt_a | 1 | x1
 pnx_1_prt_c | 3 | x3
(4 rows)

select tableoid::regclass, *
from pnx
where y = 'x1';
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
(1 row)

select tableoid::regclass, *
from pnx
where x = 1;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
(1 row)

drop table if exists pxn;
NOTICE:  table "pxn" does not exist, skipping
create table pxn 
    (x int , y text)
    distributed randomly
    partition by list (y)
        ( 
            partition a values ('x1', 'x2'),
            partition c values ('x3', 'x4')
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (1,'x1'),
    (2,'x2'),
    (3,'x3'), 
    (4,'x4');
select tableoid::regclass, * 
from pxn;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
 pxn_1_prt_c | 4 | x4
 pxn_1_prt_a | 1 | x1
 pxn_1_prt_c | 3 | x3
(4 rows)

alter table pxn
    split partition a at ('x1')
    into (partition c, partition b);
ERROR:  cannot split into an existing partition
select * 
from redundantly_named_part;
 tableid |   partid   | partname 
---------+------------+----------
 at      | at_1_prt_2 | 
 at      | at_1_prt_3 | 
(2 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 1 | x1
 pxn_1_prt_c | 3 | x3
 pxn_1_prt_a | 2 | x2
 pxn_1_prt_c | 4 | x4
(4 rows)

select tableoid::regclass, *
from pxn
where y = 'x2';
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
(1 row)

select tableoid::regclass, *
from pxn
where x = 2;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
(1 row)

drop table if exists pxn;
create table pxn 
    (x int , y int)
    distributed randomly
    partition by range (y)
        ( 
            partition a start (0) end (10),
            partition c start (11) end (20)
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (4,4),
    (9,9),
    (14,14), 
    (19,19);
select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
(4 rows)

alter table pxn
    split partition a at (5)
    into (partition b, partition c);
ERROR:  cannot split into an existing partition
select * 
from redundantly_named_part;
 tableid |   partid   | partname 
---------+------------+----------
 at      | at_1_prt_2 | 
 at      | at_1_prt_3 | 
(2 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
(4 rows)

select tableoid::regclass, *
from pxn
where y = 4;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 4 | 4
(1 row)

select tableoid::regclass, *
from pxn
where x = 4;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 4 | 4
(1 row)

drop table if exists pxn;
create table pxn 
    (x int , y int)
    distributed randomly
    partition by range (y)
        ( 
            partition a start (0) end (10),
            partition c start (11) end (20)
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (4,4),
    (9,9),
    (14,14), 
    (19,19);
select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
(4 rows)

alter table pxn
    split partition a at (5)
    into (partition c, partition b);
ERROR:  cannot split into an existing partition
select * 
from redundantly_named_part;
 tableid |   partid   | partname 
---------+------------+----------
 at      | at_1_prt_2 | 
 at      | at_1_prt_3 | 
(2 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
(4 rows)

select tableoid::regclass, *
from pxn
where y = 9;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 9 | 9
(1 row)

select tableoid::regclass, *
from pxn
where x = 9;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 9 | 9
(1 row)

-- MPP-18359 end
-- MPP-19105
-- Base partitions with trailing dropped columns
drop table if exists t;
NOTICE:  table "t" does not exist, skipping
create table t (
        a int, 
        b int, 
        c char,
        d varchar(50)
) distributed by (c)  
partition by range (a)  
( 
        partition p1 start(1) end(5),
        partition p2 start(5)
);
NOTICE:  CREATE TABLE will create partition "t_1_prt_p1" for table "t"
NOTICE:  CREATE TABLE will create partition "t_1_prt_p2" for table "t"
-- Drop column
alter table t drop column d;
-- Alter table split partition
alter table t split partition for(1) at (2) into (partition p11, partition p22);
NOTICE:  exchanged partition "p1" of relation "t" with relation "pg_temp_362911"
NOTICE:  dropped partition "p1" for relation "t"
NOTICE:  CREATE TABLE will create partition "t_1_prt_p11" for table "t"
NOTICE:  CREATE TABLE will create partition "t_1_prt_p22" for table "t"
insert into  t values(1,2,'a');
select * from t;
 a | b | c  
---+---+---
 1 | 2 | a
(1 row) 

-- END MPP-19105
reset optimizer_nestloop_factor;
