/* C code produced by gperf version 3.0.4 */
/* Command-line: gperf -S 1 --hash-fn-name=cq_hash --lookup-fn-name=cq_lookup --duplicates --key=11,18,20,27,29,39,43,61,92 -t gperf.init  */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
#endif



/* 
   WARNING: DO NOT MODIFY THIS FILE: 
   Generated by ../../../../src/include/catalog/calico.pl version 55
   on Thu Apr 17 15:20:17 2014

ARGV: \-meta\ \/Users\/jianl\/Git\/hawq\/mn\/cdb\-pg\/\.\.\/gpMgmt\/bin\/gppylib\/data\/1\.2\.json\ \-filemap\ caqlfilemap\.json\ \-uniqdef\ uniqdef\.json\ \-basedef\ basedef\.json\ \-gperf\ gperf\.init\ \-infiles\ caql\.files

*/

/*-------------------------------------------------------------------------
 *
 * catquery.c
 *	  general catalog table access methods (internal api)
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include <math.h>
#include <fcntl.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>

#include "access/catquery.h"
#include "access/genam.h"
#include "access/heapam.h"
#include "access/relscan.h"
#include "access/transam.h"

#include "catalog/caqlparse.h"
#include "catalog/catalog.h"
#include "catalog/indexing.h"
#include "catalog/pg_aggregate.h"
#include "catalog/pg_amop.h"
#include "catalog/pg_amproc.h"
#include "catalog/pg_appendonly_alter_column.h"
#include "catalog/pg_attrdef.h"
#include "catalog/pg_auth_members.h"
#include "catalog/pg_authid.h"
#include "catalog/pg_autovacuum.h"
#include "catalog/pg_cast.h"
#include "catalog/pg_class.h"
#include "catalog/pg_constraint.h"
#include "catalog/pg_conversion.h"
#include "catalog/pg_database.h"
#include "catalog/pg_depend.h"
#include "catalog/pg_description.h"
#include "catalog/pg_extprotocol.h"
#include "catalog/pg_exttable.h"
#include "catalog/pg_filespace.h"
#include "catalog/pg_filespace_entry.h"
#include "catalog/pg_inherits.h"
#include "catalog/pg_language.h"
#include "catalog/pg_largeobject.h"
#include "catalog/pg_listener.h"
#include "catalog/pg_namespace.h"
#include "catalog/pg_opclass.h"
#include "catalog/pg_operator.h"
#include "catalog/pg_partition.h"
#include "catalog/pg_partition_rule.h"
#include "catalog/pg_pltemplate.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_resqueue.h"
#include "catalog/pg_rewrite.h"
#include "catalog/pg_shdepend.h"
#include "catalog/pg_shdescription.h"
#include "catalog/pg_statistic.h"
#include "catalog/pg_tablespace.h"
#include "catalog/pg_trigger.h"
#include "catalog/pg_user_mapping.h"
#include "catalog/pg_window.h"
#include "catalog/pg_tidycat.h"

#include "catalog/gp_configuration.h"
#include "catalog/gp_configuration.h"
#include "catalog/gp_segment_config.h"
#include "catalog/gp_san_config.h"

#include "catalog/gp_fastsequence.h"

#include "catalog/gp_master_mirroring.h"
#include "catalog/gp_persistent.h"
#include "catalog/gp_global_sequence.h"
#include "catalog/gp_id.h"
#include "catalog/gp_version.h"
#include "catalog/toasting.h"
#include "catalog/gp_policy.h"

#include "miscadmin.h"
#include "storage/fd.h"
#include "utils/fmgroids.h"
#include "utils/relcache.h"
#include "utils/lsyscache.h"
#include "utils/syscache.h"

#include "utils/acl.h"
#include "utils/builtins.h"
#include "utils/inval.h"

#include "cdb/cdbpersistenttablespace.h"
#include "cdb/cdbvars.h"



static void caql_UpdateIndexes(cqContext	*pCtx, 
							   Relation		 rel, 
							   HeapTuple	 tup);

#define caql_getattr_internal(pCtx, tup, attnum, isnull) \
(((pCtx)->cq_usesyscache) ? \
(SysCacheGetAttr((pCtx)->cq_cacheId, (tup), (attnum), (isnull))) : \
(heap_getattr((tup), (attnum), (pCtx)->cq_tupdesc, (isnull))))

#define caql_heapclose(pCtx) \
if (!(pCtx)->cq_externrel) { \
heap_close((pCtx)->cq_heap_rel, (pCtx)->cq_lockmode); \
(pCtx)->cq_heap_rel = InvalidRelation; } else



/* ----------------------------------------------------------------
 * cq_lookup() 
 * cq_lookup() defines a hash cookie for every cql() declaration.  The
 * cookie associates the caql string with a "base query" function
 * [caql_basic_fn_#()] that constructs the scan for the query.  
 * caql_switch() dispatches on the cookie to the base query function.
 * ----------------------------------------------------------------
*/

#ifdef NOT_USED


struct caql_hash_cookie
{
	const char *name;       /* caql string */
	int uniqquery_code;     /* corresponding unique query */
	int basequery_code;     /* corresponding base query */
	int bDelete;            /* query performs DELETE */
	int bCount;             /* SELECT COUNT(*) (or DELETE) */
	int bUpdate;            /* SELECT ... FOR UPDATE */
	int bInsert;            /* INSERT INTO  */
	AttrNumber attnum;      /* column number (or 0 if no column specified) */
};

#define TOTAL_KEYWORDS 409
#define MIN_WORD_LENGTH 19
#define MAX_WORD_LENGTH 170
#define MIN_HASH_VALUE 23
#define MAX_HASH_VALUE 1757
/* maximum key range = 1735, duplicates = 0 */

#ifdef __GNUC__

#else
#ifdef __cplusplus

#endif
#endif
static unsigned int
cq_hash (str, len)
     register const char *str;
     register unsigned int len;
{
  static unsigned short asso_values[] =
    {
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758,    0,    0, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758,    0, 1758, 1758, 1758, 1758,  160,
        20,    0, 1758, 1758, 1758, 1758, 1758, 1758,   25, 1758,
        25,   10,    5, 1758, 1758,  145, 1758, 1758,    0,   45,
       495, 1758,  405,  280, 1758, 1758, 1758,    0,   60,    0,
         0, 1758,    5,  411,    5,   20, 1758,  295,  175,    0,
      1758, 1758, 1758, 1758, 1758,  542,  480,    5,  210,    5,
         0,  105,   90,  245,  425,   30,  260,   10,  335,  235,
         0,   10,   35,   95,   10,    5,   20,    0,  465,  328,
         5,    0,    5, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
      1758, 1758, 1758, 1758, 1758, 1758, 1758
    };
  register int hval = len;

  switch (hval)
    {
      default:
        hval += asso_values[(unsigned char)str[91]];
      /*FALLTHROUGH*/
      case 91:
      case 90:
      case 89:
      case 88:
      case 87:
      case 86:
      case 85:
      case 84:
      case 83:
      case 82:
      case 81:
      case 80:
      case 79:
      case 78:
      case 77:
      case 76:
      case 75:
      case 74:
      case 73:
      case 72:
      case 71:
      case 70:
      case 69:
      case 68:
      case 67:
      case 66:
      case 65:
      case 64:
      case 63:
      case 62:
      case 61:
        hval += asso_values[(unsigned char)str[60]];
      /*FALLTHROUGH*/
      case 60:
      case 59:
      case 58:
      case 57:
      case 56:
      case 55:
      case 54:
      case 53:
      case 52:
      case 51:
      case 50:
      case 49:
      case 48:
      case 47:
      case 46:
      case 45:
      case 44:
      case 43:
        hval += asso_values[(unsigned char)str[42]];
      /*FALLTHROUGH*/
      case 42:
      case 41:
      case 40:
      case 39:
        hval += asso_values[(unsigned char)str[38]];
      /*FALLTHROUGH*/
      case 38:
      case 37:
      case 36:
      case 35:
      case 34:
      case 33:
      case 32:
      case 31:
      case 30:
      case 29:
        hval += asso_values[(unsigned char)str[28]];
      /*FALLTHROUGH*/
      case 28:
      case 27:
        hval += asso_values[(unsigned char)str[26]+1];
      /*FALLTHROUGH*/
      case 26:
      case 25:
      case 24:
      case 23:
      case 22:
      case 21:
      case 20:
        hval += asso_values[(unsigned char)str[19]];
      /*FALLTHROUGH*/
      case 19:
      case 18:
        hval += asso_values[(unsigned char)str[17]];
      /*FALLTHROUGH*/
      case 17:
      case 16:
      case 15:
      case 14:
      case 13:
      case 12:
      case 11:
        hval += asso_values[(unsigned char)str[10]];
        break;
    }
  return hval;
}

#ifdef __GNUC__

#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__

#endif
#endif
static struct caql_hash_cookie *
cq_lookup (str, len)
     register const char *str;
     register unsigned int len;
{
  static struct caql_hash_cookie wordlist[] =
    {

      {"INSERT INTO pg_language", 73, 29, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_cast", 57, 13, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_index ", 71, 27, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_resqueue", 82, 38, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_amop", 48, 4, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_proc ", 80, 36, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_class ", 58, 14, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_opclass", 75, 31, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_class ", 132, 90, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_description", 63, 19, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_attrdef ", 51, 7, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_constraint", 59, 15, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_resqueue ", 229, 170, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_exttable", 65, 21, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_database", 149, 104, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_database ", 150, 104, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_type ", 90, 46, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_extprotocol", 64, 20, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_depend ", 62, 18, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_shdepend ", 84, 40, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_appendonly", 50, 6, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_partition ", 77, 33, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_amproc", 49, 5, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_shdescription", 85, 41, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_constraint  WHERE conrelid = :1 ", 138, 97, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_cast  WHERE oid = :1 ", 11, 89, 1, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_authid ", 56, 12, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT oprname FROM pg_operator  WHERE oid = :1 ", 368, 143, 0, 0, 0, 0, Anum_pg_operator_oprname},

      {"INSERT INTO pg_attribute ", 52, 8, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_am  WHERE oid = :1 ", 105, 60, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oprcode FROM pg_operator  WHERE oid = :1 ", 365, 143, 0, 0, 0, 0, Anum_pg_operator_oprcode},

      {"SELECT * FROM pg_constraint  WHERE contypid = :1 ", 141, 99, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_constraint  WHERE conrelid = :1  FOR UPDATE ", 139, 97, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oprrest FROM pg_operator  WHERE oid = :1 ", 372, 143, 0, 0, 0, 0, Anum_pg_operator_oprrest},

      {"SELECT * FROM pg_constraint  WHERE conrelid = :1 AND contype = :2", 140, 98, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_constraint  WHERE conname = :1  AND connamespace = :2 ", 137, 96, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT opcowner FROM pg_opclass WHERE oid = :1 ", 364, 140, 0, 0, 0, 0, Anum_pg_opclass_opcowner},

      {"SELECT relname FROM pg_class  WHERE oid = :1 ", 389, 91, 0, 0, 0, 0, Anum_pg_class_relname},

      {"SELECT * FROM pg_constraint  WHERE contypid = :1  FOR UPDATE ", 142, 99, 0, 0, 1, 0, InvalidAttrNumber},

      {"INSERT INTO pg_partition_encoding ", 78, 34, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO gp_distribution_policy ", 45, 1, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_conversion  WHERE conname = :1  AND connamespace = :2 ", 145, 101, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_type  WHERE oid = :1 ", 42, 198, 1, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_attribute_encoding", 53, 9, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT rolname FROM pg_authid  WHERE oid = :1 ", 394, 83, 0, 0, 0, 0, Anum_pg_authid_rolname},

      {"SELECT srvowner FROM pg_foreign_server WHERE oid = :1 ", 399, 124, 0, 0, 0, 0, Anum_pg_foreign_server_srvowner},

      {"SELECT reltype FROM pg_class  WHERE oid = :1 ", 393, 91, 0, 0, 0, 0, Anum_pg_class_reltype},

      {"SELECT fsname FROM pg_filespace  WHERE oid = :1 ", 328, 118, 0, 0, 0, 0, Anum_pg_filespace_fsname},

      {"SELECT nspowner FROM pg_namespace WHERE oid = :1 ", 335, 139, 0, 0, 0, 0, Anum_pg_namespace_nspowner},

      {"SELECT conname FROM pg_constraint  WHERE oid = :1 ", 319, 100, 0, 0, 0, 0, Anum_pg_constraint_conname},

      {"DELETE FROM pg_shdescription where objoid  = :1 AND  classoid = :2", 37, 181, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_opclass  WHERE oid = :1 ", 298, 140, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT proowner FROM pg_proc  WHERE oid = :1 ", 381, 161, 0, 0, 0, 0, Anum_pg_proc_proowner},

      {"SELECT datdba FROM pg_database WHERE oid = :1 ", 325, 106, 0, 0, 0, 0, Anum_pg_database_datdba},

      {"SELECT * FROM pg_appendonly  WHERE relid = :1 ", 110, 69, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_conversion", 60, 16, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT ptcowner FROM pg_extprotocol WHERE oid = :1 ", 385, 113, 0, 0, 0, 0, Anum_pg_extprotocol_ptcowner},

      {"INSERT INTO pg_operator", 76, 32, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_namespace  WHERE nspname = :1 ", 296, 138, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT parrelid FROM pg_partition  WHERE oid = :1 ", 377, 149, 0, 0, 0, 0, Anum_pg_partition_parrelid},

      {"SELECT COUNT(*) FROM pg_resqueue WHERE rsqname = :1", 305, 172, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_appendonly  WHERE relid = :1  FOR UPDATE ", 111, 69, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT opckeytype FROM pg_opclass  WHERE oid = :1 ", 363, 140, 0, 0, 0, 0, Anum_pg_opclass_opckeytype},

      {"SELECT castfunc FROM pg_cast  WHERE castsource = :1  AND casttarget = :2 ", 317, 88, 0, 0, 0, 0, Anum_pg_cast_castfunc},

      {"DELETE FROM pg_attribute_encoding  WHERE attrelid = :1 ", 8, 77, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT conrelid FROM pg_constraint  WHERE oid = :1 ", 322, 100, 0, 0, 0, 0, Anum_pg_constraint_conrelid},

      {"SELECT COUNT(*) FROM pg_namespace  WHERE oid = :1 ", 297, 139, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT atttypid FROM pg_attribute  WHERE attrelid = :1  AND attnum = :2 ", 316, 75, 0, 0, 0, 0, Anum_pg_attribute_atttypid},

      {"SELECT oprowner FROM pg_operator WHERE oid = :1 ", 371, 143, 0, 0, 0, 0, Anum_pg_operator_oprowner},

      {"SELECT * FROM pg_description where objoid = :1 AND  classoid = :2 AND  objsubid = :3 FOR UPDATE", 162, 112, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_authid  WHERE rolname = :1 ", 278, 84, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_authid  WHERE oid = :1 ", 277, 83, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_authid WHERE rolresqueue = :1", 279, 85, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_partition  WHERE parrelid = :1 ", 301, 150, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_opclass  WHERE opcamid = :1  AND opcname = :2  AND opcnamespace = :3 ", 299, 142, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_language  WHERE oid = :1 ", 294, 134, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_proc  WHERE oid = :1 ", 303, 161, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_language  WHERE lanname = :1 ", 293, 133, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_resourcetype FOR UPDATE", 226, 167, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM gp_fastsequence  WHERE objid = :1 ", 2, 50, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT typrelid FROM pg_type  WHERE oid = :1 ", 408, 198, 0, 0, 0, 0, Anum_pg_type_typrelid},

      {"SELECT rsqname FROM pg_resqueue WHERE oid = :1 ", 396, 171, 0, 0, 0, 0, Anum_pg_resqueue_rsqname},

      {"SELECT COUNT(*) FROM pg_cast  WHERE castsource = :1  AND casttarget = :2 ", 280, 88, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT prorettype FROM pg_proc  WHERE oid = :1 ", 382, 161, 0, 0, 0, 0, Anum_pg_proc_prorettype},

      {"SELECT indrelid FROM pg_index  WHERE indexrelid = :1 ", 330, 127, 0, 0, 0, 0, Anum_pg_index_indrelid},

      {"SELECT COUNT(*) FROM pg_amop  WHERE amopopr = :1  AND amopclaid = :2 ", 274, 65, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_attribute  WHERE attrelid = :1  AND attnum = :2 ", 276, 75, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_attribute  WHERE attrelid = :1  AND attname = :2 ", 275, 74, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT amproc FROM pg_amproc  WHERE amopclaid = :1  AND amprocsubtype = :2  AND amprocnum = :3 ", 314, 68, 0, 0, 0, 0, Anum_pg_amproc_amproc},

      {"SELECT COUNT(*) FROM pg_constraint  WHERE oid = :1 ", 284, 100, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT proname FROM pg_proc  WHERE oid = :1 ", 379, 161, 0, 0, 0, 0, Anum_pg_proc_proname},

      {"SELECT * FROM pg_conversion  WHERE connamespace = :1  AND conforencoding = :2  AND contoencoding = :3  ORDER BY connamespace,   conforencoding,    contoencoding,    oid  ", 146, 102, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT spcowner FROM pg_tablespace WHERE oid = :1 ", 398, 189, 0, 0, 0, 0, Anum_pg_tablespace_spcowner},

      {"SELECT ptcname FROM pg_extprotocol  WHERE oid = :1 ", 384, 113, 0, 0, 0, 0, Anum_pg_extprotocol_ptcname},

      {"SELECT * FROM pg_auth_members  WHERE roleid = :1  AND member = :2  FOR UPDATE ", 122, 81, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_constraint  WHERE oid = :1 ", 143, 100, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT conowner FROM pg_conversion WHERE oid = :1 ", 321, 103, 0, 0, 0, 0, Anum_pg_conversion_conowner},

      {"SELECT nspname FROM pg_namespace  WHERE oid = :1 ", 334, 139, 0, 0, 0, 0, Anum_pg_namespace_nspname},

      {"SELECT COUNT(*) FROM pg_partition_rule  WHERE parchildrelid = :1 ", 302, 154, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_conversion  WHERE oid = :1 ", 147, 103, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_resourcetype WHERE restypid = :1 FOR UPDATE", 228, 169, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_constraint  WHERE oid = :1  FOR UPDATE ", 144, 100, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_constraint  WHERE conname = :1  AND connamespace = :2 ", 283, 96, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_type  WHERE oid = :1 ", 309, 198, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type_encoding  WHERE typid = :1 ", 267, 202, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_extprotocol  WHERE oid = :1 ", 163, 113, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_conversion  WHERE oid = :1  FOR UPDATE ", 148, 103, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type_encoding  WHERE typid = :1  FOR UPDATE ", 268, 202, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_extprotocol  WHERE oid = :1  FOR UPDATE ", 164, 113, 0, 0, 1, 0, InvalidAttrNumber},

      {"INSERT INTO pg_database", 61, 17, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_operator  WHERE oid = :1 ", 300, 143, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT datname FROM pg_database  WHERE oid = :1 ", 326, 106, 0, 0, 0, 0, Anum_pg_database_datname},

      {"INSERT INTO pg_namespace", 74, 30, 0, 0, 0, 1, InvalidAttrNumber},

      {"INSERT INTO pg_resqueuecapability", 83, 39, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_tablespace  WHERE spcname = :1 ", 307, 191, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_tablespace  WHERE spcfsoid = :1 ", 306, 190, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_am  WHERE amname = :1 ", 104, 59, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_conversion  WHERE oid = :1 ", 286, 103, 0, 1, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_amop  WHERE amopclaid = :1 ", 5, 61, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT amopopr FROM pg_amop  WHERE amopclaid = :1  AND amopsubtype = :2  AND amopstrategy = :3 ", 313, 63, 0, 0, 0, 0, Anum_pg_amop_amopopr},

      {"SELECT typname FROM pg_type  WHERE oid = :1", 404, 198, 0, 0, 0, 0, Anum_pg_type_typname},

      {"SELECT typname FROM pg_type  WHERE oid = :1 ", 405, 198, 0, 0, 0, 0, Anum_pg_type_typname},

      {"INSERT INTO pg_trigger ", 89, 45, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_resourcetype WHERE resname = :1 FOR UPDATE", 227, 168, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT relowner FROM pg_class WHERE oid = :1 ", 391, 91, 0, 0, 0, 0, Anum_pg_class_relowner},

      {"INSERT INTO pg_foreign_table", 70, 26, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_opclass  WHERE oid = :1 ", 196, 140, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_operator  WHERE oprname = :1 ", 349, 145, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_opclass  WHERE opcamid = :1 ", 198, 141, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT opcamid FROM pg_opclass  WHERE oid = :1 ", 361, 140, 0, 0, 0, 0, Anum_pg_opclass_opcamid},

      {"SELECT COUNT(*) FROM pg_conversion  WHERE conname = :1  AND connamespace = :2 ", 285, 101, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT typowner FROM pg_type WHERE oid = :1 ", 407, 198, 0, 0, 0, 0, Anum_pg_type_typowner},

      {"SELECT oid FROM pg_namespace  WHERE oid = :1 ", 346, 139, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_attrdef  WHERE oid = :1 ", 114, 72, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_shdescription where objoid  = :1 AND  classoid = :2 FOR UPDATE", 243, 181, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attrdef  WHERE adrelid = :1 ", 112, 70, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT spcname FROM pg_tablespace  WHERE oid = :1 ", 397, 189, 0, 0, 0, 0, Anum_pg_tablespace_spcname},

      {"SELECT amname FROM pg_am  WHERE oid = :1 ", 312, 60, 0, 0, 0, 0, Anum_pg_am_amname},

      {"SELECT oprcom FROM pg_operator  WHERE oid = :1 ", 366, 143, 0, 0, 0, 0, Anum_pg_operator_oprcom},

      {"DELETE FROM pg_statistic  WHERE starelid = :1 ", 40, 186, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oprjoin FROM pg_operator  WHERE oid = :1 ", 367, 143, 0, 0, 0, 0, Anum_pg_operator_oprjoin},

      {"SELECT * FROM pg_extprotocol  WHERE ptcname = :1  FOR UPDATE ", 165, 114, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_filespace", 289, 116, 0, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_tablespace", 88, 44, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_trigger  WHERE oid = :1 ", 254, 192, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT conbin FROM pg_constraint  WHERE oid = :1 ", 318, 100, 0, 0, 0, 0, Anum_pg_constraint_conbin},

      {"SELECT * FROM pg_trigger  WHERE tgrelid = :1 ", 258, 195, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_attribute  WHERE attrelid = :1 ", 7, 73, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attrdef  WHERE adrelid = :1  AND adnum = :2  FOR UPDATE ", 113, 71, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_resqueuecapability WHERE resqueueid = :1  ", 231, 173, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_resqueuecapability WHERE resqueueid = :1", 35, 173, 1, 1, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_statistic  WHERE starelid = :1  AND staattnum = :2 ", 41, 187, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_tablespace", 248, 188, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_tablespace ", 249, 188, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_proc  WHERE proname = :1  AND proargtypes = :2  AND pronamespace = :3 ", 304, 164, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_class  WHERE oid = :1 ", 281, 91, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_trigger  WHERE tgrelid = :1  FOR UPDATE ", 260, 195, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_resqueuecapability WHERE resqueueid = :1  FOR UPDATE", 232, 173, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_exttable  WHERE reloid = :1 ", 18, 115, 1, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_filespace", 66, 22, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_filespace  WHERE fsname = :1 ", 290, 117, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_database  WHERE oid = :1 ", 287, 106, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT attname FROM pg_attribute  WHERE attrelid = :1  AND attnum = :2 ", 315, 75, 0, 0, 0, 0, Anum_pg_attribute_attname},

      {"SELECT * FROM pg_tablespace  WHERE spcname = :1 ", 252, 191, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_aggregate", 47, 3, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_opclass  WHERE opcamid = :1  AND opcname = :2  AND opcnamespace = :3 ", 199, 142, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_extprotocol  WHERE oid = :1 ", 17, 113, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_foreign_data_wrapper  WHERE oid = :1 ", 171, 123, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_filespace  WHERE fsname = :1 ", 343, 117, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_tablespace  WHERE spcname = :1  FOR UPDATE ", 253, 191, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_shdepend  WHERE dbid = :1 ", 36, 178, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT prosrc FROM pg_proc  WHERE oid = :1 ", 383, 161, 0, 0, 0, 0, Anum_pg_proc_prosrc},

      {"DELETE FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3 ", 30, 151, 1, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_filespace_entry", 67, 23, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_foreign_data_wrapper  WHERE oid = :1  FOR UPDATE ", 172, 123, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_resqueue  WHERE rsqname = :1 ", 355, 172, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_trigger  WHERE tgrelid = :1  AND tgname = :2  FOR UPDATE ", 259, 197, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_foreign_data_wrapper  WHERE fdwname = :1  FOR UPDATE ", 170, 122, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition  WHERE oid = :1 ", 207, 149, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT typelem FROM pg_type  WHERE oid = :1 ", 403, 198, 0, 0, 0, 0, Anum_pg_type_typelem},

      {"SELECT * FROM pg_trigger  WHERE tgrelid = :1  ORDER BY tgrelid, tgname", 261, 196, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_operator  WHERE oprname = :1  AND oprleft = :2  AND oprright = :3  AND oprnamespace = :4 ", 350, 148, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_depend  WHERE refclassid = :1  AND refobjid = :2 ", 158, 109, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_foreign_server", 69, 25, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_opclass  WHERE opcamid = :1  AND opcname = :2  AND opcnamespace = :3  FOR UPDATE ", 200, 142, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE rolsuper = :1  AND rolcanlogin = :2 ", 128, 86, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_depend  WHERE refclassid = :1  AND refobjid = :2  FOR UPDATE ", 161, 109, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_segment_configuration ", 98, 54, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_auth_members  WHERE member = :1  ORDER BY member,  roleid ", 121, 79, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT conname FROM pg_conversion  WHERE oid = :1 ", 320, 103, 0, 0, 0, 0, Anum_pg_conversion_conname},

      {"SELECT * FROM pg_resqueue WHERE rsqname = :1 FOR UPDATE", 230, 172, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_depend  WHERE refclassid = :1  AND refobjid = :2  AND refobjsubid = :3 ", 159, 110, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_database WHERE datname = :1 FOR UPDATE", 153, 105, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE rolsuper = :1  AND rolcanlogin = :2  AND oid = :3 ", 129, 87, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_namespace  WHERE nspname = :1 ", 345, 138, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM gp_fault_strategy ", 97, 53, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_depend  WHERE refclassid = :1  AND refobjid = :2  AND refobjsubid = :3  FOR UPDATE ", 160, 110, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_largeobject  WHERE loid = :1  ORDER BY loid, pageno ", 191, 136, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_amproc  WHERE amopclaid = :1  AND amprocsubtype = :2 ", 109, 67, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_foreign_server  WHERE oid = :1 ", 23, 124, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_user_mapping  WHERE umuser = :1  AND umserver = :2 ", 360, 204, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"INSERT INTO pg_inherits", 72, 28, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT parlevel FROM pg_partition  WHERE oid = :1 ", 375, 149, 0, 0, 0, 0, Anum_pg_partition_parlevel},

      {"SELECT * FROM pg_cast  WHERE oid = :1 ", 131, 89, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_largeobject  WHERE loid = :1  AND pageno >= :2  ORDER BY loid, pageno ", 189, 137, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_database  WHERE oid = :1 ", 151, 106, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_type  WHERE typname = :1  AND typnamespace = :2 ", 310, 201, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT lanname FROM pg_language  WHERE oid = :1 ", 332, 134, 0, 0, 0, 0, Anum_pg_language_lanname},

      {"SELECT * FROM pg_largeobject  WHERE loid = :1  AND pageno >= :2  ORDER BY loid, pageno  FOR UPDATE ", 190, 137, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_shdepend  WHERE dbid = :1  FOR UPDATE ", 240, 178, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_segment_configuration  WHERE dbid = :1 ", 101, 57, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_statistic  WHERE starelid = :1  AND staattnum = :2 ", 246, 187, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_database  WHERE oid = :1  FOR UPDATE ", 152, 106, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_language  WHERE oid = :1 ", 26, 134, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_extprotocol  WHERE ptcname = :1 ", 342, 114, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_attribute  WHERE attrelid = :1  FOR UPDATE ", 119, 73, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_segment_configuration  WHERE dbid = :1  FOR UPDATE ", 102, 57, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_statistic  WHERE starelid = :1  AND staattnum = :2  FOR UPDATE ", 247, 187, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM gp_distribution_policy  WHERE localoid = :1 ", 1, 49, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition  WHERE parrelid = :1 ", 208, 150, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_proc  WHERE oid = :1 ", 221, 161, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attribute  WHERE attrelid = :1  AND attnum > :2 ", 118, 76, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT fsowner FROM pg_filespace WHERE oid = :1 ", 329, 118, 0, 0, 0, 0, Anum_pg_filespace_fsowner},

      {"SELECT * FROM pg_proc  WHERE proname = :1", 223, 162, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_amop  WHERE amopopr = :1  ORDER BY amopopr,  amopclaid ", 108, 64, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_depend  WHERE classid = :1  AND objid = :2 ", 14, 107, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attribute  WHERE attrelid = :1  AND attnum = :2 ", 116, 75, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT ptcwritefn FROM pg_extprotocol  WHERE ptcname = :1 ", 388, 114, 0, 0, 0, 0, Anum_pg_extprotocol_ptcwritefn},

      {"DELETE FROM pg_filespace_entry  WHERE fsefsoid = :1 ", 21, 121, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type  WHERE oid = :1 ", 262, 198, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition  WHERE parrelid = :1  FOR UPDATE ", 211, 150, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_proc  WHERE oid = :1  FOR UPDATE ", 222, 161, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_fastsequence  WHERE objid = :1  AND objmod = :2  FOR UPDATE ", 96, 51, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_amop  WHERE amopopr = :1  AND amopclaid = :2 ", 107, 65, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_shdepend  WHERE dbid = :1  AND classid = :2  AND objid = :3  FOR UPDATE ", 239, 179, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE oid = :1 ", 124, 83, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attribute  WHERE attrelid = :1  AND attnum = :2  FOR UPDATE ", 117, 75, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_shdepend  WHERE refclassid = :1  AND refobjid = :2 ", 241, 180, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE rolname = :1 ", 126, 84, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT relnamespace FROM pg_class  WHERE oid = :1 ", 390, 91, 0, 0, 0, 0, Anum_pg_class_relnamespace},

      {"SELECT * FROM pg_type  WHERE oid = :1  FOR UPDATE ", 263, 198, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_namespace  WHERE oid = :1 ", 27, 139, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE oid = :1  FOR UPDATE ", 125, 83, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_description where objoid = :1 AND  classoid = :2", 15, 111, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_tablespace  WHERE oid = :1 ", 250, 189, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_shdepend  WHERE refclassid = :1  AND refobjid = :2  FOR UPDATE ", 242, 180, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_authid  WHERE rolname = :1  FOR UPDATE ", 127, 84, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_fastsequence  WHERE objid = :1  AND objmod = :2  AND contentid = :3  FOR UPDATE ", 95, 52, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_extprotocol  WHERE ptcname = :1 ", 288, 114, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_compression  WHERE compname = :1 ", 282, 95, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_tablespace  WHERE oid = :1  FOR UPDATE ", 251, 189, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT typnamespace FROM pg_type  WHERE oid = :1 ", 406, 198, 0, 0, 0, 0, Anum_pg_type_typnamespace},

      {"SELECT * FROM pg_depend  WHERE classid = :1  AND objid = :2 ", 154, 107, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type  WHERE typname = :1  AND typnamespace = :2 ", 265, 201, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_description where objoid = :1 AND  classoid = :2 AND  objsubid = :3", 16, 112, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT aggtranstype FROM pg_aggregate  WHERE aggfnoid = :1 ", 311, 58, 0, 0, 0, 0, Anum_pg_aggregate_aggtranstype},

      {"SELECT * FROM pg_proc  WHERE proname = :1  ORDER BY proname,  proargtypes,  pronamespace ", 225, 163, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT tgname FROM pg_trigger  WHERE oid = :1 ", 401, 192, 0, 0, 0, 0, Anum_pg_trigger_tgname},

      {"DELETE FROM pg_conversion  WHERE oid = :1 ", 12, 103, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT tgfoid FROM pg_trigger  WHERE oid = :1 ", 400, 192, 0, 0, 0, 0, Anum_pg_trigger_tgfoid},

      {"SELECT * FROM pg_depend  WHERE classid = :1  AND objid = :2  FOR UPDATE ", 157, 107, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type  WHERE typname = :1  AND typnamespace = :2  FOR UPDATE ", 266, 201, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT pronamespace FROM pg_proc  WHERE oid = :1 ", 380, 161, 0, 0, 0, 0, Anum_pg_proc_pronamespace},

      {"SELECT * FROM pg_proc  WHERE proname = :1  AND proargtypes = :2  AND pronamespace = :3  FOR UPDATE ", 224, 164, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_depend  WHERE classid = :1  AND objid = :2  AND objsubid = :3 ", 155, 108, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_operator  WHERE oid = :1 ", 201, 143, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT count(*) FROM pg_inherits  WHERE inhrelid = :1 ", 323, 131, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_depend  WHERE classid = :1  AND objid = :2  AND objsubid = :3  FOR UPDATE ", 156, 108, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_rule  WHERE oid = :1 ", 214, 153, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_operator  WHERE oid = :1  FOR UPDATE ", 202, 143, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_trigger  WHERE tgconstrname = :1 ", 256, 193, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_proc_callback ", 81, 37, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_namespace  WHERE oid = :1 ", 194, 139, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_opclass  WHERE oid = :1 ", 28, 140, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_rule  WHERE oid = :1  FOR UPDATE ", 215, 153, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_rule  WHERE parchildrelid = :1 ", 216, 154, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_class  WHERE oid = :1 ", 133, 91, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_operator  WHERE oid = :1 ", 29, 143, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * from pg_proc WHERE oid = :1", 272, 161, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_namespace  WHERE nspname = :1 ", 192, 138, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_aggregate  WHERE aggfnoid = :1 ", 103, 58, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_auth_time_constraint  WHERE authid = :1  FOR UPDATE ", 123, 82, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_namespace  WHERE oid = :1  FOR UPDATE ", 195, 139, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_opclass  WHERE oid = :1 ", 347, 140, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_partition_rule  WHERE parchildrelid = :1  FOR UPDATE ", 217, 154, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_class  WHERE relkind = :1 ", 135, 92, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_namespace  WHERE nspname = :1  FOR UPDATE ", 193, 138, 0, 0, 1, 0, InvalidAttrNumber},

      {"INSERT INTO pg_auth_members ", 54, 10, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_class  WHERE oid = :1  FOR UPDATE ", 134, 91, 0, 0, 1, 0, InvalidAttrNumber},

      {"INSERT INTO pg_foreign_data_wrapper", 68, 24, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_rewrite  WHERE ev_class = :1 ", 233, 174, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_type_encoding ", 91, 47, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_exttable  WHERE reloid = :1  FOR UPDATE ", 166, 115, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_trigger  WHERE oid = :1 ", 308, 192, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_rule  WHERE paroid = :1  AND parparentrule = :2 ", 218, 156, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_cast  WHERE castsource = :1  AND casttarget = :2 ", 130, 88, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_language WHERE oid = :1", 188, 134, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_filespace  WHERE oid = :1 ", 19, 118, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_rewrite  WHERE oid = :1 ", 236, 176, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_inherits  WHERE inhparent = :1 ", 291, 130, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT umuser FROM pg_user_mapping  WHERE oid = :1 ", 409, 203, 0, 0, 0, 0, Anum_pg_user_mapping_umuser},

      {"SELECT COUNT(*) FROM pg_largeobject  WHERE loid = :1 ", 295, 135, 0, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_auth_time_constraint ", 55, 11, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_pltemplate  WHERE tmplname = :1 ", 220, 160, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_partition_rule ", 79, 35, 0, 0, 0, 1, InvalidAttrNumber},

      {"DELETE FROM pg_proc_callback  WHERE profnoid = :1 ", 34, 165, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_rewrite  WHERE ev_class = :1  AND rulename = :2 ", 234, 175, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_segment_configuration  WHERE content = :1  AND role = :2 ", 100, 56, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_class  WHERE relname = :1 ", 338, 93, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"DELETE FROM pg_aggregate  WHERE aggfnoid = :1 ", 4, 58, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT COUNT(*) FROM pg_inherits  WHERE inhrelid = :1  AND inhseqno = :2 ", 292, 132, 0, 1, 0, 0, InvalidAttrNumber},

      {"INSERT INTO pg_stat_last_shoperation ", 87, 43, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_index  WHERE indexrelid = :1 ", 176, 127, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_segment_configuration  WHERE content = :1  AND preferred_role = :2 ", 99, 55, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_rewrite  WHERE ev_class = :1  AND rulename = :2  FOR UPDATE ", 235, 175, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_amop  WHERE amopclaid = :1  AND amopsubtype = :2 ", 106, 62, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_foreign_table  WHERE reloid = :1 ", 24, 126, 1, 1, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_amproc  WHERE amopclaid = :1 ", 6, 66, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_index  WHERE indexrelid = :1  FOR UPDATE ", 177, 127, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_partition_rule  WHERE paroid = :1 ", 32, 155, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_distribution_policy  WHERE localoid = :1 ", 93, 49, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_class  WHERE relname = :1  AND relnamespace = :2 ", 339, 94, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_operator  WHERE oprleft = :1 and oprright = :2", 203, 144, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_type_encoding  WHERE typid = :1 ", 43, 202, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM gp_distribution_policy  WHERE localoid = :1  FOR UPDATE ", 94, 49, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oprnegate FROM pg_operator  WHERE oid = :1 ", 370, 143, 0, 0, 0, 0, Anum_pg_operator_oprnegate},

      {"INSERT INTO pg_stat_last_operation ", 86, 42, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_window  WHERE winfnoid = :1 ", 270, 205, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT count(*) FROM pg_trigger  WHERE tgrelid = :1  AND tgname = :2 ", 324, 197, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_database WHERE datname = :1 ", 341, 105, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_trigger  WHERE tgconstrrelid = :1  FOR UPDATE ", 257, 194, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_partition_rule  WHERE parchildrelid = :1 ", 31, 154, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT tgrelid FROM pg_trigger  WHERE oid = :1 ", 402, 192, 0, 0, 0, 0, Anum_pg_trigger_tgrelid},

      {"SELECT * FROM pg_user_mapping  WHERE oid = :1  FOR UPDATE ", 269, 203, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT inhparent FROM pg_inherits  WHERE inhrelid = :1 ", 331, 131, 0, 0, 0, 0, Anum_pg_inherits_inhparent},

      {"SELECT * FROM pg_foreign_server  WHERE oid = :1 ", 173, 124, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_filespace_entry  WHERE fsedbid = :1 ", 20, 120, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_type  WHERE typlen = :1  AND typalign = :2  FOR UPDATE ", 264, 199, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_database  WHERE oid = :1 ", 13, 106, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_language  WHERE lanname = :1 ", 344, 133, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_foreign_server  WHERE oid = :1  FOR UPDATE ", 174, 124, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_rule  WHERE paroid = :1  AND parparentrule = :2  AND parruleord <= :3  ORDER BY paroid, parparentrule, parruleord  FOR UPDATE ", 219, 158, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_am  WHERE amname = :1 ", 336, 59, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT oid FROM pg_cast  WHERE castsource = :1  AND casttarget = :2 ", 337, 88, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * from pg_aggregate WHERE aggfnoid = :1", 271, 58, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_index  WHERE indisclustered = :1 ", 178, 128, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT lanplcallfoid FROM pg_language  WHERE oid = :1 ", 333, 134, 0, 0, 0, 0, Anum_pg_language_lanplcallfoid},

      {"DELETE FROM pg_auth_members  WHERE roleid = :1 ", 10, 80, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_type  WHERE typname = :1 ", 358, 200, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT paroid FROM pg_partition_rule  WHERE parchildrelid = :1 ", 376, 154, 0, 0, 0, 0, Anum_pg_partition_rule_paroid},

      {"SELECT oid FROM pg_proc  WHERE proname = :1 ", 354, 162, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_index  WHERE indrelid = :1", 179, 129, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_index  WHERE indrelid = :1 ", 180, 129, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_stat_last_operation  WHERE classid = :1  AND objid = :2 ", 38, 182, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_language  WHERE oid = :1 ", 186, 134, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_inherits  WHERE inhrelid = :1 ", 25, 131, 1, 1, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_partition_rule  WHERE paroid = :1  AND parparentrule = :2 ", 33, 156, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_language  WHERE oid = :1  FOR UPDATE ", 187, 134, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_compression  WHERE compname = :1 ", 136, 95, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_opclass  WHERE oid = :1  FOR UPDATE ", 197, 140, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_attrdef  WHERE oid = :1  FOR UPDATE ", 115, 72, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT oprnamespace FROM pg_operator  WHERE oid = :1 ", 369, 143, 0, 0, 0, 0, Anum_pg_operator_oprnamespace},

      {"SELECT * FROM pg_rewrite  WHERE rulename = :1 ", 238, 177, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_trigger  WHERE oid = :1  FOR UPDATE ", 255, 192, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_auth_members  WHERE member = :1 ", 9, 78, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_operator  WHERE oprname = :1  AND oprleft = :2  AND oprright = :3  AND oprnamespace = :4 ", 204, 148, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_foreign_server  WHERE srvname = :1  FOR UPDATE ", 175, 125, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_operator  WHERE oprname = :1  ORDER BY oprname,  oprleft,  oprright,  oprnamespace ", 206, 146, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT reltablespace FROM pg_class  WHERE oid = :1 ", 392, 91, 0, 0, 0, 0, Anum_pg_class_reltablespace},

      {"SELECT * FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3", 209, 151, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3 ", 210, 151, 0, 0, 0, 0, InvalidAttrNumber},

      {"INSERT INTO gp_segment_configuration ", 46, 2, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT oid FROM pg_type  WHERE typname = :1  AND typnamespace = :2 ", 359, 201, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT oid FROM pg_opclass  WHERE opcamid = :1  AND opcname = :2  AND opcnamespace = :3 ", 348, 142, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_operator  WHERE oprname = :1  AND oprleft = :2  AND oprright = :3  ORDER BY oprname,  oprleft,  oprright,  oprnamespace ", 205, 147, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_tablespace  WHERE spcname = :1", 356, 191, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT COUNT(*) FROM pg_aggregate  WHERE aggfnoid = :1 ", 273, 58, 0, 1, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3", 351, 151, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_inherits  WHERE inhparent = :1 ", 181, 130, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3  FOR UPDATE ", 352, 151, 0, 0, 1, 0, ObjectIdAttributeNumber},

      {"SELECT oid FROM pg_partition_rule  WHERE parchildrelid = :1 ", 353, 154, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT ptcreadfn FROM pg_extprotocol  WHERE ptcname = :1 ", 386, 114, 0, 0, 0, 0, Anum_pg_extprotocol_ptcreadfn},

      {"SELECT * FROM pg_filespace_entry", 168, 119, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT oid FROM pg_trigger  WHERE tgrelid = :1  AND tgname = :2 ", 357, 197, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"SELECT * FROM pg_attribute_encoding  WHERE attrelid = :1 ", 120, 77, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_stat_last_operation  WHERE classid = :1  AND objid = :2  AND staactionname = :3  FOR UPDATE ", 244, 183, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_encoding  WHERE parencoid = :1 ", 212, 152, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_partition_encoding  WHERE parencoid = :1  FOR UPDATE", 213, 152, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_filespace  WHERE fsname = :1  FOR UPDATE ", 167, 117, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_stat_last_shoperation  WHERE classid = :1  AND objid = :2 ", 39, 184, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_language  WHERE lanname = :1 ", 184, 133, 0, 0, 0, 0, InvalidAttrNumber},

      {"DELETE FROM pg_foreign_data_wrapper  WHERE oid = :1 ", 22, 123, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT ptcvalidatorfn FROM pg_extprotocol  WHERE ptcname = :1 ", 387, 114, 0, 0, 0, 0, Anum_pg_extprotocol_ptcvalidatorfn},

      {"SELECT * FROM pg_language  WHERE lanname = :1  FOR UPDATE ", 185, 133, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT opcintype FROM pg_opclass  WHERE oid = :1 ", 362, 140, 0, 0, 0, 0, Anum_pg_opclass_opcintype},

      {"SELECT dbid FROM gp_segment_configuration  WHERE content = :1  AND role = :2 ", 327, 56, 0, 0, 0, 0, Anum_gp_segment_configuration_dbid},

      {"SELECT oid FROM pg_conversion  WHERE conname = :1  AND connamespace = :2 ", 340, 101, 0, 0, 0, 0, ObjectIdAttributeNumber},

      {"INSERT INTO pg_user_mapping", 92, 48, 0, 0, 0, 1, InvalidAttrNumber},

      {"SELECT * FROM pg_filespace_entry  WHERE fsedbid = :1  FOR UPDATE ", 169, 120, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_rewrite  WHERE oid = :1  FOR UPDATE ", 237, 176, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT rolresqueue FROM pg_authid  WHERE oid = :1 ", 395, 83, 0, 0, 0, 0, Anum_pg_authid_rolresqueue},

      {"DELETE FROM gp_segment_configuration  WHERE dbid = :1 ", 3, 57, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_inherits  WHERE inhrelid = :1 ", 182, 131, 0, 0, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_inherits  WHERE inhrelid = :1  FOR UPDATE ", 183, 131, 0, 0, 1, 0, InvalidAttrNumber},

      {"DELETE FROM pg_user_mapping  WHERE oid = :1 ", 44, 203, 1, 1, 0, 0, InvalidAttrNumber},

      {"SELECT * FROM pg_stat_last_shoperation  WHERE classid = :1  AND objid = :2  AND staactionname = :3  FOR UPDATE ", 245, 185, 0, 0, 1, 0, InvalidAttrNumber},

      {"SELECT procallback FROM pg_proc_callback  WHERE profnoid = :1  AND promethod = :2 ", 378, 166, 0, 0, 0, 0, Anum_pg_proc_callback_procallback},

      {"SELECT parchildrelid FROM pg_partition_rule  WHERE paroid = :1  AND parparentrule = :2  AND parname = :3 ", 373, 157, 0, 0, 0, 0, Anum_pg_partition_rule_parchildrelid},

      {"SELECT parchildrelid FROM pg_partition_rule  WHERE paroid = :1  AND parparentrule = :2  AND parruleord = :3 ", 374, 159, 0, 0, 0, 0, Anum_pg_partition_rule_parchildrelid}
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = cq_hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          register struct caql_hash_cookie *resword;

          switch (key - 23)
            {
              case 0:
                resword = &wordlist[0];
                goto compare;
              case 1:
                resword = &wordlist[1];
                goto compare;
              case 3:
                resword = &wordlist[2];
                goto compare;
              case 5:
                resword = &wordlist[3];
                goto compare;
              case 6:
                resword = &wordlist[4];
                goto compare;
              case 7:
                resword = &wordlist[5];
                goto compare;
              case 8:
                resword = &wordlist[6];
                goto compare;
              case 9:
                resword = &wordlist[7];
                goto compare;
              case 15:
                resword = &wordlist[8];
                goto compare;
              case 18:
                resword = &wordlist[9];
                goto compare;
              case 20:
                resword = &wordlist[10];
                goto compare;
              case 22:
                resword = &wordlist[11];
                goto compare;
              case 23:
                resword = &wordlist[12];
                goto compare;
              case 25:
                resword = &wordlist[13];
                goto compare;
              case 27:
                resword = &wordlist[14];
                goto compare;
              case 28:
                resword = &wordlist[15];
                goto compare;
              case 32:
                resword = &wordlist[16];
                goto compare;
              case 33:
                resword = &wordlist[17];
                goto compare;
              case 34:
                resword = &wordlist[18];
                goto compare;
              case 36:
                resword = &wordlist[19];
                goto compare;
              case 37:
                resword = &wordlist[20];
                goto compare;
              case 42:
                resword = &wordlist[21];
                goto compare;
              case 43:
                resword = &wordlist[22];
                goto compare;
              case 45:
                resword = &wordlist[23];
                goto compare;
              case 46:
                resword = &wordlist[24];
                goto compare;
              case 48:
                resword = &wordlist[25];
                goto compare;
              case 49:
                resword = &wordlist[26];
                goto compare;
              case 50:
                resword = &wordlist[27];
                goto compare;
              case 52:
                resword = &wordlist[28];
                goto compare;
              case 53:
                resword = &wordlist[29];
                goto compare;
              case 55:
                resword = &wordlist[30];
                goto compare;
              case 56:
                resword = &wordlist[31];
                goto compare;
              case 58:
                resword = &wordlist[32];
                goto compare;
              case 60:
                resword = &wordlist[33];
                goto compare;
              case 62:
                resword = &wordlist[34];
                goto compare;
              case 63:
                resword = &wordlist[35];
                goto compare;
              case 64:
                resword = &wordlist[36];
                goto compare;
              case 67:
                resword = &wordlist[37];
                goto compare;
              case 68:
                resword = &wordlist[38];
                goto compare;
              case 71:
                resword = &wordlist[39];
                goto compare;
              case 72:
                resword = &wordlist[40];
                goto compare;
              case 73:
                resword = &wordlist[41];
                goto compare;
              case 78:
                resword = &wordlist[42];
                goto compare;
              case 80:
                resword = &wordlist[43];
                goto compare;
              case 83:
                resword = &wordlist[44];
                goto compare;
              case 86:
                resword = &wordlist[45];
                goto compare;
              case 87:
                resword = &wordlist[46];
                goto compare;
              case 90:
                resword = &wordlist[47];
                goto compare;
              case 91:
                resword = &wordlist[48];
                goto compare;
              case 92:
                resword = &wordlist[49];
                goto compare;
              case 93:
                resword = &wordlist[50];
                goto compare;
              case 95:
                resword = &wordlist[51];
                goto compare;
              case 97:
                resword = &wordlist[52];
                goto compare;
              case 98:
                resword = &wordlist[53];
                goto compare;
              case 103:
                resword = &wordlist[54];
                goto compare;
              case 107:
                resword = &wordlist[55];
                goto compare;
              case 108:
                resword = &wordlist[56];
                goto compare;
              case 110:
                resword = &wordlist[57];
                goto compare;
              case 111:
                resword = &wordlist[58];
                goto compare;
              case 112:
                resword = &wordlist[59];
                goto compare;
              case 113:
                resword = &wordlist[60];
                goto compare;
              case 115:
                resword = &wordlist[61];
                goto compare;
              case 117:
                resword = &wordlist[62];
                goto compare;
              case 120:
                resword = &wordlist[63];
                goto compare;
              case 127:
                resword = &wordlist[64];
                goto compare;
              case 128:
                resword = &wordlist[65];
                goto compare;
              case 132:
                resword = &wordlist[66];
                goto compare;
              case 134:
                resword = &wordlist[67];
                goto compare;
              case 135:
                resword = &wordlist[68];
                goto compare;
              case 137:
                resword = &wordlist[69];
                goto compare;
              case 138:
                resword = &wordlist[70];
                goto compare;
              case 139:
                resword = &wordlist[71];
                goto compare;
              case 140:
                resword = &wordlist[72];
                goto compare;
              case 142:
                resword = &wordlist[73];
                goto compare;
              case 145:
                resword = &wordlist[74];
                goto compare;
              case 146:
                resword = &wordlist[75];
                goto compare;
              case 147:
                resword = &wordlist[76];
                goto compare;
              case 150:
                resword = &wordlist[77];
                goto compare;
              case 152:
                resword = &wordlist[78];
                goto compare;
              case 153:
                resword = &wordlist[79];
                goto compare;
              case 157:
                resword = &wordlist[80];
                goto compare;
              case 159:
                resword = &wordlist[81];
                goto compare;
              case 160:
                resword = &wordlist[82];
                goto compare;
              case 164:
                resword = &wordlist[83];
                goto compare;
              case 165:
                resword = &wordlist[84];
                goto compare;
              case 171:
                resword = &wordlist[85];
                goto compare;
              case 174:
                resword = &wordlist[86];
                goto compare;
              case 175:
                resword = &wordlist[87];
                goto compare;
              case 177:
                resword = &wordlist[88];
                goto compare;
              case 178:
                resword = &wordlist[89];
                goto compare;
              case 181:
                resword = &wordlist[90];
                goto compare;
              case 182:
                resword = &wordlist[91];
                goto compare;
              case 187:
                resword = &wordlist[92];
                goto compare;
              case 188:
                resword = &wordlist[93];
                goto compare;
              case 190:
                resword = &wordlist[94];
                goto compare;
              case 191:
                resword = &wordlist[95];
                goto compare;
              case 192:
                resword = &wordlist[96];
                goto compare;
              case 196:
                resword = &wordlist[97];
                goto compare;
              case 197:
                resword = &wordlist[98];
                goto compare;
              case 201:
                resword = &wordlist[99];
                goto compare;
              case 202:
                resword = &wordlist[100];
                goto compare;
              case 203:
                resword = &wordlist[101];
                goto compare;
              case 205:
                resword = &wordlist[102];
                goto compare;
              case 207:
                resword = &wordlist[103];
                goto compare;
              case 211:
                resword = &wordlist[104];
                goto compare;
              case 212:
                resword = &wordlist[105];
                goto compare;
              case 213:
                resword = &wordlist[106];
                goto compare;
              case 223:
                resword = &wordlist[107];
                goto compare;
              case 224:
                resword = &wordlist[108];
                goto compare;
              case 230:
                resword = &wordlist[109];
                goto compare;
              case 231:
                resword = &wordlist[110];
                goto compare;
              case 240:
                resword = &wordlist[111];
                goto compare;
              case 241:
                resword = &wordlist[112];
                goto compare;
              case 255:
                resword = &wordlist[113];
                goto compare;
              case 257:
                resword = &wordlist[114];
                goto compare;
              case 258:
                resword = &wordlist[115];
                goto compare;
              case 261:
                resword = &wordlist[116];
                goto compare;
              case 263:
                resword = &wordlist[117];
                goto compare;
              case 264:
                resword = &wordlist[118];
                goto compare;
              case 267:
                resword = &wordlist[119];
                goto compare;
              case 270:
                resword = &wordlist[120];
                goto compare;
              case 271:
                resword = &wordlist[121];
                goto compare;
              case 275:
                resword = &wordlist[122];
                goto compare;
              case 276:
                resword = &wordlist[123];
                goto compare;
              case 277:
                resword = &wordlist[124];
                goto compare;
              case 280:
                resword = &wordlist[125];
                goto compare;
              case 283:
                resword = &wordlist[126];
                goto compare;
              case 285:
                resword = &wordlist[127];
                goto compare;
              case 287:
                resword = &wordlist[128];
                goto compare;
              case 289:
                resword = &wordlist[129];
                goto compare;
              case 290:
                resword = &wordlist[130];
                goto compare;
              case 291:
                resword = &wordlist[131];
                goto compare;
              case 292:
                resword = &wordlist[132];
                goto compare;
              case 293:
                resword = &wordlist[133];
                goto compare;
              case 296:
                resword = &wordlist[134];
                goto compare;
              case 297:
                resword = &wordlist[135];
                goto compare;
              case 302:
                resword = &wordlist[136];
                goto compare;
              case 303:
                resword = &wordlist[137];
                goto compare;
              case 304:
                resword = &wordlist[138];
                goto compare;
              case 308:
                resword = &wordlist[139];
                goto compare;
              case 310:
                resword = &wordlist[140];
                goto compare;
              case 313:
                resword = &wordlist[141];
                goto compare;
              case 315:
                resword = &wordlist[142];
                goto compare;
              case 317:
                resword = &wordlist[143];
                goto compare;
              case 318:
                resword = &wordlist[144];
                goto compare;
              case 321:
                resword = &wordlist[145];
                goto compare;
              case 322:
                resword = &wordlist[146];
                goto compare;
              case 323:
                resword = &wordlist[147];
                goto compare;
              case 325:
                resword = &wordlist[148];
                goto compare;
              case 326:
                resword = &wordlist[149];
                goto compare;
              case 327:
                resword = &wordlist[150];
                goto compare;
              case 328:
                resword = &wordlist[151];
                goto compare;
              case 329:
                resword = &wordlist[152];
                goto compare;
              case 330:
                resword = &wordlist[153];
                goto compare;
              case 331:
                resword = &wordlist[154];
                goto compare;
              case 333:
                resword = &wordlist[155];
                goto compare;
              case 334:
                resword = &wordlist[156];
                goto compare;
              case 336:
                resword = &wordlist[157];
                goto compare;
              case 340:
                resword = &wordlist[158];
                goto compare;
              case 341:
                resword = &wordlist[159];
                goto compare;
              case 345:
                resword = &wordlist[160];
                goto compare;
              case 346:
                resword = &wordlist[161];
                goto compare;
              case 348:
                resword = &wordlist[162];
                goto compare;
              case 350:
                resword = &wordlist[163];
                goto compare;
              case 351:
                resword = &wordlist[164];
                goto compare;
              case 353:
                resword = &wordlist[165];
                goto compare;
              case 355:
                resword = &wordlist[166];
                goto compare;
              case 356:
                resword = &wordlist[167];
                goto compare;
              case 360:
                resword = &wordlist[168];
                goto compare;
              case 362:
                resword = &wordlist[169];
                goto compare;
              case 363:
                resword = &wordlist[170];
                goto compare;
              case 365:
                resword = &wordlist[171];
                goto compare;
              case 366:
                resword = &wordlist[172];
                goto compare;
              case 367:
                resword = &wordlist[173];
                goto compare;
              case 368:
                resword = &wordlist[174];
                goto compare;
              case 370:
                resword = &wordlist[175];
                goto compare;
              case 371:
                resword = &wordlist[176];
                goto compare;
              case 372:
                resword = &wordlist[177];
                goto compare;
              case 375:
                resword = &wordlist[178];
                goto compare;
              case 376:
                resword = &wordlist[179];
                goto compare;
              case 377:
                resword = &wordlist[180];
                goto compare;
              case 380:
                resword = &wordlist[181];
                goto compare;
              case 383:
                resword = &wordlist[182];
                goto compare;
              case 384:
                resword = &wordlist[183];
                goto compare;
              case 385:
                resword = &wordlist[184];
                goto compare;
              case 394:
                resword = &wordlist[185];
                goto compare;
              case 395:
                resword = &wordlist[186];
                goto compare;
              case 396:
                resword = &wordlist[187];
                goto compare;
              case 397:
                resword = &wordlist[188];
                goto compare;
              case 400:
                resword = &wordlist[189];
                goto compare;
              case 402:
                resword = &wordlist[190];
                goto compare;
              case 405:
                resword = &wordlist[191];
                goto compare;
              case 407:
                resword = &wordlist[192];
                goto compare;
              case 408:
                resword = &wordlist[193];
                goto compare;
              case 411:
                resword = &wordlist[194];
                goto compare;
              case 419:
                resword = &wordlist[195];
                goto compare;
              case 422:
                resword = &wordlist[196];
                goto compare;
              case 426:
                resword = &wordlist[197];
                goto compare;
              case 427:
                resword = &wordlist[198];
                goto compare;
              case 431:
                resword = &wordlist[199];
                goto compare;
              case 432:
                resword = &wordlist[200];
                goto compare;
              case 435:
                resword = &wordlist[201];
                goto compare;
              case 437:
                resword = &wordlist[202];
                goto compare;
              case 441:
                resword = &wordlist[203];
                goto compare;
              case 444:
                resword = &wordlist[204];
                goto compare;
              case 449:
                resword = &wordlist[205];
                goto compare;
              case 454:
                resword = &wordlist[206];
                goto compare;
              case 455:
                resword = &wordlist[207];
                goto compare;
              case 456:
                resword = &wordlist[208];
                goto compare;
              case 457:
                resword = &wordlist[209];
                goto compare;
              case 458:
                resword = &wordlist[210];
                goto compare;
              case 460:
                resword = &wordlist[211];
                goto compare;
              case 461:
                resword = &wordlist[212];
                goto compare;
              case 462:
                resword = &wordlist[213];
                goto compare;
              case 463:
                resword = &wordlist[214];
                goto compare;
              case 467:
                resword = &wordlist[215];
                goto compare;
              case 470:
                resword = &wordlist[216];
                goto compare;
              case 472:
                resword = &wordlist[217];
                goto compare;
              case 473:
                resword = &wordlist[218];
                goto compare;
              case 475:
                resword = &wordlist[219];
                goto compare;
              case 476:
                resword = &wordlist[220];
                goto compare;
              case 477:
                resword = &wordlist[221];
                goto compare;
              case 478:
                resword = &wordlist[222];
                goto compare;
              case 479:
                resword = &wordlist[223];
                goto compare;
              case 480:
                resword = &wordlist[224];
                goto compare;
              case 481:
                resword = &wordlist[225];
                goto compare;
              case 482:
                resword = &wordlist[226];
                goto compare;
              case 483:
                resword = &wordlist[227];
                goto compare;
              case 484:
                resword = &wordlist[228];
                goto compare;
              case 486:
                resword = &wordlist[229];
                goto compare;
              case 487:
                resword = &wordlist[230];
                goto compare;
              case 488:
                resword = &wordlist[231];
                goto compare;
              case 489:
                resword = &wordlist[232];
                goto compare;
              case 490:
                resword = &wordlist[233];
                goto compare;
              case 491:
                resword = &wordlist[234];
                goto compare;
              case 492:
                resword = &wordlist[235];
                goto compare;
              case 494:
                resword = &wordlist[236];
                goto compare;
              case 495:
                resword = &wordlist[237];
                goto compare;
              case 496:
                resword = &wordlist[238];
                goto compare;
              case 497:
                resword = &wordlist[239];
                goto compare;
              case 498:
                resword = &wordlist[240];
                goto compare;
              case 503:
                resword = &wordlist[241];
                goto compare;
              case 504:
                resword = &wordlist[242];
                goto compare;
              case 505:
                resword = &wordlist[243];
                goto compare;
              case 506:
                resword = &wordlist[244];
                goto compare;
              case 507:
                resword = &wordlist[245];
                goto compare;
              case 508:
                resword = &wordlist[246];
                goto compare;
              case 509:
                resword = &wordlist[247];
                goto compare;
              case 513:
                resword = &wordlist[248];
                goto compare;
              case 514:
                resword = &wordlist[249];
                goto compare;
              case 518:
                resword = &wordlist[250];
                goto compare;
              case 521:
                resword = &wordlist[251];
                goto compare;
              case 522:
                resword = &wordlist[252];
                goto compare;
              case 523:
                resword = &wordlist[253];
                goto compare;
              case 524:
                resword = &wordlist[254];
                goto compare;
              case 526:
                resword = &wordlist[255];
                goto compare;
              case 527:
                resword = &wordlist[256];
                goto compare;
              case 528:
                resword = &wordlist[257];
                goto compare;
              case 529:
                resword = &wordlist[258];
                goto compare;
              case 533:
                resword = &wordlist[259];
                goto compare;
              case 534:
                resword = &wordlist[260];
                goto compare;
              case 535:
                resword = &wordlist[261];
                goto compare;
              case 536:
                resword = &wordlist[262];
                goto compare;
              case 537:
                resword = &wordlist[263];
                goto compare;
              case 541:
                resword = &wordlist[264];
                goto compare;
              case 544:
                resword = &wordlist[265];
                goto compare;
              case 546:
                resword = &wordlist[266];
                goto compare;
              case 553:
                resword = &wordlist[267];
                goto compare;
              case 555:
                resword = &wordlist[268];
                goto compare;
              case 556:
                resword = &wordlist[269];
                goto compare;
              case 557:
                resword = &wordlist[270];
                goto compare;
              case 558:
                resword = &wordlist[271];
                goto compare;
              case 565:
                resword = &wordlist[272];
                goto compare;
              case 566:
                resword = &wordlist[273];
                goto compare;
              case 567:
                resword = &wordlist[274];
                goto compare;
              case 570:
                resword = &wordlist[275];
                goto compare;
              case 571:
                resword = &wordlist[276];
                goto compare;
              case 572:
                resword = &wordlist[277];
                goto compare;
              case 573:
                resword = &wordlist[278];
                goto compare;
              case 574:
                resword = &wordlist[279];
                goto compare;
              case 575:
                resword = &wordlist[280];
                goto compare;
              case 576:
                resword = &wordlist[281];
                goto compare;
              case 577:
                resword = &wordlist[282];
                goto compare;
              case 580:
                resword = &wordlist[283];
                goto compare;
              case 582:
                resword = &wordlist[284];
                goto compare;
              case 585:
                resword = &wordlist[285];
                goto compare;
              case 586:
                resword = &wordlist[286];
                goto compare;
              case 587:
                resword = &wordlist[287];
                goto compare;
              case 588:
                resword = &wordlist[288];
                goto compare;
              case 590:
                resword = &wordlist[289];
                goto compare;
              case 591:
                resword = &wordlist[290];
                goto compare;
              case 593:
                resword = &wordlist[291];
                goto compare;
              case 594:
                resword = &wordlist[292];
                goto compare;
              case 595:
                resword = &wordlist[293];
                goto compare;
              case 597:
                resword = &wordlist[294];
                goto compare;
              case 599:
                resword = &wordlist[295];
                goto compare;
              case 602:
                resword = &wordlist[296];
                goto compare;
              case 603:
                resword = &wordlist[297];
                goto compare;
              case 606:
                resword = &wordlist[298];
                goto compare;
              case 607:
                resword = &wordlist[299];
                goto compare;
              case 608:
                resword = &wordlist[300];
                goto compare;
              case 610:
                resword = &wordlist[301];
                goto compare;
              case 615:
                resword = &wordlist[302];
                goto compare;
              case 616:
                resword = &wordlist[303];
                goto compare;
              case 617:
                resword = &wordlist[304];
                goto compare;
              case 619:
                resword = &wordlist[305];
                goto compare;
              case 620:
                resword = &wordlist[306];
                goto compare;
              case 621:
                resword = &wordlist[307];
                goto compare;
              case 622:
                resword = &wordlist[308];
                goto compare;
              case 623:
                resword = &wordlist[309];
                goto compare;
              case 625:
                resword = &wordlist[310];
                goto compare;
              case 626:
                resword = &wordlist[311];
                goto compare;
              case 628:
                resword = &wordlist[312];
                goto compare;
              case 631:
                resword = &wordlist[313];
                goto compare;
              case 632:
                resword = &wordlist[314];
                goto compare;
              case 634:
                resword = &wordlist[315];
                goto compare;
              case 635:
                resword = &wordlist[316];
                goto compare;
              case 637:
                resword = &wordlist[317];
                goto compare;
              case 640:
                resword = &wordlist[318];
                goto compare;
              case 641:
                resword = &wordlist[319];
                goto compare;
              case 645:
                resword = &wordlist[320];
                goto compare;
              case 650:
                resword = &wordlist[321];
                goto compare;
              case 655:
                resword = &wordlist[322];
                goto compare;
              case 656:
                resword = &wordlist[323];
                goto compare;
              case 657:
                resword = &wordlist[324];
                goto compare;
              case 662:
                resword = &wordlist[325];
                goto compare;
              case 664:
                resword = &wordlist[326];
                goto compare;
              case 665:
                resword = &wordlist[327];
                goto compare;
              case 666:
                resword = &wordlist[328];
                goto compare;
              case 669:
                resword = &wordlist[329];
                goto compare;
              case 675:
                resword = &wordlist[330];
                goto compare;
              case 678:
                resword = &wordlist[331];
                goto compare;
              case 679:
                resword = &wordlist[332];
                goto compare;
              case 680:
                resword = &wordlist[333];
                goto compare;
              case 682:
                resword = &wordlist[334];
                goto compare;
              case 685:
                resword = &wordlist[335];
                goto compare;
              case 688:
                resword = &wordlist[336];
                goto compare;
              case 690:
                resword = &wordlist[337];
                goto compare;
              case 692:
                resword = &wordlist[338];
                goto compare;
              case 695:
                resword = &wordlist[339];
                goto compare;
              case 697:
                resword = &wordlist[340];
                goto compare;
              case 700:
                resword = &wordlist[341];
                goto compare;
              case 704:
                resword = &wordlist[342];
                goto compare;
              case 705:
                resword = &wordlist[343];
                goto compare;
              case 708:
                resword = &wordlist[344];
                goto compare;
              case 712:
                resword = &wordlist[345];
                goto compare;
              case 718:
                resword = &wordlist[346];
                goto compare;
              case 721:
                resword = &wordlist[347];
                goto compare;
              case 731:
                resword = &wordlist[348];
                goto compare;
              case 740:
                resword = &wordlist[349];
                goto compare;
              case 746:
                resword = &wordlist[350];
                goto compare;
              case 755:
                resword = &wordlist[351];
                goto compare;
              case 756:
                resword = &wordlist[352];
                goto compare;
              case 760:
                resword = &wordlist[353];
                goto compare;
              case 764:
                resword = &wordlist[354];
                goto compare;
              case 767:
                resword = &wordlist[355];
                goto compare;
              case 770:
                resword = &wordlist[356];
                goto compare;
              case 776:
                resword = &wordlist[357];
                goto compare;
              case 777:
                resword = &wordlist[358];
                goto compare;
              case 790:
                resword = &wordlist[359];
                goto compare;
              case 800:
                resword = &wordlist[360];
                goto compare;
              case 810:
                resword = &wordlist[361];
                goto compare;
              case 821:
                resword = &wordlist[362];
                goto compare;
              case 825:
                resword = &wordlist[363];
                goto compare;
              case 826:
                resword = &wordlist[364];
                goto compare;
              case 843:
                resword = &wordlist[365];
                goto compare;
              case 846:
                resword = &wordlist[366];
                goto compare;
              case 847:
                resword = &wordlist[367];
                goto compare;
              case 850:
                resword = &wordlist[368];
                goto compare;
              case 852:
                resword = &wordlist[369];
                goto compare;
              case 853:
                resword = &wordlist[370];
                goto compare;
              case 854:
                resword = &wordlist[371];
                goto compare;
              case 859:
                resword = &wordlist[372];
                goto compare;
              case 870:
                resword = &wordlist[373];
                goto compare;
              case 874:
                resword = &wordlist[374];
                goto compare;
              case 876:
                resword = &wordlist[375];
                goto compare;
              case 877:
                resword = &wordlist[376];
                goto compare;
              case 889:
                resword = &wordlist[377];
                goto compare;
              case 900:
                resword = &wordlist[378];
                goto compare;
              case 902:
                resword = &wordlist[379];
                goto compare;
              case 904:
                resword = &wordlist[380];
                goto compare;
              case 914:
                resword = &wordlist[381];
                goto compare;
              case 919:
                resword = &wordlist[382];
                goto compare;
              case 946:
                resword = &wordlist[383];
                goto compare;
              case 949:
                resword = &wordlist[384];
                goto compare;
              case 956:
                resword = &wordlist[385];
                goto compare;
              case 970:
                resword = &wordlist[386];
                goto compare;
              case 981:
                resword = &wordlist[387];
                goto compare;
              case 995:
                resword = &wordlist[388];
                goto compare;
              case 1002:
                resword = &wordlist[389];
                goto compare;
              case 1003:
                resword = &wordlist[390];
                goto compare;
              case 1012:
                resword = &wordlist[391];
                goto compare;
              case 1014:
                resword = &wordlist[392];
                goto compare;
              case 1015:
                resword = &wordlist[393];
                goto compare;
              case 1026:
                resword = &wordlist[394];
                goto compare;
              case 1036:
                resword = &wordlist[395];
                goto compare;
              case 1040:
                resword = &wordlist[396];
                goto compare;
              case 1076:
                resword = &wordlist[397];
                goto compare;
              case 1102:
                resword = &wordlist[398];
                goto compare;
              case 1113:
                resword = &wordlist[399];
                goto compare;
              case 1152:
                resword = &wordlist[400];
                goto compare;
              case 1211:
                resword = &wordlist[401];
                goto compare;
              case 1234:
                resword = &wordlist[402];
                goto compare;
              case 1246:
                resword = &wordlist[403];
                goto compare;
              case 1253:
                resword = &wordlist[404];
                goto compare;
              case 1433:
                resword = &wordlist[405];
                goto compare;
              case 1519:
                resword = &wordlist[406];
                goto compare;
              case 1731:
                resword = &wordlist[407];
                goto compare;
              case 1734:
                resword = &wordlist[408];
                goto compare;
            }
          return 0;
        compare:
          {
            register const char *s = resword->name;

            if (*str == *s && !strcmp (str + 1, s + 1))
              return resword;
          }
        }
    }
  return 0;
}




/* ----------------------------------------------------------------
 * catquery statistics
 *	
 *	total files: 102
 *	total caql queries (including inserts): 776
 *	total unique queries: 409
 *	total basic queries: 205
 *	total insert statements: 48
 *	
 *	locking - table locks required for 
 *	0 tables, 0 functions:
 	  <None>
 *	space and case-sensitive query duplicates:
 	  "SELECT * FROM pg_index  WHERE indrelid = :1"
 	  "SELECT * FROM pg_index  WHERE indrelid = :1 "
 	  "SELECT * FROM pg_tablespace"
 	  "SELECT * FROM pg_tablespace "
 	  "SELECT * FROM pg_aggregate  WHERE aggfnoid = :1 "
 	  "SELECT * from pg_aggregate WHERE aggfnoid = :1"
 	  "SELECT * FROM pg_language  WHERE oid = :1 "
 	  "SELECT * FROM pg_language WHERE oid = :1"
 	  "SELECT * FROM pg_proc  WHERE oid = :1 "
 	  "SELECT * from pg_proc WHERE oid = :1"
 	  "SELECT typname FROM pg_type  WHERE oid = :1"
 	  "SELECT typname FROM pg_type  WHERE oid = :1 "
 	  "SELECT * FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3 "
 	  "SELECT * FROM pg_partition  WHERE parrelid = :1  AND parlevel = :2  AND paristemplate = :3"
 	  "SELECT * FROM pg_database"
 	  "SELECT * FROM pg_database "

 * ----------------------------------------------------------------
 */

/* base query: insert into gp_distribution_policy  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/cdb/cdbcat.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_1(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = GpPolicyRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpPolicyRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into gp_segment_configuration  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/utils/gp/segadmin.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_2(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = GpSegmentConfigRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpSegmentConfigRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_aggregate  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_aggregate.c: 1
 */
/* foreign key tables: 
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_3(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AggregateRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AggregateRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_amop  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_4(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_amproc  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_5(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AccessMethodProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_appendonly  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_appendonly.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_6(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AppendOnlyRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AppendOnlyRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_attrdef  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_7(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AttrDefaultRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttrDefaultRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_attribute  */
/* index: *None*  */
/* clients: 3		i/u/d: 3/0/0 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/catalog/index.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_8(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AttributeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_attribute_encoding  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_attribute_encoding.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_9(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AttributeEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_auth_members  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_10(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AuthMemRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthMemRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_auth_time_constraint  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_11(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AuthTimeConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthTimeConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_authid  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_12(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_cast  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/functioncmds.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_13(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = CastRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(CastRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_class  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_14(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_constraint  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_constraint.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_15(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_conversion  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_conversion.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_16(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ConversionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConversionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_database  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/dbcommands.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_17(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = DatabaseRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DatabaseRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_depend  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_depend.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_18(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = DependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_description  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/comment.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_19(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = DescriptionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DescriptionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_extprotocol  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_extprotocol.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_20(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ExtprotocolRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ExtprotocolRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_exttable  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_exttable.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_21(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ExtTableRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ExtTableRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_filespace  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/filespace.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_22(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = FileSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_filespace_entry  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/filespace.c: 1
 */
/* foreign key tables: 
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_23(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = FileSpaceEntryRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceEntryRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_foreign_data_wrapper  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_24(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ForeignDataWrapperRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignDataWrapperRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_foreign_server  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_data_wrapper
 */
static
SysScanDesc
caql_basic_fn_25(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ForeignServerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignServerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_foreign_table  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_foreign_server
 */
static
SysScanDesc
caql_basic_fn_26(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ForeignTableRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignTableRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_index  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/index.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
static
SysScanDesc
caql_basic_fn_27(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = IndexRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(IndexRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_inherits  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_28(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = InheritsRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(InheritsRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_language  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/proclang.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_29(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = LanguageRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LanguageRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_namespace  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_namespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_30(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = NamespaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(NamespaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_opclass  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 */
static
SysScanDesc
caql_basic_fn_31(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = OperatorClassRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorClassRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_operator  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_operator.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_32(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_partition  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
static
SysScanDesc
caql_basic_fn_33(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = PartitionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_partition_encoding  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 */
/* foreign key tables: 
 *   pg_partition
 */
static
SysScanDesc
caql_basic_fn_34(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = PartitionEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_partition_rule  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_35(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_proc  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_proc.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_language
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_36(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_proc_callback  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_proc_callback.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_37(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ProcCallbackRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcCallbackRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_resqueue  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_38(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ResQueueRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_resqueuecapability  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: 
 *   pg_resourcetype
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_39(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = ResQueueCapabilityRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueCapabilityRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_shdepend  */
/* index: *None*  */
/* clients: 2		i/u/d: 2/0/0 
 *   /src/backend/catalog/pg_shdepend.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_database
 */
static
SysScanDesc
caql_basic_fn_40(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = SharedDependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_shdescription  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/comment.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_41(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = SharedDescriptionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDescriptionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_stat_last_operation  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_42(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = StatLastOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_stat_last_shoperation  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_43(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = StatLastShOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastShOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_tablespace  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/tablespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_44(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = TableSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TableSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_trigger  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/trigger.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_45(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_type  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_type.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_46(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = TypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_type_encoding  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/catalog/pg_type.c: 1
 */
/* foreign key tables: 
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_47(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = TypeEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: insert into pg_user_mapping  */
/* index: *None*  */
/* clients: 1		i/u/d: 1/0/0 
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_server
 */
static
SysScanDesc
caql_basic_fn_48(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	Relation	rel;

	pCtx->cq_relationId = UserMappingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(UserMappingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	return NULL; /* XXX XXX: don't init scan */
}

/* base query: select * from gp_distribution_policy where localoid = :1  */
/* index: GpPolicyLocalOidIndexId  */
/* clients: 3		i/u/d: 0/1/1 
 *   /src/backend/cdb/cdbcat.c: 3
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_49(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = GpPolicyRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpPolicyRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_policy_localoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   GpPolicyLocalOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_fastsequence where objid = :1  */
/* index: FastSequenceObjidObjmodContentidIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/gp_fastsequence.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index gp_fastsequence(objid, ...) <FastSequenceObjidObjmodContentidIndexId>
 */
static
SysScanDesc
caql_basic_fn_50(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FastSequenceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FastSequenceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_fastsequence_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   FastSequenceObjidObjmodContentidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_fastsequence where objid = :1 and objmod = :2  */
/* index: FastSequenceObjidObjmodContentidIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/catalog/gp_fastsequence.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index gp_fastsequence(objid, ...) <FastSequenceObjidObjmodContentidIndexId>
 */
static
SysScanDesc
caql_basic_fn_51(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FastSequenceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FastSequenceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_fastsequence_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_gp_fastsequence_objmod,
				BTEqualStrategyNumber, F_INT8EQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   FastSequenceObjidObjmodContentidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_fastsequence where objid = :1 and objmod = :2 and contentid = :3  */
/* index: FastSequenceObjidObjmodContentidIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/catalog/gp_fastsequence.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_52(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FastSequenceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FastSequenceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_fastsequence_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_gp_fastsequence_objmod,
				BTEqualStrategyNumber, F_INT8EQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_gp_fastsequence_contentid,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   FastSequenceObjidObjmodContentidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_fault_strategy  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/fts/fts.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_53(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = GpFaultStrategyRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpFaultStrategyRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_segment_configuration  */
/* index: *None*  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/utils/gp/segadmin.c: 3
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_54(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = GpSegmentConfigRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpSegmentConfigRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_segment_configuration where content = :1 and preferred_role = :2  */
/* index: GpSegmentConfigContentPreferred_roleIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbutil.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_55(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = GpSegmentConfigRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpSegmentConfigRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_segment_configuration_content,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_gp_segment_configuration_preferred_role,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   GpSegmentConfigContentPreferred_roleIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_segment_configuration where content = :1 and role = :2  */
/* index: *None*  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbutil.c: 3
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_56(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = GpSegmentConfigRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpSegmentConfigRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_segment_configuration_content,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_gp_segment_configuration_role,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from gp_segment_configuration where dbid = :1  */
/* index: GpSegmentConfigDbidIndexId  */
/* clients: 4		i/u/d: 0/1/2 
 *   /src/backend/cdb/cdbutil.c: 1
 *   /src/backend/utils/gp/segadmin.c: 3
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_57(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = GpSegmentConfigRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(GpSegmentConfigRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_gp_segment_configuration_dbid,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   GpSegmentConfigDbidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_aggregate where aggfnoid = :1  */
/* index: AggregateAggfnoidIndexId  */
/* syscacheid: AGGFNOID  */
/* clients: 12		i/u/d: 0/0/1 
 *   /src/backend/cdb/cdbgroup.c: 1
 *   /src/backend/cdb/cdbquerycontextdispatching.c: 1
 *   /src/backend/commands/functioncmds.c: 1
 *   /src/backend/executor/nodeAgg.c: 1
 *   /src/backend/executor/nodeWindow.c: 1
 *   /src/backend/optimizer/plan/planwindow.c: 1
 *   /src/backend/optimizer/util/clauses.c: 1
 *   /src/backend/parser/parse_func.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 4
 */
/* foreign key tables: 
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_58(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AGGFNOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AggregateRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AggregateRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_aggregate_aggfnoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AggregateAggfnoidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_am where amname = :1  */
/* index: AmNameIndexId  */
/* syscacheid: AMNAME  */
/* clients: 7		i/u/d: 0/0/0 
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/indexcmds.c: 2
 *   /src/backend/commands/opclasscmds.c: 4
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_59(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_am_amname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AmNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_am where oid = :1  */
/* index: AmOidIndexId  */
/* syscacheid: AMOID  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_60(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AmOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amop where amopclaid = :1  */
/* index: AccessMethodStrategyIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
/* Notes: 
 *    index pg_opclass(oid) <OpclassOidIndexId> is a prefix of 
 *    	index pg_amop(amopclaid, ...) <AccessMethodStrategyIndexId>
 */
static
SysScanDesc
caql_basic_fn_61(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amop_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AccessMethodStrategyIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amop where amopclaid = :1 and amopsubtype = :2  */
/* index: AccessMethodStrategyIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
/* Notes: 
 *    index pg_opclass(oid) <OpclassOidIndexId> is a prefix of 
 *    	index pg_amop(amopclaid, ...) <AccessMethodStrategyIndexId>
 */
static
SysScanDesc
caql_basic_fn_62(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amop_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_amop_amopsubtype,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AccessMethodStrategyIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amop where amopclaid = :1 and amopsubtype = :2 and amopstrategy = :3  */
/* index: AccessMethodStrategyIndexId  */
/* syscacheid: AMOPSTRATEGY  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_63(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMOPSTRATEGY;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amop_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_amop_amopsubtype,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_amop_amopstrategy,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   AccessMethodStrategyIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amop where amopopr = :1 ORDER_BY AccessMethodOperatorIndexId  */
/* index: AccessMethodOperatorIndexId  */
/* syscacheid: AMOPOPID  */
/* clients: 8		i/u/d: 0/0/0 
 *   /src/backend/executor/nodeMergejoin.c: 1
 *   /src/backend/optimizer/util/predtest.c: 2
 *   /src/backend/parser/parse_clause.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 3
 *   /src/backend/utils/sort/tuplesort.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
/* Notes: 
 *    index pg_operator(oid) <OperatorOidIndexId> is a prefix of 
 *    	index pg_amop(amopopr, ...) <AccessMethodOperatorIndexId>
 *    Predicate does not match all index columns ( 1 != 2 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_64(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMOPOPID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amop_amopopr,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AccessMethodOperatorIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amop where amopopr = :1 and amopclaid = :2  */
/* index: AccessMethodOperatorIndexId  */
/* syscacheid: AMOPOPID  */
/* clients: 5		i/u/d: 0/0/0 
 *   /src/backend/optimizer/util/predtest.c: 2
 *   /src/backend/utils/cache/lsyscache.c: 3
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_operator
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_65(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMOPOPID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodOperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodOperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amop_amopopr,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_amop_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AccessMethodOperatorIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amproc where amopclaid = :1  */
/* index: AccessMethodProcedureIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_proc
 *   pg_type
 */
/* Notes: 
 *    index pg_opclass(oid) <OpclassOidIndexId> is a prefix of 
 *    	index pg_amproc(amopclaid, ...) <AccessMethodProcedureIndexId>
 */
static
SysScanDesc
caql_basic_fn_66(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amproc_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AccessMethodProcedureIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2  */
/* index: AccessMethodProcedureIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_proc
 *   pg_type
 */
/* Notes: 
 *    index pg_opclass(oid) <OpclassOidIndexId> is a prefix of 
 *    	index pg_amproc(amopclaid, ...) <AccessMethodProcedureIndexId>
 */
static
SysScanDesc
caql_basic_fn_67(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amproc_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_amproc_amprocsubtype,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AccessMethodProcedureIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2 and amprocnum = :3  */
/* index: AccessMethodProcedureIndexId  */
/* syscacheid: AMPROCNUM  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_opclass
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_68(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AMPROCNUM;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AccessMethodProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AccessMethodProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_amproc_amopclaid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_amproc_amprocsubtype,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_amproc_amprocnum,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   AccessMethodProcedureIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_appendonly where relid = :1  */
/* index: AppendOnlyRelidIndexId  */
/* clients: 5		i/u/d: 0/3/0 
 *   /src/backend/catalog/pg_appendonly.c: 5
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_69(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AppendOnlyRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AppendOnlyRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_appendonly_relid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AppendOnlyRelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attrdef where adrelid = :1  */
/* index: AttrDefaultIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_70(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttrDefaultRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttrDefaultRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attrdef_adrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AttrDefaultIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attrdef where adrelid = :1 and adnum = :2  */
/* index: AttrDefaultIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_71(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttrDefaultRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttrDefaultRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attrdef_adrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_attrdef_adnum,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AttrDefaultIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attrdef where oid = :1  */
/* index: AttrDefaultOidIndexId  */
/* clients: 2		i/u/d: 0/1/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_72(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttrDefaultRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttrDefaultRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AttrDefaultOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attribute where attrelid = :1  */
/* index: AttributeRelidNameIndexId  */
/* clients: 2		i/u/d: 0/1/1 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_type
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_attribute(attrelid, ...) <AttributeRelidNameIndexId>
 */
static
SysScanDesc
caql_basic_fn_73(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttributeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attribute_attrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AttributeRelidNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attribute where attrelid = :1 and attname = :2  */
/* index: AttributeRelidNameIndexId  */
/* syscacheid: ATTNAME  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/tablecmds.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_74(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = ATTNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttributeRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attribute_attrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_attribute_attname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AttributeRelidNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attribute where attrelid = :1 and attnum = :2  */
/* index: AttributeRelidNumIndexId  */
/* syscacheid: ATTNUM  */
/* clients: 12		i/u/d: 0/4/0 
 *   /src/backend/catalog/heap.c: 3
 *   /src/backend/cdb/cdbsubselect.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/parser/parse_relation.c: 3
 *   /src/backend/utils/cache/lsyscache.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_75(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = ATTNUM;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttributeRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attribute_attrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_attribute_attnum,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AttributeRelidNumIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attribute where attrelid = :1 and attnum > :2  */
/* index: AttributeRelidNumIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_type
 */
/* Notes: 
 *    WHERE clause is not strict equality
 *    Could not use syscache due to inequality
 */
static
SysScanDesc
caql_basic_fn_76(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttributeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attribute_attrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_attribute_attnum,
				BTGreaterStrategyNumber, F_INT2GT,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AttributeRelidNumIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_attribute_encoding where attrelid = :1  */
/* index: AttributeEncodingAttrelidIndexId  */
/* clients: 2		i/u/d: 0/0/1 
 *   /src/backend/catalog/pg_attribute_encoding.c: 2
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_77(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AttributeEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AttributeEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_attribute_encoding_attrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AttributeEncodingAttrelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_auth_members where member = :1  */
/* index: AuthMemMemRoleIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
/* Notes: 
 *    index pg_authid(oid) <AuthIdOidIndexId> is a prefix of 
 *    	index pg_auth_members(member, ...) <AuthMemMemRoleIndexId>
 */
static
SysScanDesc
caql_basic_fn_78(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthMemRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthMemRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_auth_members_member,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthMemMemRoleIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_auth_members where member = :1 ORDER_BY AuthMemMemRoleIndexId  */
/* index: AuthMemMemRoleIndexId  */
/* syscacheid: AUTHMEMMEMROLE  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/utils/adt/acl.c: 3
 */
/* foreign key tables: 
 *   pg_authid
 */
/* Notes: 
 *    index pg_authid(oid) <AuthIdOidIndexId> is a prefix of 
 *    	index pg_auth_members(member, ...) <AuthMemMemRoleIndexId>
 *    Predicate does not match all index columns ( 1 != 2 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_79(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AUTHMEMMEMROLE;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthMemRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthMemRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_auth_members_member,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthMemMemRoleIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_auth_members where roleid = :1  */
/* index: AuthMemRoleMemIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
/* Notes: 
 *    index pg_authid(oid) <AuthIdOidIndexId> is a prefix of 
 *    	index pg_auth_members(roleid, ...) <AuthMemRoleMemIndexId>
 */
static
SysScanDesc
caql_basic_fn_80(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthMemRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthMemRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_auth_members_roleid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthMemRoleMemIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_auth_members where roleid = :1 and member = :2  */
/* index: AuthMemRoleMemIndexId  */
/* syscacheid: AUTHMEMROLEMEM  */
/* clients: 2		i/u/d: 0/2/0 
 *   /src/backend/commands/user.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_81(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AUTHMEMROLEMEM;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthMemRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthMemRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_auth_members_roleid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_auth_members_member,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   AuthMemRoleMemIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_auth_time_constraint where authid = :1  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/user.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_82(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = AuthTimeConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthTimeConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_auth_time_constraint_authid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_authid where oid = :1  */
/* index: AuthIdOidIndexId  */
/* syscacheid: AUTHOID  */
/* clients: 15		i/u/d: 0/1/0 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_shdepend.c: 1
 *   /src/backend/commands/dbcommands.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/commands/user.c: 1
 *   /src/backend/utils/adt/acl.c: 3
 *   /src/backend/utils/adt/ruleutils.c: 1
 *   /src/backend/utils/init/miscinit.c: 1
 *   /src/backend/utils/misc/superuser.c: 1
 *   /src/backend/utils/resscheduler/resscheduler.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_83(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AUTHOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthIdOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_authid where rolname = :1  */
/* index: AuthIdRolnameIndexId  */
/* syscacheid: AUTHNAME  */
/* clients: 10		i/u/d: 0/4/0 
 *   /src/backend/commands/user.c: 6
 *   /src/backend/commands/variable.c: 2
 *   /src/backend/utils/cache/lsyscache.c: 1
 *   /src/backend/utils/init/miscinit.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_84(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = AUTHNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_authid_rolname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthIdRolnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_authid where rolresqueue = :1  */
/* index: AuthIdRolResQueueIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
/* Notes: 
 *    index pg_resqueue(oid) <ResQueueOidIndexId> is a prefix of 
 *    	index pg_authid(rolresqueue, ...) <AuthIdRolResQueueIndexId>
 */
static
SysScanDesc
caql_basic_fn_85(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_authid_rolresqueue,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   AuthIdRolResQueueIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_authid where rolsuper = :1 and rolcanlogin = :2  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/fts/fts.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_86(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_authid_rolsuper,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_authid_rolcanlogin,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_authid where rolsuper = :1 and rolcanlogin = :2 and oid = :3  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/fts/fts.c: 1
 */
/* foreign key tables: 
 *   pg_resqueue
 */
static
SysScanDesc
caql_basic_fn_87(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = AuthIdRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(AuthIdRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_authid_rolsuper,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_authid_rolcanlogin,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_cast where castsource = :1 and casttarget = :2  */
/* index: CastSourceTargetIndexId  */
/* syscacheid: CASTSOURCETARGET  */
/* clients: 6		i/u/d: 0/0/0 
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/functioncmds.c: 2
 *   /src/backend/parser/parse_coerce.c: 3
 */
/* foreign key tables: 
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_88(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CASTSOURCETARGET;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = CastRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(CastRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_cast_castsource,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_cast_casttarget,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   CastSourceTargetIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_cast where oid = :1  */
/* index: CastOidIndexId  */
/* clients: 2		i/u/d: 0/0/1 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/commands/functioncmds.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_89(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = CastRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(CastRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   CastOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_class  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/indexcmds.c: 1
 *   /src/backend/commands/vacuum.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_90(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_class where oid = :1  */
/* index: ClassOidIndexId  */
/* syscacheid: RELOID  */
/* clients: 69		i/u/d: 0/27/0 
 *   /src/backend/access/heap/heapam.c: 1
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/catalog/dependency.c: 2
 *   /src/backend/catalog/heap.c: 3
 *   /src/backend/catalog/index.c: 2
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_constraint.c: 1
 *   /src/backend/catalog/toasting.c: 1
 *   /src/backend/cdb/cdbpartition.c: 3
 *   /src/backend/commands/analyze.c: 1
 *   /src/backend/commands/cluster.c: 4
 *   /src/backend/commands/indexcmds.c: 3
 *   /src/backend/commands/sequence.c: 1
 *   /src/backend/commands/tablecmds.c: 13
 *   /src/backend/commands/trigger.c: 2
 *   /src/backend/commands/vacuum.c: 1
 *   /src/backend/optimizer/plan/planpartition.c: 1
 *   /src/backend/parser/parse_relation.c: 1
 *   /src/backend/parser/parse_utilcmd.c: 1
 *   /src/backend/rewrite/rewriteSupport.c: 1
 *   /src/backend/tcop/utility.c: 3
 *   /src/backend/utils/adt/acl.c: 3
 *   /src/backend/utils/adt/regproc.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 5
 *   /src/backend/utils/adt/selfuncs.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 8
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_91(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = RELOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ClassOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_class where relkind = :1  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/analyze.c: 1
 *   /src/backend/commands/vacuum.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_92(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_class_relkind,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_class where relname = :1  */
/* index: ClassNameNspIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/adt/regproc.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_93(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_class_relname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ClassNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_class where relname = :1 and relnamespace = :2  */
/* index: ClassNameNspIndexId  */
/* syscacheid: RELNAMENSP  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_am
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_tablespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_94(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = RELNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RelationRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RelationRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_class_relname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_class_relnamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   ClassNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_compression where compname = :1  */
/* index: CompressionCompnameIndexId  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/catalog/pg_compression.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_95(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = CompressionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(CompressionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_compression_compname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   CompressionCompnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_constraint where conname = :1 and connamespace = :2  */
/* index: ConstraintNameNspIndexId  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/catalog/pg_constraint.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_96(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_constraint_conname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_constraint_connamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   ConstraintNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_constraint where conrelid = :1  */
/* index: ConstraintRelidIndexId  */
/* clients: 9		i/u/d: 0/2/0 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/catalog/pg_constraint.c: 2
 *   /src/backend/cdb/cdbpartition.c: 1
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/tablecmds.c: 2
 *   /src/backend/utils/cache/lsyscache.c: 1
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_constraint(conrelid, ...) <ConstraintRelidIndexId>
 */
static
SysScanDesc
caql_basic_fn_97(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_constraint_conrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ConstraintRelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_constraint where conrelid = :1 and contype = :2  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbpartindex.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_98(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_constraint_conrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_constraint_contype,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_constraint where contypid = :1  */
/* index: ConstraintTypidIndexId  */
/* clients: 3		i/u/d: 0/2/0 
 *   /src/backend/catalog/pg_constraint.c: 1
 *   /src/backend/commands/typecmds.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
/* Notes: 
 *    index pg_type(oid) <TypeOidIndexId> is a prefix of 
 *    	index pg_constraint(contypid, ...) <ConstraintTypidIndexId>
 */
static
SysScanDesc
caql_basic_fn_99(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_constraint_contypid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ConstraintTypidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_constraint where oid = :1  */
/* index: ConstraintOidIndexId  */
/* clients: 8		i/u/d: 0/1/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/pg_constraint.c: 2
 *   /src/backend/utils/adt/ruleutils.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_100(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConstraintRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConstraintRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ConstraintOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_conversion where conname = :1 and connamespace = :2  */
/* index: ConversionNameNspIndexId  */
/* syscacheid: CONNAMENSP  */
/* clients: 4		i/u/d: 0/0/0 
 *   /src/backend/catalog/namespace.c: 1
 *   /src/backend/catalog/pg_conversion.c: 2
 *   /src/backend/commands/conversioncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_101(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CONNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConversionRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConversionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_conversion_conname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_conversion_connamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   ConversionNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_conversion where connamespace = :1 and conforencoding = :2 and contoencoding = :3 ORDER_BY ConversionDefaultIndexId  */
/* index: ConversionDefaultIndexId  */
/* syscacheid: CONDEFAULT  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/catalog/pg_conversion.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_proc
 */
/* Notes: 
 *    index pg_namespace(oid) <NamespaceOidIndexId> is a prefix of 
 *    	index pg_conversion(connamespace, ...) <ConversionDefaultIndexId>
 *    Predicate does not match all index columns ( 3 != 4 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_102(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CONDEFAULT;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConversionRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConversionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_conversion_connamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_conversion_conforencoding,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_conversion_contoencoding,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   ConversionDefaultIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_conversion where oid = :1  */
/* index: ConversionOidIndexId  */
/* syscacheid: CONOID  */
/* clients: 9		i/u/d: 0/2/1 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_conversion.c: 3
 *   /src/backend/commands/conversioncmds.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_103(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CONOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ConversionRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ConversionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ConversionOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_database  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/vacuum.c: 1
 *   /src/backend/utils/gp/segadmin.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_104(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = DatabaseRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DatabaseRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_database where datname = :1  */
/* index: DatabaseNameIndexId  */
/* clients: 5		i/u/d: 0/3/0 
 *   /src/backend/commands/dbcommands.c: 5
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_105(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DatabaseRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DatabaseRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_database_datname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   DatabaseNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_database where oid = :1  */
/* index: DatabaseOidIndexId  */
/* syscacheid: DATABASEOID  */
/* clients: 11		i/u/d: 0/3/1 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/commands/dbcommands.c: 4
 *   /src/backend/commands/vacuum.c: 1
 *   /src/backend/utils/adt/acl.c: 3
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_106(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = DATABASEOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DatabaseRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DatabaseRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   DatabaseOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_depend where classid = :1 and objid = :2  */
/* index: DependDependerIndexId  */
/* clients: 6		i/u/d: 0/3/1 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/pg_depend.c: 4
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_depend(classid, ...) <DependDependerIndexId>
 */
static
SysScanDesc
caql_basic_fn_107(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_depend_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_depend_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   DependDependerIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_depend where classid = :1 and objid = :2 and objsubid = :3  */
/* index: DependDependerIndexId  */
/* clients: 4		i/u/d: 0/3/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/pg_depend.c: 1
 *   /src/backend/commands/tablecmds.c: 2
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_depend(classid, ...) <DependDependerIndexId>
 */
static
SysScanDesc
caql_basic_fn_108(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_depend_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_depend_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_depend_objsubid,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   DependDependerIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_depend where refclassid = :1 and refobjid = :2  */
/* index: DependReferenceIndexId  */
/* clients: 8		i/u/d: 0/1/0 
 *   /src/backend/catalog/dependency.c: 2
 *   /src/backend/catalog/pg_depend.c: 1
 *   /src/backend/catalog/pg_proc.c: 1
 *   /src/backend/commands/tablecmds.c: 3
 *   /src/backend/commands/typecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_depend(refclassid, ...) <DependReferenceIndexId>
 */
static
SysScanDesc
caql_basic_fn_109(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_depend_refclassid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_depend_refobjid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   DependReferenceIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_depend where refclassid = :1 and refobjid = :2 and refobjsubid = :3  */
/* index: DependReferenceIndexId  */
/* clients: 5		i/u/d: 0/2/0 
 *   /src/backend/catalog/dependency.c: 2
 *   /src/backend/catalog/pg_depend.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_depend(refclassid, ...) <DependReferenceIndexId>
 */
static
SysScanDesc
caql_basic_fn_110(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_depend_refclassid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_depend_refobjid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_depend_refobjsubid,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   DependReferenceIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_description where objoid = :1 and classoid = :2  */
/* index: DescriptionObjIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/comment.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_111(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DescriptionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DescriptionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_description_objoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_description_classoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   DescriptionObjIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_description where objoid = :1 and classoid = :2 and objsubid = :3  */
/* index: DescriptionObjIndexId  */
/* clients: 2		i/u/d: 0/1/1 
 *   /src/backend/commands/comment.c: 2
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_112(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = DescriptionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(DescriptionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_description_objoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_description_classoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_description_objsubid,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   DescriptionObjIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_extprotocol where oid = :1  */
/* index: ExtprotocolOidIndexId  */
/* clients: 5		i/u/d: 0/1/1 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/catalog/pg_extprotocol.c: 2
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_113(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ExtprotocolRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ExtprotocolRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ExtprotocolOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_extprotocol where ptcname = :1  */
/* index: ExtprotocolPtcnameIndexId  */
/* clients: 7		i/u/d: 0/2/0 
 *   /src/backend/catalog/pg_extprotocol.c: 5
 *   /src/backend/commands/extprotocolcmds.c: 2
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_114(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ExtprotocolRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ExtprotocolRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_extprotocol_ptcname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ExtprotocolPtcnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_exttable where reloid = :1  */
/* index: ExtTableReloidIndexId  */
/* clients: 2		i/u/d: 0/1/1 
 *   /src/backend/catalog/pg_exttable.c: 2
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_115(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ExtTableRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ExtTableRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_exttable_reloid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ExtTableReloidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/filespace.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_116(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = FileSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace where fsname = :1  */
/* index: FilespaceNameIndexId  */
/* clients: 4		i/u/d: 0/2/0 
 *   /src/backend/commands/filespace.c: 4
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_117(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FileSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_filespace_fsname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   FilespaceNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace where oid = :1  */
/* index: FilespaceOidIndexId  */
/* clients: 3		i/u/d: 0/0/1 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/commands/filespace.c: 2
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_118(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FileSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   FilespaceOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace_entry  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/gp/segadmin.c: 1
 */
/* foreign key tables: 
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_119(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = FileSpaceEntryRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceEntryRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace_entry where fsedbid = :1  */
/* index: *None*  */
/* clients: 3		i/u/d: 0/1/2 
 *   /src/backend/commands/filespace.c: 1
 *   /src/backend/utils/gp/segadmin.c: 2
 */
/* foreign key tables: 
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_120(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = FileSpaceEntryRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceEntryRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_filespace_entry_fsedbid,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_filespace_entry where fsefsoid = :1  */
/* index: FileSpaceEntryFsefsoidIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/filespace.c: 1
 */
/* foreign key tables: 
 *   pg_filespace
 */
/* Notes: 
 *    index pg_filespace(oid) <FilespaceOidIndexId> is a prefix of 
 *    	index pg_filespace_entry(fsefsoid, ...) <FileSpaceEntryFsefsoidIndexId>
 */
static
SysScanDesc
caql_basic_fn_121(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = FileSpaceEntryRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(FileSpaceEntryRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_filespace_entry_fsefsoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   FileSpaceEntryFsefsoidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_foreign_data_wrapper where fdwname = :1  */
/* index: ForeignDataWrapperNameIndexId  */
/* syscacheid: FOREIGNDATAWRAPPERNAME  */
/* clients: 2		i/u/d: 0/2/0 
 *   /src/backend/commands/foreigncmds.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_122(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = FOREIGNDATAWRAPPERNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ForeignDataWrapperRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignDataWrapperRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_foreign_data_wrapper_fdwname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ForeignDataWrapperNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_foreign_data_wrapper where oid = :1  */
/* index: ForeignDataWrapperOidIndexId  */
/* syscacheid: FOREIGNDATAWRAPPEROID  */
/* clients: 3		i/u/d: 0/1/1 
 *   /src/backend/catalog/aclchk.c: 2
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_123(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = FOREIGNDATAWRAPPEROID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ForeignDataWrapperRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignDataWrapperRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ForeignDataWrapperOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_foreign_server where oid = :1  */
/* index: ForeignServerOidIndexId  */
/* syscacheid: FOREIGNSERVEROID  */
/* clients: 4		i/u/d: 0/1/1 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_data_wrapper
 */
static
SysScanDesc
caql_basic_fn_124(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = FOREIGNSERVEROID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ForeignServerRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignServerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ForeignServerOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_foreign_server where srvname = :1  */
/* index: ForeignServerNameIndexId  */
/* syscacheid: FOREIGNSERVERNAME  */
/* clients: 2		i/u/d: 0/2/0 
 *   /src/backend/commands/foreigncmds.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_data_wrapper
 */
static
SysScanDesc
caql_basic_fn_125(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = FOREIGNSERVERNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ForeignServerRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignServerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_foreign_server_srvname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ForeignServerNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_foreign_table where reloid = :1  */
/* index: ForeignTableRelOidIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/commands/foreigncmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_foreign_server
 */
static
SysScanDesc
caql_basic_fn_126(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ForeignTableRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ForeignTableRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_foreign_table_reloid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ForeignTableRelOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_index where indexrelid = :1  */
/* index: IndexRelidIndexId  */
/* syscacheid: INDEXRELID  */
/* clients: 17		i/u/d: 0/4/0 
 *   /src/backend/catalog/index.c: 3
 *   /src/backend/cdb/cdbpartindex.c: 1
 *   /src/backend/commands/cluster.c: 4
 *   /src/backend/commands/indexcmds.c: 3
 *   /src/backend/commands/tablecmds.c: 5
 *   /src/backend/utils/adt/ruleutils.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
static
SysScanDesc
caql_basic_fn_127(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = INDEXRELID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = IndexRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(IndexRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_index_indexrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   IndexRelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_index where indisclustered = :1  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/cluster.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
static
SysScanDesc
caql_basic_fn_128(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = IndexRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(IndexRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_index_indisclustered,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_index where indrelid = :1  */
/* index: IndexIndrelidIndexId  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbpartindex.c: 2
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_index(indrelid, ...) <IndexIndrelidIndexId>
 */
static
SysScanDesc
caql_basic_fn_129(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = IndexRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(IndexRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_index_indrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   IndexIndrelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_inherits where inhparent = :1  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/optimizer/util/plancat.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_130(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = InheritsRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(InheritsRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_inherits_inhparent,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_inherits where inhrelid = :1  */
/* index: InheritsRelidSeqnoIndexId  */
/* clients: 8		i/u/d: 0/2/1 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/cdb/cdbpartition.c: 3
 *   /src/backend/commands/tablecmds.c: 3
 *   /src/backend/parser/parse_func.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_inherits(inhrelid, ...) <InheritsRelidSeqnoIndexId>
 */
static
SysScanDesc
caql_basic_fn_131(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = InheritsRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(InheritsRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_inherits_inhrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InheritsRelidSeqnoIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_inherits where inhrelid = :1 and inhseqno = :2  */
/* index: InheritsRelidSeqnoIndexId  */
/* syscacheid: INHRELID  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_132(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = INHRELID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = InheritsRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(InheritsRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_inherits_inhrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_inherits_inhseqno,
				BTEqualStrategyNumber, F_INT4EQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InheritsRelidSeqnoIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_language where lanname = :1  */
/* index: LanguageNameIndexId  */
/* syscacheid: LANGNAME  */
/* clients: 8		i/u/d: 0/1/0 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/functioncmds.c: 1
 *   /src/backend/commands/proclang.c: 4
 *   /src/backend/utils/adt/acl.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_133(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = LANGNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = LanguageRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LanguageRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_language_lanname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   LanguageNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_language where oid = :1  */
/* index: LanguageOidIndexId  */
/* syscacheid: LANGOID  */
/* clients: 10		i/u/d: 0/1/1 
 *   /src/backend/catalog/aclchk.c: 2
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/cdb/cdbquerycontextdispatching.c: 1
 *   /src/backend/commands/functioncmds.c: 1
 *   /src/backend/commands/proclang.c: 1
 *   /src/backend/utils/adt/acl.c: 3
 *   /src/backend/utils/fmgr/fmgr.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_134(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = LANGOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = LanguageRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LanguageRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   LanguageOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_largeobject where loid = :1  */
/* index: LargeObjectLoidPagenoIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/storage/large_object/inv_api.c: 1
 */
/* foreign key tables: *None*
 */
/* Notes: 
 *    cql0 definition only - function never called
 */
static
SysScanDesc
caql_basic_fn_135(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = LargeObjectRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LargeObjectRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_largeobject_loid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   LargeObjectLoidPagenoIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_largeobject where loid = :1 ORDER_BY LargeObjectLoidPagenoIndexId  */
/* index: LargeObjectLoidPagenoIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/storage/large_object/inv_api.c: 1
 */
/* foreign key tables: *None*
 */
/* Notes: 
 *    cql0 definition only - function never called
 */
static
SysScanDesc
caql_basic_fn_136(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = LargeObjectRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LargeObjectRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_largeobject_loid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   LargeObjectLoidPagenoIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_largeobject where loid = :1 and pageno >= :2 ORDER_BY LargeObjectLoidPagenoIndexId  */
/* index: LargeObjectLoidPagenoIndexId  */
/* clients: 3		i/u/d: 0/2/0 
 *   /src/backend/storage/large_object/inv_api.c: 3
 */
/* foreign key tables: *None*
 */
/* Notes: 
 *    WHERE clause is not strict equality
 *    cql0 definition only - function never called
 */
static
SysScanDesc
caql_basic_fn_137(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = LargeObjectRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(LargeObjectRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_largeobject_loid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_largeobject_pageno,
				BTGreaterEqualStrategyNumber, F_INT4GE,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   LargeObjectLoidPagenoIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_namespace where nspname = :1  */
/* index: NamespaceNspnameIndexId  */
/* syscacheid: NAMESPACENAME  */
/* clients: 16		i/u/d: 0/2/0 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/namespace.c: 7
 *   /src/backend/catalog/pg_namespace.c: 1
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/schemacmds.c: 4
 *   /src/backend/utils/adt/acl.c: 1
 *   /src/backend/utils/adt/dbsize.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_138(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = NAMESPACENAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = NamespaceRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(NamespaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_namespace_nspname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   NamespaceNspnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_namespace where oid = :1  */
/* index: NamespaceOidIndexId  */
/* syscacheid: NAMESPACEOID  */
/* clients: 10		i/u/d: 0/2/1 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/catalog/namespace.c: 1
 *   /src/backend/commands/schemacmds.c: 2
 *   /src/backend/utils/adt/acl.c: 3
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 */
static
SysScanDesc
caql_basic_fn_139(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = NAMESPACEOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = NamespaceRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(NamespaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   NamespaceOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_opclass where oid = :1  */
/* index: OpclassOidIndexId  */
/* syscacheid: CLAOID  */
/* clients: 18		i/u/d: 0/3/1 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/index.c: 1
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/indexcmds.c: 1
 *   /src/backend/commands/opclasscmds.c: 5
 *   /src/backend/parser/parse_utilcmd.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 4
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 */
static
SysScanDesc
caql_basic_fn_140(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CLAOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorClassRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorClassRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   OpclassOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_opclass where opcamid = :1  */
/* index: OpclassAmNameNspIndexId  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/indexcmds.c: 1
 *   /src/backend/commands/opclasscmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 */
static
SysScanDesc
caql_basic_fn_141(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorClassRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorClassRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_opclass_opcamid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   OpclassAmNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_opclass where opcamid = :1 and opcname = :2 and opcnamespace = :3  */
/* index: OpclassAmNameNspIndexId  */
/* syscacheid: CLAAMNAMENSP  */
/* clients: 8		i/u/d: 0/2/0 
 *   /src/backend/catalog/namespace.c: 1
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/indexcmds.c: 1
 *   /src/backend/commands/opclasscmds.c: 5
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 */
static
SysScanDesc
caql_basic_fn_142(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = CLAAMNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorClassRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorClassRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_opclass_opcamid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_opclass_opcname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_opclass_opcnamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   OpclassAmNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oid = :1  */
/* index: OperatorOidIndexId  */
/* syscacheid: OPEROID  */
/* clients: 28		i/u/d: 0/4/1 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_operator.c: 3
 *   /src/backend/commands/opclasscmds.c: 1
 *   /src/backend/commands/operatorcmds.c: 3
 *   /src/backend/executor/nodeWindow.c: 1
 *   /src/backend/parser/analyze.c: 1
 *   /src/backend/parser/parse_oper.c: 1
 *   /src/backend/utils/adt/regproc.c: 2
 *   /src/backend/utils/adt/ruleutils.c: 2
 *   /src/backend/utils/cache/lsyscache.c: 10
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_143(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = OPEROID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   OperatorOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oprleft = :1 and oprright = :2  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/lsyscache.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_144(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_operator_oprleft,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_operator_oprright,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oprname = :1  */
/* index: OperatorNameNspIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/adt/regproc.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_145(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_operator_oprname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   OperatorNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oprname = :1 ORDER_BY OperatorNameNspIndexId  */
/* index: OperatorNameNspIndexId  */
/* syscacheid: OPERNAMENSP  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/catalog/namespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
/* Notes: 
 *    Predicate does not match all index columns ( 1 != 4 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_146(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = OPERNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_operator_oprname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   OperatorNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 ORDER_BY OperatorNameNspIndexId  */
/* index: OperatorNameNspIndexId  */
/* syscacheid: OPERNAMENSP  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/catalog/namespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
/* Notes: 
 *    Predicate does not match all index columns ( 3 != 4 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_147(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = OPERNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_operator_oprname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_operator_oprleft,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_operator_oprright,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   OperatorNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 and oprnamespace = :4  */
/* index: OperatorNameNspIndexId  */
/* syscacheid: OPERNAMENSP  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/catalog/namespace.c: 1
 *   /src/backend/catalog/pg_operator.c: 1
 *   /src/backend/executor/nodeWindow.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_namespace
 *   pg_operator
 *   pg_proc
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_148(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = OPERNAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = OperatorRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(OperatorRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_operator_oprname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_operator_oprleft,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_operator_oprright,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[3],
				Anum_pg_operator_oprnamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[3]));

	scan = systable_beginscan(rel,
				   OperatorNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 4, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition where oid = :1  */
/* index: PartitionOidIndexId  */
/* clients: 4		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbpartition.c: 2
 *   /src/backend/parser/analyze.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
static
SysScanDesc
caql_basic_fn_149(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition where parrelid = :1  */
/* index: PartitionParrelidIndexId  */
/* clients: 5		i/u/d: 0/1/0 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/cdb/cdbpartition.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_partition(parrelid, ...) <PartitionParrelidIndexId>
 */
static
SysScanDesc
caql_basic_fn_150(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_parrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionParrelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition where parrelid = :1 and parlevel = :2 and paristemplate = :3  */
/* index: PartitionParrelidParlevelParistemplateIndexId  */
/* clients: 5		i/u/d: 0/1/1 
 *   /src/backend/cdb/cdbpartindex.c: 1
 *   /src/backend/cdb/cdbpartition.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_opclass
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_partition(parrelid, ...) <PartitionParrelidParlevelParistemplateIndexId>
 */
static
SysScanDesc
caql_basic_fn_151(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_parrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_partition_parlevel,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_partition_paristemplate,
				BTEqualStrategyNumber, F_BOOLEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   PartitionParrelidParlevelParistemplateIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_encoding where parencoid = :1  */
/* index: PartitionEncodingParencoidIndexId  */
/* clients: 2		i/u/d: 0/1/0 
 *   /src/backend/cdb/cdbpartition.c: 2
 */
/* foreign key tables: 
 *   pg_partition
 */
/* Notes: 
 *    index pg_partition(oid) <PartitionOidIndexId> is a prefix of 
 *    	index pg_partition_encoding(parencoid, ...) <PartitionEncodingParencoidIndexId>
 */
static
SysScanDesc
caql_basic_fn_152(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_encoding_parencoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionEncodingParencoidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where oid = :1  */
/* index: PartitionRuleOidIndexId  */
/* clients: 3		i/u/d: 0/1/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_153(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionRuleOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where parchildrelid = :1  */
/* index: PartitionRuleParchildrelidIndexId  */
/* clients: 8		i/u/d: 0/1/1 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/cdb/cdbpartition.c: 6
 *   /src/backend/parser/analyze.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_partition_rule(parchildrelid, ...) <PartitionRuleParchildrelidIndexId>
 */
static
SysScanDesc
caql_basic_fn_154(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_parchildrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionRuleParchildrelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where paroid = :1  */
/* index: PartitionRuleParoidParparentruleParruleordIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
/* Notes: 
 *    index pg_partition(oid) <PartitionOidIndexId> is a prefix of 
 *    	index pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>
 */
static
SysScanDesc
caql_basic_fn_155(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_paroid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PartitionRuleParoidParparentruleParruleordIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where paroid = :1 and parparentrule = :2  */
/* index: PartitionRuleParoidParparentruleParruleordIndexId  */
/* clients: 3		i/u/d: 0/0/1 
 *   /src/backend/cdb/cdbpartindex.c: 1
 *   /src/backend/cdb/cdbpartition.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
/* Notes: 
 *    index pg_partition(oid) <PartitionOidIndexId> is a prefix of 
 *    	index pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>
 */
static
SysScanDesc
caql_basic_fn_156(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_paroid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_partition_rule_parparentrule,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   PartitionRuleParoidParparentruleParruleordIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parname = :3  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
static
SysScanDesc
caql_basic_fn_157(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_paroid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_partition_rule_parparentrule,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_partition_rule_parname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord <= :3 ORDER_BY PartitionRuleParoidParparentruleParruleordIndexId  */
/* index: PartitionRuleParoidParparentruleParruleordIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
/* Notes: 
 *    index pg_partition(oid) <PartitionOidIndexId> is a prefix of 
 *    	index pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>
 *    WHERE clause is not strict equality
 */
static
SysScanDesc
caql_basic_fn_158(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_paroid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_partition_rule_parparentrule,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_partition_rule_parruleord,
				BTLessEqualStrategyNumber, F_INT2LE,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   PartitionRuleParoidParparentruleParruleordIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord = :3  */
/* index: PartitionRuleParoidParparentruleParruleordIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/cdb/cdbpartition.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_partition
 *   pg_partition_rule
 *   pg_tablespace
 */
/* Notes: 
 *    index pg_partition(oid) <PartitionOidIndexId> is a prefix of 
 *    	index pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>
 */
static
SysScanDesc
caql_basic_fn_159(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PartitionRuleRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PartitionRuleRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_partition_rule_paroid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_partition_rule_parparentrule,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_partition_rule_parruleord,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   PartitionRuleParoidParparentruleParruleordIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_pltemplate where tmplname = :1  */
/* index: PLTemplateNameIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/proclang.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_160(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = PLTemplateRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(PLTemplateRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_pltemplate_tmplname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   PLTemplateNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc where oid = :1  */
/* index: ProcedureOidIndexId  */
/* syscacheid: PROCOID  */
/* clients: 56		i/u/d: 0/10/0 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_aggregate.c: 1
 *   /src/backend/catalog/pg_proc.c: 3
 *   /src/backend/cdb/cdbdisp.c: 1
 *   /src/backend/cdb/cdbquerycontextdispatching.c: 1
 *   /src/backend/commands/aggregatecmds.c: 1
 *   /src/backend/commands/functioncmds.c: 11
 *   /src/backend/commands/opclasscmds.c: 1
 *   /src/backend/executor/functions.c: 2
 *   /src/backend/executor/nodeAgg.c: 1
 *   /src/backend/executor/nodeWindow.c: 1
 *   /src/backend/optimizer/plan/planwindow.c: 2
 *   /src/backend/optimizer/util/clauses.c: 1
 *   /src/backend/parser/parse_coerce.c: 1
 *   /src/backend/parser/parse_func.c: 2
 *   /src/backend/utils/adt/acl.c: 3
 *   /src/backend/utils/adt/regproc.c: 2
 *   /src/backend/utils/adt/ruleutils.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 10
 *   /src/backend/utils/fmgr/fmgr.c: 2
 *   /src/backend/utils/fmgr/funcapi.c: 2
 *   /src/backend/utils/mb/mbutils.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_language
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_161(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = PROCOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ProcedureOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc where proname = :1  */
/* index: ProcedureNameArgsNspIndexId  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/utils/adt/regproc.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_language
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_162(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_proc_proname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ProcedureNameArgsNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc where proname = :1 ORDER_BY ProcedureNameArgsNspIndexId  */
/* index: ProcedureNameArgsNspIndexId  */
/* syscacheid: PROCNAMEARGSNSP  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/catalog/namespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_language
 *   pg_namespace
 *   pg_type
 */
/* Notes: 
 *    Predicate does not match all index columns ( 1 != 3 ),
 *    can only use syscache for SearchSysCacheList case
 */
static
SysScanDesc
caql_basic_fn_163(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = PROCNAMEARGSNSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_proc_proname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ProcedureNameArgsNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc where proname = :1 and proargtypes = :2 and pronamespace = :3  */
/* index: ProcedureNameArgsNspIndexId  */
/* syscacheid: PROCNAMEARGSNSP  */
/* clients: 4		i/u/d: 0/1/0 
 *   /src/backend/catalog/pg_proc.c: 1
 *   /src/backend/commands/aggregatecmds.c: 1
 *   /src/backend/commands/functioncmds.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_language
 *   pg_namespace
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_164(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = PROCNAMEARGSNSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcedureRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcedureRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_proc_proname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_proc_proargtypes,
				BTEqualStrategyNumber, F_OIDVECTOREQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_proc_pronamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   ProcedureNameArgsNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc_callback where profnoid = :1  */
/* index: ProcCallbackProfnoidPromethodIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/pg_proc_callback.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
/* Notes: 
 *    index pg_proc(oid) <ProcedureOidIndexId> is a prefix of 
 *    	index pg_proc_callback(profnoid, ...) <ProcCallbackProfnoidPromethodIndexId>
 */
static
SysScanDesc
caql_basic_fn_165(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcCallbackRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcCallbackRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_proc_callback_profnoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ProcCallbackProfnoidPromethodIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_proc_callback where profnoid = :1 and promethod = :2  */
/* index: ProcCallbackProfnoidPromethodIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/catalog/pg_proc_callback.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_166(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ProcCallbackRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ProcCallbackRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_proc_callback_profnoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_proc_callback_promethod,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   ProcCallbackProfnoidPromethodIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resourcetype  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_167(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = ResourceTypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResourceTypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resourcetype where resname = :1  */
/* index: ResourceTypeResnameIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_168(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ResourceTypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResourceTypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_resourcetype_resname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ResourceTypeResnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resourcetype where restypid = :1  */
/* index: ResourceTypeRestypidIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_169(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ResourceTypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResourceTypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_resourcetype_restypid,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ResourceTypeRestypidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resqueue  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/resscheduler/resscheduler.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_170(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = ResQueueRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resqueue where oid = :1  */
/* index: ResQueueOidIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/queue.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_171(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ResQueueRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ResQueueOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resqueue where rsqname = :1  */
/* index: ResQueueRsqnameIndexId  */
/* clients: 5		i/u/d: 0/2/0 
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/queue.c: 3
 *   /src/backend/utils/resscheduler/resscheduler.c: 1
 */
/* foreign key tables: *None*
 */
static
SysScanDesc
caql_basic_fn_172(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ResQueueRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_resqueue_rsqname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ResQueueRsqnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_resqueuecapability where resqueueid = :1  */
/* index: ResQueueCapabilityResqueueidIndexId  */
/* clients: 3		i/u/d: 0/1/1 
 *   /src/backend/commands/queue.c: 3
 */
/* foreign key tables: 
 *   pg_resourcetype
 *   pg_resqueue
 */
/* Notes: 
 *    index pg_resqueue(oid) <ResQueueOidIndexId> is a prefix of 
 *    	index pg_resqueuecapability(resqueueid, ...) <ResQueueCapabilityResqueueidIndexId>
 */
static
SysScanDesc
caql_basic_fn_173(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = ResQueueCapabilityRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(ResQueueCapabilityRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_resqueuecapability_resqueueid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   ResQueueCapabilityResqueueidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_rewrite where ev_class = :1  */
/* index: RewriteRelRulenameIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/cache/relcache.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_174(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RewriteRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RewriteRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_rewrite_ev_class,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   RewriteRelRulenameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_rewrite where ev_class = :1 and rulename = :2  */
/* index: RewriteRelRulenameIndexId  */
/* syscacheid: RULERELNAME  */
/* clients: 4		i/u/d: 0/3/0 
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/rewrite/rewriteDefine.c: 2
 *   /src/backend/rewrite/rewriteRemove.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_175(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = RULERELNAME;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RewriteRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RewriteRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_rewrite_ev_class,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_rewrite_rulename,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   RewriteRelRulenameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_rewrite where oid = :1  */
/* index: RewriteOidIndexId  */
/* clients: 2		i/u/d: 0/1/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/rewrite/rewriteRemove.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_176(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = RewriteRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RewriteRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   RewriteOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_rewrite where rulename = :1  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/comment.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 */
static
SysScanDesc
caql_basic_fn_177(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = RewriteRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(RewriteRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_rewrite_rulename,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_shdepend where dbid = :1  */
/* index: SharedDependDependerIndexId  */
/* clients: 2		i/u/d: 0/1/1 
 *   /src/backend/catalog/pg_shdepend.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_database
 */
/* Notes: 
 *    index pg_database(oid) <DatabaseOidIndexId> is a prefix of 
 *    	index pg_shdepend(dbid, ...) <SharedDependDependerIndexId>
 */
static
SysScanDesc
caql_basic_fn_178(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = SharedDependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_shdepend_dbid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   SharedDependDependerIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_shdepend where dbid = :1 and classid = :2 and objid = :3  */
/* index: SharedDependDependerIndexId  */
/* clients: 3		i/u/d: 0/3/0 
 *   /src/backend/catalog/pg_shdepend.c: 3
 */
/* foreign key tables: 
 *   pg_class
 *   pg_database
 */
/* Notes: 
 *    index pg_database(oid) <DatabaseOidIndexId> is a prefix of 
 *    	index pg_shdepend(dbid, ...) <SharedDependDependerIndexId>
 */
static
SysScanDesc
caql_basic_fn_179(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = SharedDependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_shdepend_dbid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_shdepend_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_shdepend_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   SharedDependDependerIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_shdepend where refclassid = :1 and refobjid = :2  */
/* index: SharedDependReferenceIndexId  */
/* clients: 4		i/u/d: 0/1/0 
 *   /src/backend/catalog/pg_shdepend.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_database
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_shdepend(refclassid, ...) <SharedDependReferenceIndexId>
 */
static
SysScanDesc
caql_basic_fn_180(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = SharedDependRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDependRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_shdepend_refclassid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_shdepend_refobjid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   SharedDependReferenceIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_shdescription where objoid = :1 and classoid = :2  */
/* index: SharedDescriptionObjIndexId  */
/* clients: 2		i/u/d: 0/1/1 
 *   /src/backend/commands/comment.c: 2
 */
/* foreign key tables: 
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_181(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = SharedDescriptionRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(SharedDescriptionRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_shdescription_objoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_shdescription_classoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   SharedDescriptionObjIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_stat_last_operation where classid = :1 and objid = :2  */
/* index: StatLastOpClassidObjidIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_182(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatLastOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statlastop_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_statlastop_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   StatLastOpClassidObjidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_stat_last_operation where classid = :1 and objid = :2 and staactionname = :3  */
/* index: StatLastOpClassidObjidStaactionnameIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_183(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatLastOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statlastop_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_statlastop_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_statlastop_staactionname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   StatLastOpClassidObjidStaactionnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_stat_last_shoperation where classid = :1 and objid = :2  */
/* index: StatLastShOpClassidObjidIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_184(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatLastShOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastShOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statlastshop_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_statlastshop_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   StatLastShOpClassidObjidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_stat_last_shoperation where classid = :1 and objid = :2 and staactionname = :3  */
/* index: StatLastShOpClassidObjidStaactionnameIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 */
static
SysScanDesc
caql_basic_fn_185(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatLastShOpRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatLastShOpRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statlastshop_classid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_statlastshop_objid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[2],
				Anum_pg_statlastshop_staactionname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[2]));

	scan = systable_beginscan(rel,
				   StatLastShOpClassidObjidStaactionnameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_statistic where starelid = :1  */
/* index: StatisticRelidAttnumIndexId  */
/* clients: 1		i/u/d: 0/0/1 
 *   /src/backend/catalog/heap.c: 1
 */
/* foreign key tables: 
 *   pg_attribute
 *   pg_operator
 */
static
SysScanDesc
caql_basic_fn_186(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatisticRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatisticRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statistic_starelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   StatisticRelidAttnumIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_statistic where starelid = :1 and staattnum = :2  */
/* index: StatisticRelidAttnumIndexId  */
/* syscacheid: STATRELATT  */
/* clients: 8		i/u/d: 0/1/1 
 *   /src/backend/catalog/heap.c: 1
 *   /src/backend/commands/analyze.c: 1
 *   /src/backend/utils/adt/selfuncs.c: 4
 *   /src/backend/utils/cache/lsyscache.c: 2
 */
/* foreign key tables: 
 *   pg_attribute
 *   pg_operator
 */
static
SysScanDesc
caql_basic_fn_187(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = STATRELATT;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = StatisticRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(StatisticRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_statistic_starelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_statistic_staattnum,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   StatisticRelidAttnumIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_tablespace  */
/* index: *None*  */
/* clients: 2		i/u/d: 0/0/0 
 *   /src/backend/commands/dbcommands.c: 1
 *   /src/backend/utils/gp/segadmin.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_188(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = TableSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TableSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_tablespace where oid = :1  */
/* index: TablespaceOidIndexId  */
/* clients: 4		i/u/d: 0/1/0 
 *   /src/backend/catalog/aclchk.c: 3
 *   /src/backend/commands/tablespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_189(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TableSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TableSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TablespaceOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_tablespace where spcfsoid = :1  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/filespace.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_190(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = TableSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TableSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_tablespace_spcfsoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_tablespace where spcname = :1  */
/* index: TablespaceNameIndexId  */
/* clients: 6		i/u/d: 0/3/0 
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/commands/tablespace.c: 5
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_filespace
 */
static
SysScanDesc
caql_basic_fn_191(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TableSpaceRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TableSpaceRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_tablespace_spcname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TablespaceNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where oid = :1  */
/* index: TriggerOidIndexId  */
/* clients: 9		i/u/d: 0/1/0 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/commands/trigger.c: 1
 *   /src/backend/utils/adt/ruleutils.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 6
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_192(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TriggerOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where tgconstrname = :1  */
/* index: TriggerConstrNameIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/trigger.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_193(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_trigger_tgconstrname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TriggerConstrNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where tgconstrrelid = :1  */
/* index: TriggerConstrRelidIndexId  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_trigger(tgconstrrelid, ...) <TriggerConstrRelidIndexId>
 */
static
SysScanDesc
caql_basic_fn_194(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_trigger_tgconstrrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TriggerConstrRelidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where tgrelid = :1  */
/* index: TriggerRelidNameIndexId  */
/* clients: 3		i/u/d: 0/2/0 
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/commands/trigger.c: 2
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_trigger(tgrelid, ...) <TriggerRelidNameIndexId>
 */
static
SysScanDesc
caql_basic_fn_195(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_trigger_tgrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TriggerRelidNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where tgrelid = :1 ORDER_BY TriggerRelidNameIndexId  */
/* index: TriggerRelidNameIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/commands/trigger.c: 1
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
/* Notes: 
 *    index pg_class(oid) <ClassOidIndexId> is a prefix of 
 *    	index pg_trigger(tgrelid, ...) <TriggerRelidNameIndexId>
 */
static
SysScanDesc
caql_basic_fn_196(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_trigger_tgrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TriggerRelidNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_trigger where tgrelid = :1 and tgname = :2  */
/* index: TriggerRelidNameIndexId  */
/* clients: 5		i/u/d: 0/2/0 
 *   /src/backend/commands/comment.c: 1
 *   /src/backend/commands/trigger.c: 4
 */
/* foreign key tables: 
 *   pg_class
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_197(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TriggerRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TriggerRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_trigger_tgrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_trigger_tgname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   TriggerRelidNameIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_type where oid = :1  */
/* index: TypeOidIndexId  */
/* syscacheid: TYPEOID  */
/* clients: 52		i/u/d: 0/8/1 
 *   /src/backend/access/common/tupdesc.c: 1
 *   /src/backend/catalog/aclchk.c: 1
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/catalog/index.c: 2
 *   /src/backend/catalog/namespace.c: 3
 *   /src/backend/catalog/pg_type.c: 1
 *   /src/backend/cdb/cdbparquetstoragewrite.c: 1
 *   /src/backend/cdb/cdbquerycontextdispatching.c: 1
 *   /src/backend/cdb/motion/tupser.c: 1
 *   /src/backend/commands/tablecmds.c: 1
 *   /src/backend/commands/typecmds.c: 11
 *   /src/backend/executor/spi.c: 1
 *   /src/backend/parser/parse_node.c: 1
 *   /src/backend/parser/parse_type.c: 1
 *   /src/backend/utils/adt/format_type.c: 2
 *   /src/backend/utils/adt/regproc.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 21
 *   /src/backend/utils/cache/typcache.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_198(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = TYPEOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TypeRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TypeOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_type where typlen = :1 and typalign = :2  */
/* index: *None*  */
/* clients: 1		i/u/d: 0/1/0 
 *   /src/backend/commands/tablecmds.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_199(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */

	pCtx->cq_relationId = TypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_type_typlen,
				BTEqualStrategyNumber, F_INT2EQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_type_typalign,
				BTEqualStrategyNumber, F_CHAREQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   InvalidOid,
				   false,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_type where typname = :1  */
/* index: TypeNameNspIndexId  */
/* clients: 1		i/u/d: 0/0/0 
 *   /src/backend/utils/adt/regproc.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_200(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TypeRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_type_typname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TypeNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_type where typname = :1 and typnamespace = :2  */
/* index: TypeNameNspIndexId  */
/* syscacheid: TYPENAMENSP  */
/* clients: 8		i/u/d: 0/1/0 
 *   /src/backend/catalog/namespace.c: 2
 *   /src/backend/catalog/pg_type.c: 2
 *   /src/backend/commands/typecmds.c: 2
 *   /src/backend/parser/parse_type.c: 1
 *   /src/backend/utils/cache/lsyscache.c: 1
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_class
 *   pg_namespace
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_201(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = TYPENAMENSP;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TypeRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_type_typname,
				BTEqualStrategyNumber, F_NAMEEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_type_typnamespace,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   TypeNameNspIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_type_encoding where typid = :1  */
/* index: TypeEncodingTypidIndexId  */
/* clients: 3		i/u/d: 0/1/1 
 *   /src/backend/commands/typecmds.c: 2
 *   /src/backend/parser/analyze.c: 1
 */
/* foreign key tables: 
 *   pg_type
 */
static
SysScanDesc
caql_basic_fn_202(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	Assert (!pCtx->cq_usesyscache);
	pCtx->cq_usesyscache = false; /* complain in debug, work in production */
	
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = TypeEncodingRelationId;

	if (!pCtx->cq_externrel)
	{
		
		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(TypeEncodingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_type_encoding_typid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   TypeEncodingTypidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_user_mapping where oid = :1  */
/* index: UserMappingOidIndexId  */
/* syscacheid: USERMAPPINGOID  */
/* clients: 3		i/u/d: 0/1/1 
 *   /src/backend/catalog/dependency.c: 1
 *   /src/backend/commands/foreigncmds.c: 2
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_server
 */
static
SysScanDesc
caql_basic_fn_203(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = USERMAPPINGOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = UserMappingRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(UserMappingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				ObjectIdAttributeNumber,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   UserMappingOidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_user_mapping where umuser = :1 and umserver = :2  */
/* index: UserMappingUserServerIndexId  */
/* syscacheid: USERMAPPINGUSERSERVER  */
/* clients: 3		i/u/d: 0/0/0 
 *   /src/backend/commands/foreigncmds.c: 3
 */
/* foreign key tables: 
 *   pg_authid
 *   pg_foreign_server
 */
static
SysScanDesc
caql_basic_fn_204(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = USERMAPPINGUSERSERVER;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = UserMappingRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(UserMappingRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_user_mapping_umuser,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));
	
	ScanKeyInit(&pCtx->cq_scanKeys[1],
				Anum_pg_user_mapping_umserver,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[1]));

	scan = systable_beginscan(rel,
				   UserMappingUserServerIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);


	return (scan);
}

/* base query: select * from pg_window where winfnoid = :1  */
/* index: WindowWinfnoidIndexId  */
/* syscacheid: WINFNOID  */
/* clients: 4		i/u/d: 0/0/0 
 *   /src/backend/executor/nodeWindow.c: 1
 *   /src/backend/optimizer/plan/planwindow.c: 1
 *   /src/backend/parser/parse_clause.c: 1
 *   /src/backend/parser/parse_func.c: 1
 */
/* foreign key tables: 
 *   pg_proc
 */
static
SysScanDesc
caql_basic_fn_205(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)
{
	SysScanDesc  scan;
	
	Relation	rel;


	/* always use the syscache unless the caller states otherwise */
	if (!pCtx->cq_setsyscache)
	{
		pCtx->cq_usesyscache = true;
	
		/* Normally, must match all columns of the index to use syscache,
		 * except for case of SearchSysCacheList 
		 */
		if (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))
			pCtx->cq_usesyscache = false;
	
		/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */
		if (pCtx->cq_snapshot != SnapshotNow)
		{
			/* Complain in debug, but behave in production */
			Assert(!pCtx->cq_usesyscache);
	
			pCtx->cq_setsyscache = true;
			pCtx->cq_usesyscache = false;
		}
	}
	
	if (pCtx->cq_usesyscache)
	{
		pCtx->cq_cacheId      = WINFNOID;
	
		/* number of keys must match (unless a SearchSysCacheList ) */
		Assert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));
	}
	
	/* else perform heap/index scan */
	/* always use the index (if possible) unless the caller states otherwise */
	if (!pCtx->cq_setidxOK)
		pCtx->cq_useidxOK = true;

	pCtx->cq_relationId = WindowRelationId;

	if (!pCtx->cq_externrel)
	{
		/* XXX XXX : NOTE: disable heap_open/lock for syscache 
			only if : no external lock mode or external relation
		*/
		if ((!pCtx->cq_setlockmode) &&
			pCtx->cq_usesyscache &&
			(AccessShareLock == pCtx->cq_lockmode))
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
			/* 
				pCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;
			*/
		
			return NULL; /* XXX XXX: return early - don't open heap */
		}
		else

		{
			pCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, 
										  pCtx->cq_lockmode);
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}
	}
	else
	{
		/* make sure the supplied relation matches the caql */
		if (RelationIsValid(pCtx->cq_heap_rel))
		{
			Assert(WindowRelationId == 
				   RelationGetRelid(pCtx->cq_heap_rel));
			pCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);
		}

	}		

	rel = pCtx->cq_heap_rel;

	if (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */

	ScanKeyInit(&pCtx->cq_scanKeys[0],
				Anum_pg_window_winfnoid,
				BTEqualStrategyNumber, F_OIDEQ,
				(pCtx->cq_datumKeys[0]));

	scan = systable_beginscan(rel,
				   WindowWinfnoidIndexId,
				   pCtx->cq_useidxOK,
				   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);


	return (scan);
}


/* ----------------------------------------------------------------
 * caql_switch()
 * Given a cookie, dispatch to the appropriate "base query" function to
 * construct the scan, and return a cqContext
 * NOTE: the caql_switch frees the cql after it sets up the pCtx
 * ----------------------------------------------------------------
 */

static
cqContext *caql_switch(struct caql_hash_cookie *pchn, 
					   cqContext *pCtx,
					   cq_list *pcql)

{

	Assert(pCtx); /* must have a valid context */

	/* set the snapshot and lockmodes */
	if (!pCtx->cq_setsnapshot)
		pCtx->cq_snapshot = SnapshotNow;

	if (!pCtx->cq_setlockmode)
	{
		if (pchn->bDelete || pchn->bUpdate || pchn->bInsert)
			pCtx->cq_lockmode = RowExclusiveLock;
		else
			pCtx->cq_lockmode = AccessShareLock;
	}

	/* XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX */
	if (1) /* implicit locking everywhere */
	{
		pCtx->cq_setpklock = 1;
		pCtx->cq_pklock_excl = 
			(pchn->bDelete || pchn->bUpdate || pchn->bInsert);
	}
	/* XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX */

	/* pcql must be valid */
	Assert(pcql && pcql->bGood);

	/* get everything we need from cql */
	for (int ii = 0; ii < pcql->maxkeys; ii++)
	{
		pCtx->cq_datumKeys[ii] = pcql->cqlKeys[ii];
	}
	pCtx->cq_NumKeys = pcql->maxkeys;
	pCtx->cq_cacheKeys = &pCtx->cq_datumKeys[0];

	pCtx->cq_uniqquery_code = pchn->uniqquery_code;
	pCtx->cq_basequery_code = pchn->basequery_code;

	/* NOTE: pass the cql to basic functions -- optionally 
	 * used for debugging 
	 */
	switch(pchn->basequery_code)
	{
		case 1: /* insert into gp_distribution_policy */
			pCtx->cq_sysScan = caql_basic_fn_1(pCtx, pcql, false);
			break;
		case 2: /* insert into gp_segment_configuration */
			pCtx->cq_sysScan = caql_basic_fn_2(pCtx, pcql, false);
			break;
		case 3: /* insert into pg_aggregate */
			pCtx->cq_sysScan = caql_basic_fn_3(pCtx, pcql, false);
			break;
		case 4: /* insert into pg_amop */
			pCtx->cq_sysScan = caql_basic_fn_4(pCtx, pcql, false);
			break;
		case 5: /* insert into pg_amproc */
			pCtx->cq_sysScan = caql_basic_fn_5(pCtx, pcql, false);
			break;
		case 6: /* insert into pg_appendonly */
			pCtx->cq_sysScan = caql_basic_fn_6(pCtx, pcql, false);
			break;
		case 7: /* insert into pg_attrdef */
			pCtx->cq_sysScan = caql_basic_fn_7(pCtx, pcql, false);
			break;
		case 8: /* insert into pg_attribute */
			pCtx->cq_sysScan = caql_basic_fn_8(pCtx, pcql, false);
			break;
		case 9: /* insert into pg_attribute_encoding */
			pCtx->cq_sysScan = caql_basic_fn_9(pCtx, pcql, false);
			break;
		case 10: /* insert into pg_auth_members */
			pCtx->cq_sysScan = caql_basic_fn_10(pCtx, pcql, false);
			break;
		case 11: /* insert into pg_auth_time_constraint */
			pCtx->cq_sysScan = caql_basic_fn_11(pCtx, pcql, false);
			break;
		case 12: /* insert into pg_authid */
			pCtx->cq_sysScan = caql_basic_fn_12(pCtx, pcql, false);
			break;
		case 13: /* insert into pg_cast */
			pCtx->cq_sysScan = caql_basic_fn_13(pCtx, pcql, false);
			break;
		case 14: /* insert into pg_class */
			pCtx->cq_sysScan = caql_basic_fn_14(pCtx, pcql, false);
			break;
		case 15: /* insert into pg_constraint */
			pCtx->cq_sysScan = caql_basic_fn_15(pCtx, pcql, false);
			break;
		case 16: /* insert into pg_conversion */
			pCtx->cq_sysScan = caql_basic_fn_16(pCtx, pcql, false);
			break;
		case 17: /* insert into pg_database */
			pCtx->cq_sysScan = caql_basic_fn_17(pCtx, pcql, false);
			break;
		case 18: /* insert into pg_depend */
			pCtx->cq_sysScan = caql_basic_fn_18(pCtx, pcql, false);
			break;
		case 19: /* insert into pg_description */
			pCtx->cq_sysScan = caql_basic_fn_19(pCtx, pcql, false);
			break;
		case 20: /* insert into pg_extprotocol */
			pCtx->cq_sysScan = caql_basic_fn_20(pCtx, pcql, false);
			break;
		case 21: /* insert into pg_exttable */
			pCtx->cq_sysScan = caql_basic_fn_21(pCtx, pcql, false);
			break;
		case 22: /* insert into pg_filespace */
			pCtx->cq_sysScan = caql_basic_fn_22(pCtx, pcql, false);
			break;
		case 23: /* insert into pg_filespace_entry */
			pCtx->cq_sysScan = caql_basic_fn_23(pCtx, pcql, false);
			break;
		case 24: /* insert into pg_foreign_data_wrapper */
			pCtx->cq_sysScan = caql_basic_fn_24(pCtx, pcql, false);
			break;
		case 25: /* insert into pg_foreign_server */
			pCtx->cq_sysScan = caql_basic_fn_25(pCtx, pcql, false);
			break;
		case 26: /* insert into pg_foreign_table */
			pCtx->cq_sysScan = caql_basic_fn_26(pCtx, pcql, false);
			break;
		case 27: /* insert into pg_index */
			pCtx->cq_sysScan = caql_basic_fn_27(pCtx, pcql, false);
			break;
		case 28: /* insert into pg_inherits */
			pCtx->cq_sysScan = caql_basic_fn_28(pCtx, pcql, false);
			break;
		case 29: /* insert into pg_language */
			pCtx->cq_sysScan = caql_basic_fn_29(pCtx, pcql, false);
			break;
		case 30: /* insert into pg_namespace */
			pCtx->cq_sysScan = caql_basic_fn_30(pCtx, pcql, false);
			break;
		case 31: /* insert into pg_opclass */
			pCtx->cq_sysScan = caql_basic_fn_31(pCtx, pcql, false);
			break;
		case 32: /* insert into pg_operator */
			pCtx->cq_sysScan = caql_basic_fn_32(pCtx, pcql, false);
			break;
		case 33: /* insert into pg_partition */
			pCtx->cq_sysScan = caql_basic_fn_33(pCtx, pcql, false);
			break;
		case 34: /* insert into pg_partition_encoding */
			pCtx->cq_sysScan = caql_basic_fn_34(pCtx, pcql, false);
			break;
		case 35: /* insert into pg_partition_rule */
			pCtx->cq_sysScan = caql_basic_fn_35(pCtx, pcql, false);
			break;
		case 36: /* insert into pg_proc */
			pCtx->cq_sysScan = caql_basic_fn_36(pCtx, pcql, false);
			break;
		case 37: /* insert into pg_proc_callback */
			pCtx->cq_sysScan = caql_basic_fn_37(pCtx, pcql, false);
			break;
		case 38: /* insert into pg_resqueue */
			pCtx->cq_sysScan = caql_basic_fn_38(pCtx, pcql, false);
			break;
		case 39: /* insert into pg_resqueuecapability */
			pCtx->cq_sysScan = caql_basic_fn_39(pCtx, pcql, false);
			break;
		case 40: /* insert into pg_shdepend */
			pCtx->cq_sysScan = caql_basic_fn_40(pCtx, pcql, false);
			break;
		case 41: /* insert into pg_shdescription */
			pCtx->cq_sysScan = caql_basic_fn_41(pCtx, pcql, false);
			break;
		case 42: /* insert into pg_stat_last_operation */
			pCtx->cq_sysScan = caql_basic_fn_42(pCtx, pcql, false);
			break;
		case 43: /* insert into pg_stat_last_shoperation */
			pCtx->cq_sysScan = caql_basic_fn_43(pCtx, pcql, false);
			break;
		case 44: /* insert into pg_tablespace */
			pCtx->cq_sysScan = caql_basic_fn_44(pCtx, pcql, false);
			break;
		case 45: /* insert into pg_trigger */
			pCtx->cq_sysScan = caql_basic_fn_45(pCtx, pcql, false);
			break;
		case 46: /* insert into pg_type */
			pCtx->cq_sysScan = caql_basic_fn_46(pCtx, pcql, false);
			break;
		case 47: /* insert into pg_type_encoding */
			pCtx->cq_sysScan = caql_basic_fn_47(pCtx, pcql, false);
			break;
		case 48: /* insert into pg_user_mapping */
			pCtx->cq_sysScan = caql_basic_fn_48(pCtx, pcql, false);
			break;
		case 49: /* select * from gp_distribution_policy where localoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_49(pCtx, pcql, false);
			break;
		case 50: /* select * from gp_fastsequence where objid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_50(pCtx, pcql, false);
			break;
		case 51: /* select * from gp_fastsequence where objid = :1 and objmod = :2 */
			pCtx->cq_sysScan = caql_basic_fn_51(pCtx, pcql, false);
			break;
		case 52: /* select * from gp_fastsequence where objid = :1 and objmod = :2 and contentid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_52(pCtx, pcql, false);
			break;
		case 53: /* select * from gp_fault_strategy */
			pCtx->cq_sysScan = caql_basic_fn_53(pCtx, pcql, false);
			break;
		case 54: /* select * from gp_segment_configuration */
			pCtx->cq_sysScan = caql_basic_fn_54(pCtx, pcql, false);
			break;
		case 55: /* select * from gp_segment_configuration where content = :1 and preferred_role = :2 */
			pCtx->cq_sysScan = caql_basic_fn_55(pCtx, pcql, false);
			break;
		case 56: /* select * from gp_segment_configuration where content = :1 and role = :2 */
			pCtx->cq_sysScan = caql_basic_fn_56(pCtx, pcql, false);
			break;
		case 57: /* select * from gp_segment_configuration where dbid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_57(pCtx, pcql, false);
			break;
		case 58: /* select * from pg_aggregate where aggfnoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_58(pCtx, pcql, false);
			break;
		case 59: /* select * from pg_am where amname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_59(pCtx, pcql, false);
			break;
		case 60: /* select * from pg_am where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_60(pCtx, pcql, false);
			break;
		case 61: /* select * from pg_amop where amopclaid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_61(pCtx, pcql, false);
			break;
		case 62: /* select * from pg_amop where amopclaid = :1 and amopsubtype = :2 */
			pCtx->cq_sysScan = caql_basic_fn_62(pCtx, pcql, false);
			break;
		case 63: /* select * from pg_amop where amopclaid = :1 and amopsubtype = :2 and amopstrategy = :3 */
			pCtx->cq_sysScan = caql_basic_fn_63(pCtx, pcql, false);
			break;
		case 64: /* select * from pg_amop where amopopr = :1 ORDER_BY AccessMethodOperatorIndexId */
			pCtx->cq_sysScan = caql_basic_fn_64(pCtx, pcql, false);
			break;
		case 65: /* select * from pg_amop where amopopr = :1 and amopclaid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_65(pCtx, pcql, false);
			break;
		case 66: /* select * from pg_amproc where amopclaid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_66(pCtx, pcql, false);
			break;
		case 67: /* select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2 */
			pCtx->cq_sysScan = caql_basic_fn_67(pCtx, pcql, false);
			break;
		case 68: /* select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2 and amprocnum = :3 */
			pCtx->cq_sysScan = caql_basic_fn_68(pCtx, pcql, false);
			break;
		case 69: /* select * from pg_appendonly where relid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_69(pCtx, pcql, false);
			break;
		case 70: /* select * from pg_attrdef where adrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_70(pCtx, pcql, false);
			break;
		case 71: /* select * from pg_attrdef where adrelid = :1 and adnum = :2 */
			pCtx->cq_sysScan = caql_basic_fn_71(pCtx, pcql, false);
			break;
		case 72: /* select * from pg_attrdef where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_72(pCtx, pcql, false);
			break;
		case 73: /* select * from pg_attribute where attrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_73(pCtx, pcql, false);
			break;
		case 74: /* select * from pg_attribute where attrelid = :1 and attname = :2 */
			pCtx->cq_sysScan = caql_basic_fn_74(pCtx, pcql, false);
			break;
		case 75: /* select * from pg_attribute where attrelid = :1 and attnum = :2 */
			pCtx->cq_sysScan = caql_basic_fn_75(pCtx, pcql, false);
			break;
		case 76: /* select * from pg_attribute where attrelid = :1 and attnum > :2 */
			pCtx->cq_sysScan = caql_basic_fn_76(pCtx, pcql, false);
			break;
		case 77: /* select * from pg_attribute_encoding where attrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_77(pCtx, pcql, false);
			break;
		case 78: /* select * from pg_auth_members where member = :1 */
			pCtx->cq_sysScan = caql_basic_fn_78(pCtx, pcql, false);
			break;
		case 79: /* select * from pg_auth_members where member = :1 ORDER_BY AuthMemMemRoleIndexId */
			pCtx->cq_sysScan = caql_basic_fn_79(pCtx, pcql, false);
			break;
		case 80: /* select * from pg_auth_members where roleid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_80(pCtx, pcql, false);
			break;
		case 81: /* select * from pg_auth_members where roleid = :1 and member = :2 */
			pCtx->cq_sysScan = caql_basic_fn_81(pCtx, pcql, false);
			break;
		case 82: /* select * from pg_auth_time_constraint where authid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_82(pCtx, pcql, false);
			break;
		case 83: /* select * from pg_authid where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_83(pCtx, pcql, false);
			break;
		case 84: /* select * from pg_authid where rolname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_84(pCtx, pcql, false);
			break;
		case 85: /* select * from pg_authid where rolresqueue = :1 */
			pCtx->cq_sysScan = caql_basic_fn_85(pCtx, pcql, false);
			break;
		case 86: /* select * from pg_authid where rolsuper = :1 and rolcanlogin = :2 */
			pCtx->cq_sysScan = caql_basic_fn_86(pCtx, pcql, false);
			break;
		case 87: /* select * from pg_authid where rolsuper = :1 and rolcanlogin = :2 and oid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_87(pCtx, pcql, false);
			break;
		case 88: /* select * from pg_cast where castsource = :1 and casttarget = :2 */
			pCtx->cq_sysScan = caql_basic_fn_88(pCtx, pcql, false);
			break;
		case 89: /* select * from pg_cast where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_89(pCtx, pcql, false);
			break;
		case 90: /* select * from pg_class */
			pCtx->cq_sysScan = caql_basic_fn_90(pCtx, pcql, false);
			break;
		case 91: /* select * from pg_class where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_91(pCtx, pcql, false);
			break;
		case 92: /* select * from pg_class where relkind = :1 */
			pCtx->cq_sysScan = caql_basic_fn_92(pCtx, pcql, false);
			break;
		case 93: /* select * from pg_class where relname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_93(pCtx, pcql, false);
			break;
		case 94: /* select * from pg_class where relname = :1 and relnamespace = :2 */
			pCtx->cq_sysScan = caql_basic_fn_94(pCtx, pcql, false);
			break;
		case 95: /* select * from pg_compression where compname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_95(pCtx, pcql, false);
			break;
		case 96: /* select * from pg_constraint where conname = :1 and connamespace = :2 */
			pCtx->cq_sysScan = caql_basic_fn_96(pCtx, pcql, false);
			break;
		case 97: /* select * from pg_constraint where conrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_97(pCtx, pcql, false);
			break;
		case 98: /* select * from pg_constraint where conrelid = :1 and contype = :2 */
			pCtx->cq_sysScan = caql_basic_fn_98(pCtx, pcql, false);
			break;
		case 99: /* select * from pg_constraint where contypid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_99(pCtx, pcql, false);
			break;
		case 100: /* select * from pg_constraint where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_100(pCtx, pcql, false);
			break;
		case 101: /* select * from pg_conversion where conname = :1 and connamespace = :2 */
			pCtx->cq_sysScan = caql_basic_fn_101(pCtx, pcql, false);
			break;
		case 102: /* select * from pg_conversion where connamespace = :1 and conforencoding = :2 and contoencoding = :3 ORDER_BY ConversionDefaultIndexId */
			pCtx->cq_sysScan = caql_basic_fn_102(pCtx, pcql, false);
			break;
		case 103: /* select * from pg_conversion where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_103(pCtx, pcql, false);
			break;
		case 104: /* select * from pg_database */
			pCtx->cq_sysScan = caql_basic_fn_104(pCtx, pcql, false);
			break;
		case 105: /* select * from pg_database where datname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_105(pCtx, pcql, false);
			break;
		case 106: /* select * from pg_database where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_106(pCtx, pcql, false);
			break;
		case 107: /* select * from pg_depend where classid = :1 and objid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_107(pCtx, pcql, false);
			break;
		case 108: /* select * from pg_depend where classid = :1 and objid = :2 and objsubid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_108(pCtx, pcql, false);
			break;
		case 109: /* select * from pg_depend where refclassid = :1 and refobjid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_109(pCtx, pcql, false);
			break;
		case 110: /* select * from pg_depend where refclassid = :1 and refobjid = :2 and refobjsubid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_110(pCtx, pcql, false);
			break;
		case 111: /* select * from pg_description where objoid = :1 and classoid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_111(pCtx, pcql, false);
			break;
		case 112: /* select * from pg_description where objoid = :1 and classoid = :2 and objsubid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_112(pCtx, pcql, false);
			break;
		case 113: /* select * from pg_extprotocol where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_113(pCtx, pcql, false);
			break;
		case 114: /* select * from pg_extprotocol where ptcname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_114(pCtx, pcql, false);
			break;
		case 115: /* select * from pg_exttable where reloid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_115(pCtx, pcql, false);
			break;
		case 116: /* select * from pg_filespace */
			pCtx->cq_sysScan = caql_basic_fn_116(pCtx, pcql, false);
			break;
		case 117: /* select * from pg_filespace where fsname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_117(pCtx, pcql, false);
			break;
		case 118: /* select * from pg_filespace where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_118(pCtx, pcql, false);
			break;
		case 119: /* select * from pg_filespace_entry */
			pCtx->cq_sysScan = caql_basic_fn_119(pCtx, pcql, false);
			break;
		case 120: /* select * from pg_filespace_entry where fsedbid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_120(pCtx, pcql, false);
			break;
		case 121: /* select * from pg_filespace_entry where fsefsoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_121(pCtx, pcql, false);
			break;
		case 122: /* select * from pg_foreign_data_wrapper where fdwname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_122(pCtx, pcql, false);
			break;
		case 123: /* select * from pg_foreign_data_wrapper where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_123(pCtx, pcql, false);
			break;
		case 124: /* select * from pg_foreign_server where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_124(pCtx, pcql, false);
			break;
		case 125: /* select * from pg_foreign_server where srvname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_125(pCtx, pcql, false);
			break;
		case 126: /* select * from pg_foreign_table where reloid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_126(pCtx, pcql, false);
			break;
		case 127: /* select * from pg_index where indexrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_127(pCtx, pcql, false);
			break;
		case 128: /* select * from pg_index where indisclustered = :1 */
			pCtx->cq_sysScan = caql_basic_fn_128(pCtx, pcql, false);
			break;
		case 129: /* select * from pg_index where indrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_129(pCtx, pcql, false);
			break;
		case 130: /* select * from pg_inherits where inhparent = :1 */
			pCtx->cq_sysScan = caql_basic_fn_130(pCtx, pcql, false);
			break;
		case 131: /* select * from pg_inherits where inhrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_131(pCtx, pcql, false);
			break;
		case 132: /* select * from pg_inherits where inhrelid = :1 and inhseqno = :2 */
			pCtx->cq_sysScan = caql_basic_fn_132(pCtx, pcql, false);
			break;
		case 133: /* select * from pg_language where lanname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_133(pCtx, pcql, false);
			break;
		case 134: /* select * from pg_language where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_134(pCtx, pcql, false);
			break;
		case 135: /* select * from pg_largeobject where loid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_135(pCtx, pcql, false);
			break;
		case 136: /* select * from pg_largeobject where loid = :1 ORDER_BY LargeObjectLoidPagenoIndexId */
			pCtx->cq_sysScan = caql_basic_fn_136(pCtx, pcql, false);
			break;
		case 137: /* select * from pg_largeobject where loid = :1 and pageno >= :2 ORDER_BY LargeObjectLoidPagenoIndexId */
			pCtx->cq_sysScan = caql_basic_fn_137(pCtx, pcql, false);
			break;
		case 138: /* select * from pg_namespace where nspname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_138(pCtx, pcql, false);
			break;
		case 139: /* select * from pg_namespace where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_139(pCtx, pcql, false);
			break;
		case 140: /* select * from pg_opclass where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_140(pCtx, pcql, false);
			break;
		case 141: /* select * from pg_opclass where opcamid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_141(pCtx, pcql, false);
			break;
		case 142: /* select * from pg_opclass where opcamid = :1 and opcname = :2 and opcnamespace = :3 */
			pCtx->cq_sysScan = caql_basic_fn_142(pCtx, pcql, false);
			break;
		case 143: /* select * from pg_operator where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_143(pCtx, pcql, false);
			break;
		case 144: /* select * from pg_operator where oprleft = :1 and oprright = :2 */
			pCtx->cq_sysScan = caql_basic_fn_144(pCtx, pcql, false);
			break;
		case 145: /* select * from pg_operator where oprname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_145(pCtx, pcql, false);
			break;
		case 146: /* select * from pg_operator where oprname = :1 ORDER_BY OperatorNameNspIndexId */
			pCtx->cq_sysScan = caql_basic_fn_146(pCtx, pcql, false);
			break;
		case 147: /* select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 ORDER_BY OperatorNameNspIndexId */
			pCtx->cq_sysScan = caql_basic_fn_147(pCtx, pcql, false);
			break;
		case 148: /* select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 and oprnamespace = :4 */
			pCtx->cq_sysScan = caql_basic_fn_148(pCtx, pcql, false);
			break;
		case 149: /* select * from pg_partition where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_149(pCtx, pcql, false);
			break;
		case 150: /* select * from pg_partition where parrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_150(pCtx, pcql, false);
			break;
		case 151: /* select * from pg_partition where parrelid = :1 and parlevel = :2 and paristemplate = :3 */
			pCtx->cq_sysScan = caql_basic_fn_151(pCtx, pcql, false);
			break;
		case 152: /* select * from pg_partition_encoding where parencoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_152(pCtx, pcql, false);
			break;
		case 153: /* select * from pg_partition_rule where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_153(pCtx, pcql, false);
			break;
		case 154: /* select * from pg_partition_rule where parchildrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_154(pCtx, pcql, false);
			break;
		case 155: /* select * from pg_partition_rule where paroid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_155(pCtx, pcql, false);
			break;
		case 156: /* select * from pg_partition_rule where paroid = :1 and parparentrule = :2 */
			pCtx->cq_sysScan = caql_basic_fn_156(pCtx, pcql, false);
			break;
		case 157: /* select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parname = :3 */
			pCtx->cq_sysScan = caql_basic_fn_157(pCtx, pcql, false);
			break;
		case 158: /* select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord <= :3 ORDER_BY PartitionRuleParoidParparentruleParruleordIndexId */
			pCtx->cq_sysScan = caql_basic_fn_158(pCtx, pcql, false);
			break;
		case 159: /* select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord = :3 */
			pCtx->cq_sysScan = caql_basic_fn_159(pCtx, pcql, false);
			break;
		case 160: /* select * from pg_pltemplate where tmplname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_160(pCtx, pcql, false);
			break;
		case 161: /* select * from pg_proc where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_161(pCtx, pcql, false);
			break;
		case 162: /* select * from pg_proc where proname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_162(pCtx, pcql, false);
			break;
		case 163: /* select * from pg_proc where proname = :1 ORDER_BY ProcedureNameArgsNspIndexId */
			pCtx->cq_sysScan = caql_basic_fn_163(pCtx, pcql, false);
			break;
		case 164: /* select * from pg_proc where proname = :1 and proargtypes = :2 and pronamespace = :3 */
			pCtx->cq_sysScan = caql_basic_fn_164(pCtx, pcql, false);
			break;
		case 165: /* select * from pg_proc_callback where profnoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_165(pCtx, pcql, false);
			break;
		case 166: /* select * from pg_proc_callback where profnoid = :1 and promethod = :2 */
			pCtx->cq_sysScan = caql_basic_fn_166(pCtx, pcql, false);
			break;
		case 167: /* select * from pg_resourcetype */
			pCtx->cq_sysScan = caql_basic_fn_167(pCtx, pcql, false);
			break;
		case 168: /* select * from pg_resourcetype where resname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_168(pCtx, pcql, false);
			break;
		case 169: /* select * from pg_resourcetype where restypid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_169(pCtx, pcql, false);
			break;
		case 170: /* select * from pg_resqueue */
			pCtx->cq_sysScan = caql_basic_fn_170(pCtx, pcql, false);
			break;
		case 171: /* select * from pg_resqueue where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_171(pCtx, pcql, false);
			break;
		case 172: /* select * from pg_resqueue where rsqname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_172(pCtx, pcql, false);
			break;
		case 173: /* select * from pg_resqueuecapability where resqueueid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_173(pCtx, pcql, false);
			break;
		case 174: /* select * from pg_rewrite where ev_class = :1 */
			pCtx->cq_sysScan = caql_basic_fn_174(pCtx, pcql, false);
			break;
		case 175: /* select * from pg_rewrite where ev_class = :1 and rulename = :2 */
			pCtx->cq_sysScan = caql_basic_fn_175(pCtx, pcql, false);
			break;
		case 176: /* select * from pg_rewrite where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_176(pCtx, pcql, false);
			break;
		case 177: /* select * from pg_rewrite where rulename = :1 */
			pCtx->cq_sysScan = caql_basic_fn_177(pCtx, pcql, false);
			break;
		case 178: /* select * from pg_shdepend where dbid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_178(pCtx, pcql, false);
			break;
		case 179: /* select * from pg_shdepend where dbid = :1 and classid = :2 and objid = :3 */
			pCtx->cq_sysScan = caql_basic_fn_179(pCtx, pcql, false);
			break;
		case 180: /* select * from pg_shdepend where refclassid = :1 and refobjid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_180(pCtx, pcql, false);
			break;
		case 181: /* select * from pg_shdescription where objoid = :1 and classoid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_181(pCtx, pcql, false);
			break;
		case 182: /* select * from pg_stat_last_operation where classid = :1 and objid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_182(pCtx, pcql, false);
			break;
		case 183: /* select * from pg_stat_last_operation where classid = :1 and objid = :2 and staactionname = :3 */
			pCtx->cq_sysScan = caql_basic_fn_183(pCtx, pcql, false);
			break;
		case 184: /* select * from pg_stat_last_shoperation where classid = :1 and objid = :2 */
			pCtx->cq_sysScan = caql_basic_fn_184(pCtx, pcql, false);
			break;
		case 185: /* select * from pg_stat_last_shoperation where classid = :1 and objid = :2 and staactionname = :3 */
			pCtx->cq_sysScan = caql_basic_fn_185(pCtx, pcql, false);
			break;
		case 186: /* select * from pg_statistic where starelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_186(pCtx, pcql, false);
			break;
		case 187: /* select * from pg_statistic where starelid = :1 and staattnum = :2 */
			pCtx->cq_sysScan = caql_basic_fn_187(pCtx, pcql, false);
			break;
		case 188: /* select * from pg_tablespace */
			pCtx->cq_sysScan = caql_basic_fn_188(pCtx, pcql, false);
			break;
		case 189: /* select * from pg_tablespace where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_189(pCtx, pcql, false);
			break;
		case 190: /* select * from pg_tablespace where spcfsoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_190(pCtx, pcql, false);
			break;
		case 191: /* select * from pg_tablespace where spcname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_191(pCtx, pcql, false);
			break;
		case 192: /* select * from pg_trigger where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_192(pCtx, pcql, false);
			break;
		case 193: /* select * from pg_trigger where tgconstrname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_193(pCtx, pcql, false);
			break;
		case 194: /* select * from pg_trigger where tgconstrrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_194(pCtx, pcql, false);
			break;
		case 195: /* select * from pg_trigger where tgrelid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_195(pCtx, pcql, false);
			break;
		case 196: /* select * from pg_trigger where tgrelid = :1 ORDER_BY TriggerRelidNameIndexId */
			pCtx->cq_sysScan = caql_basic_fn_196(pCtx, pcql, false);
			break;
		case 197: /* select * from pg_trigger where tgrelid = :1 and tgname = :2 */
			pCtx->cq_sysScan = caql_basic_fn_197(pCtx, pcql, false);
			break;
		case 198: /* select * from pg_type where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_198(pCtx, pcql, false);
			break;
		case 199: /* select * from pg_type where typlen = :1 and typalign = :2 */
			pCtx->cq_sysScan = caql_basic_fn_199(pCtx, pcql, false);
			break;
		case 200: /* select * from pg_type where typname = :1 */
			pCtx->cq_sysScan = caql_basic_fn_200(pCtx, pcql, false);
			break;
		case 201: /* select * from pg_type where typname = :1 and typnamespace = :2 */
			pCtx->cq_sysScan = caql_basic_fn_201(pCtx, pcql, false);
			break;
		case 202: /* select * from pg_type_encoding where typid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_202(pCtx, pcql, false);
			break;
		case 203: /* select * from pg_user_mapping where oid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_203(pCtx, pcql, false);
			break;
		case 204: /* select * from pg_user_mapping where umuser = :1 and umserver = :2 */
			pCtx->cq_sysScan = caql_basic_fn_204(pCtx, pcql, false);
			break;
		case 205: /* select * from pg_window where winfnoid = :1 */
			pCtx->cq_sysScan = caql_basic_fn_205(pCtx, pcql, false);
			break;

	  default:
		break;
		/* bad */
	}

	/* NOTE: free up the cql before we return */
	pcql->bGood = false;
	pfree(pcql);

	return (pCtx);
} /* end caql_switch */
#endif /* NOT_USED */


/* NOTE: caql_iud_switch locking removed */
#define caql_iud_switch(pctx, isiud, oldtup, newtup, dontWait) 



static bool
is_builtin_object(cqContext *pCtx, HeapTuple tuple)
{
	Oid result = InvalidOid;

	if (!HeapTupleIsValid(tuple))
		return true;

	if (tuple->t_data->t_infomask & HEAP_HASOID)
		result = HeapTupleGetOid(tuple);
	else
	{
		switch(pCtx->cq_relationId)
		{
			case GpPolicyRelationId:
				result = (Oid) ((FormData_gp_policy *) GETSTRUCT(tuple))->localoid;
				break;
			case FastSequenceRelationId:
				result = (Oid) ((Form_gp_fastsequence) GETSTRUCT(tuple))->objid;
				break;
			case AggregateRelationId:
				result = (Oid) ((Form_pg_aggregate) GETSTRUCT(tuple))->aggfnoid;
				break;
			case AccessMethodOperatorRelationId:
				result = (Oid) ((Form_pg_amop) GETSTRUCT(tuple))->amopclaid;
				break;
			case AccessMethodProcedureRelationId:
				result = (Oid) ((Form_pg_amproc) GETSTRUCT(tuple))->amopclaid;
				break;
			case AppendOnlyRelationId:
				result = (Oid) ((Form_pg_appendonly) GETSTRUCT(tuple))->relid;
				break;
			case AttrDefaultRelationId:
				result = (Oid) ((Form_pg_attrdef) GETSTRUCT(tuple))->adrelid;
				break;
			case AttributeRelationId:
				result = (Oid) ((Form_pg_attribute) GETSTRUCT(tuple))->attrelid;
				break;
			case AttributeEncodingRelationId:
				result = (Oid) ((Form_pg_attribute_encoding) GETSTRUCT(tuple))->attrelid;
				break;
			case AuthMemRelationId:
				result = (Oid) ((Form_pg_auth_members) GETSTRUCT(tuple))->roleid;
				break;
			case AuthTimeConstraintRelationId:
				result = (Oid) ((Form_pg_auth_time_constraint) GETSTRUCT(tuple))->authid;
				break;
			case DependRelationId:
				result = (Oid) ((Form_pg_depend) GETSTRUCT(tuple))->objid;
				break;
			case DescriptionRelationId:
				result = (Oid) ((Form_pg_description) GETSTRUCT(tuple))->objoid;
				break;
			case ExtTableRelationId:
				result = (Oid) ((Form_pg_exttable) GETSTRUCT(tuple))->reloid;
				break;
			case FileSpaceEntryRelationId:
				result = (Oid) ((Form_pg_filespace_entry) GETSTRUCT(tuple))->fsefsoid;
				break;
			case IndexRelationId:
				result = (Oid) ((Form_pg_index) GETSTRUCT(tuple))->indexrelid;
				break;
			case InheritsRelationId:
				result = (Oid) ((Form_pg_inherits) GETSTRUCT(tuple))->inhrelid;
				break;
			case PartitionEncodingRelationId:
				result = (Oid) ((Form_pg_partition_encoding) GETSTRUCT(tuple))->parencoid;
				break;
			case PLTemplateRelationId:
				{
					char *name_str = pstrdup(NameStr(((Form_pg_pltemplate) GETSTRUCT(tuple))->tmplname));
					if ((strcmp(name_str, "plpgsql") != 0) ||
						(strcmp(name_str, "c") != 0) ||
						(strcmp(name_str, "sql") != 0) ||
						(strcmp(name_str, "internal") != 0))
						result = InvalidOid;
					break;
				}
			case TriggerRelationId:
				result = (Oid) ((Form_pg_trigger) GETSTRUCT(tuple))->tgrelid;
				break;
			case RewriteRelationId:
				result = (Oid) ((Form_pg_rewrite) GETSTRUCT(tuple))->ev_class;
				break;
			case ProcCallbackRelationId:
				result = (Oid) ((Form_pg_proc_callback) GETSTRUCT(tuple))->profnoid;
				break;
			case SharedDependRelationId:
				result = (Oid) ((Form_pg_shdepend) GETSTRUCT(tuple))->objid;
				break;
			case SharedDescriptionRelationId:
				result = (Oid) ((Form_pg_shdescription) GETSTRUCT(tuple))->objoid;
				break;
			case StatLastOpRelationId:
				result = (Oid) ((Form_pg_statlastop) GETSTRUCT(tuple))->objid;
				break;
			case StatLastShOpRelationId:
				result = (Oid) ((Form_pg_statlastshop) GETSTRUCT(tuple))->objid;
				break;
			case StatisticRelationId:
				result = (Oid) ((Form_pg_statistic) GETSTRUCT(tuple))->starelid;
				break;
			case TypeEncodingRelationId:
				result = (Oid) ((Form_pg_type_encoding) GETSTRUCT(tuple))->typid;
				break;
			case WindowRelationId:
				result = (Oid) ((Form_pg_window) GETSTRUCT(tuple))->winfnoid;
				break;

			default:
				return false;
		}
	}
	if (result > FirstNormalObjectId)
		return false;

	return true;
}

/*
 * Error out when 
 *	- the guc is enable 
 *	- and users try to access catalog on segments
 */
static void
disable_catalog_check(cqContext *pCtx, HeapTuple tuple)
{
	if (Gp_role != GP_ROLE_DISPATCH && !AmIMaster()
		&& gp_disable_catalog_access_on_segment)
	{
		if (!is_builtin_object(pCtx, tuple))
			elog(ERROR, "invalid catalog access on segments (catalog relid: %d)",
					pCtx->cq_relationId);
	}
}

/*
 * Error out when 
 *	- the guc is enable 
 *	- and users try to access catalog - pg_attribute on segments
 */
static void
disable_attribute_check(Oid attrelid)
{
	if (Gp_role != GP_ROLE_DISPATCH && !AmIMaster()
		&& gp_disable_catalog_access_on_segment)
	{
		if (attrelid > FirstNormalObjectId)
			elog(ERROR, "invalid pg_attribute access on segments");
	}
}


/* ----------------------------------------------------------------
 * cqclr
 * 
 * ----------------------------------------------------------------
 */

cqContext	*cqclr(cqContext	 *pCtx)
{
	cqClearContext(pCtx);
	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_addrel()
 * 
 * Add an existing relation as the heap_rel, and use its lockmode, 
 * and skip heap_open/heap_close
 * ----------------------------------------------------------------
 */

cqContext	*caql_addrel(cqContext *pCtx, Relation rel)
{
	if (RelationIsValid(rel))
	{
		Assert(!RelationIsValid(pCtx->cq_heap_rel));
		pCtx->cq_heap_rel  = rel;
		pCtx->cq_externrel = true;
	}
	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_indexOK()
 * 
 * if false, force a heapscan
 * ----------------------------------------------------------------
 */

cqContext	*caql_indexOK(cqContext *pCtx, bool bindexOK)
{
	pCtx->cq_setidxOK  = true;
	pCtx->cq_useidxOK  = bindexOK;

	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_lockmode()
 * 
 * Change the default lockmode (ie RowExclusiveLock for Delete/Update, 
 * else AccessShareLock) associated with the underlying relation.   
 * Has no effect if the relation is external.
 * ----------------------------------------------------------------
 */

cqContext	*caql_lockmode(cqContext *pCtx, LOCKMODE lm)
{
	pCtx->cq_setlockmode = true;
	pCtx->cq_lockmode	 = lm;
	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_PKLOCK()
 * 
 * Lock the primary key(s) for all fetched tuples of the underlying
 * relation.  If bExclusive is true, gets an exclusive lock.
 * If bExclusive is true, gets an exclusive lock on the primary key(s),
 * and share locks (nowait) on any foreign keys.
 * If bExclusive is false, gets a share lock on the primary key(s) only.
 * 
 * NOTE: Waits for all primary key locks.    
 * ----------------------------------------------------------------
 */

cqContext	*caql_PKLOCK(cqContext *pCtx, bool bExclusive)
{
	pCtx->cq_setpklock	 = true;
	pCtx->cq_pklock_excl = bExclusive;
	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_snapshot()
 * 
 * Change the default snapshot (SnapshotNow) associated with the 
 * heap/index scan.
 * ----------------------------------------------------------------
 */

cqContext	*caql_snapshot(cqContext *pCtx, Snapshot ss)
{
	pCtx->cq_setsnapshot = true;
	pCtx->cq_snapshot	 = ss;
	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_syscache()
 * 
 * Override the default choice of syscache vs heap/index scan.
 * Note: will Assert if asked to choose cache for non-cached index.
 * ----------------------------------------------------------------
 */

cqContext	*caql_syscache(cqContext *pCtx, bool bUseCache)
{
	pCtx->cq_setsyscache = true;
	pCtx->cq_usesyscache = bUseCache;
	return (pCtx);
}

/* ----------------------------------------------------------------
 * cql1()
 * The underlying function for the cql() macro.
 * find the bind parameters in a caql string and build a key list
 * ----------------------------------------------------------------
 */
cq_list *cql1(const char* caqlStr, const char* filename, int lineno, ...)
{
	int			 maxkeys = 0;
	int			 badbind = 0;
	cq_list		*pcql	 = (cq_list *) palloc0(sizeof(cq_list));
	const char*	 pc		 = caqlStr;

	if ((NULL == caqlStr) ||
		(0 == strlen(caqlStr)))
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(
					 "Invalid or undefined CaQL string"
				 ),
				 errOmitLocation(true)));

	pcql->bGood	   = true;
	pcql->caqlStr  = caqlStr;
	pcql->filename = filename;
	pcql->lineno   = lineno;

	while (*pc && (maxkeys < 5))
	{
		if (*pc != ':')
		{
			pc++;
			continue;
		}

		/* look for numeric bind parameter of the form ":1" to ":5" */
		pc++;

		if (!*pc)
			break;

		switch (*pc)
		{
			case '1':
				if (maxkeys != 0)
				{
					badbind = 1;
					goto L_wrong_args;
				}
				maxkeys++;
				break;
			case '2':
				if (maxkeys != 1)
				{
					badbind = 2;
					goto L_wrong_args;
				}
				maxkeys++;
				break;
			case '3':
				if (maxkeys != 2)
				{
					badbind = 3;
					goto L_wrong_args;
				}
				maxkeys++;
				break;
			case '4':
				if (maxkeys != 3)
				{
					badbind = 4;
					goto L_wrong_args;
				}
				maxkeys++;
				break;
			case '5':
				if (maxkeys != 4)
				{
					badbind = 5;
					goto L_wrong_args;
				}
				maxkeys++;
				break;
			case '6':
			case '7':
			case '8':
			case '9':
			case '0':
			{
				badbind = 6;
				goto L_wrong_args;
			}
			default:
				break;
		} /* end switch */
	} /* end while */

	pcql->maxkeys   = maxkeys;
	
	if (maxkeys)
	{
		va_list		ap;

		va_start(ap, lineno);

		for (int ii = 0; ii < maxkeys; ii++)
		{
			pcql->cqlKeys[ii] = va_arg(ap, Datum);
		}
		va_end(ap);
	}
	return (pcql);

  L_wrong_args:
	if (badbind != 5)
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(
					 "bind parameter out of range (1-5)"
				 ),
				 errOmitLocation(true)));
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(
					 "missing bind parameter before :%d, or out of sequence", 
					 badbind
				 ),
				 errOmitLocation(true)));

	return (NULL);
} /* end cql1 */


/* ----------------------------------------------------------------
 * caql_getcount()
 * Perform COUNT(*) or DELETE
 * ----------------------------------------------------------------
 */
int caql_getcount(cqContext *pCtx0, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;
	HeapTuple				 tuple;
	Relation				 rel;
	int						 ii		  = 0;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */
	rel  = pCtx->cq_heap_rel;

	/* use the SysCache */
	if (pCtx->cq_usesyscache)
	{
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);

		disable_catalog_check(pCtx, tuple);
		if (HeapTupleIsValid(tuple))
		{
			ii++;
			if (pchn->bDelete)
			{
				pCtx->cq_lasttup = tuple;
				caql_iud_switch(pCtx, 0, tuple, NULL, true /* dontWait */);
				simple_heap_delete(rel, &tuple->t_self);
			}
			else
			{
				if (pCtx->cq_setpklock)
					caql_iud_switch(pCtx, 0, tuple, NULL, false /* Wait */);
			}

			ReleaseSysCache(tuple);
			/* only one */
		}
		caql_heapclose(pCtx);
		return (ii);
	}

	while (HeapTupleIsValid(tuple = systable_getnext(pCtx->cq_sysScan)))
	{
		disable_catalog_check(pCtx, tuple);
		if (HeapTupleIsValid(tuple) && (pchn->bDelete || pCtx->cq_setpklock))
		{
			pCtx->cq_lasttup = tuple;
			caql_iud_switch(pCtx, 0, tuple, NULL, true /* dontWait */);
			if (pchn->bDelete)
				simple_heap_delete(rel, &tuple->t_self);
		}

		ii++;
	}
	systable_endscan(pCtx->cq_sysScan); 
	caql_heapclose(pCtx);

	return (ii);
}

/* ----------------------------------------------------------------
 * caql_getfirst_only()
 * Return a copy the first tuple, pallocd in the current memory context,
 * and end the scan.  Clients should heap_freetuple() as necessary.
 * If pbOnly is not NULL, return TRUE if a second tuple is not found,
 * else return FALSE
 * NOTE: this function will return NULL if no tuples satisfy the
 * caql predicate -- use HeapTupleIsValid() to detect this condition.
 * ----------------------------------------------------------------
 */
HeapTuple caql_getfirst_only(cqContext *pCtx0, bool *pbOnly, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;
	HeapTuple				 tuple, newTup = NULL;
	Relation				 rel;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */
	rel  = pCtx->cq_heap_rel;

	if (pbOnly) *pbOnly = true;

	/* use the SysCache */
	if (pCtx->cq_usesyscache)
	{
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);

		disable_catalog_check(pCtx, tuple);
		if (HeapTupleIsValid(tuple))
		{
			newTup = heap_copytuple(tuple);
			ReleaseSysCache(tuple);
			/* only one */
		}
		caql_heapclose(pCtx);

		pCtx->cq_lasttup = newTup; /* need this for update/delete */

		if (pCtx->cq_setpklock)
			caql_iud_switch(pCtx, 0, newTup, NULL, false /* Wait */);

		return (newTup);
	}

	if (HeapTupleIsValid(tuple = systable_getnext(pCtx->cq_sysScan)))
	{
		disable_catalog_check(pCtx, tuple);

		/* always copy the tuple, because the endscan releases tup memory */
		newTup = heap_copytuple(tuple);
 
		if (pbOnly)
		{
			*pbOnly = 
				!(HeapTupleIsValid(systable_getnext(pCtx->cq_sysScan)));
		}
	}
	systable_endscan(pCtx->cq_sysScan); 
	caql_heapclose(pCtx);

	if (pCtx->cq_setpklock)
		caql_iud_switch(pCtx, 0, newTup, NULL, false /* Wait */);

	pCtx->cq_lasttup = newTup; /* need this for update/delete */
	return (newTup);
}

/* ----------------------------------------------------------------
 * caql_begin_CacheList()
 * Return a catclist
 * 
 * In general, catquery will choose the syscache when the cql
 * statement contains an equality predicate on *all* of the syscache
 * primary key index columns, eg: 
 *
 *   cql("SELECT * FROM pg_amop WHERE amopopr = :1 and amopclaid = :2 ")
 *
 * will use the AMOPOPID syscache with index
 * AccessMethodOperatorIndexId.  However, the cql statement for a
 * list-search requires an equality predicate on a subset of the
 * initial columns of the index, with *all* of the index columns
 * specified in an ORDER BY clause, eg:
 *
 *   cql("SELECT * FROM pg_amop WHERE amopopr = :1 "
 *       " ORDER BY amopopr, amopclaid ")
 *
 * will use a syscache list-search if this cql statement is an
 * argument to caql_begin_CacheList().  However, the syscache will
 * *not* be used for this statement if it is supplied for
 * caql_beginscan(), since SearchSysCache() can only return (at most)
 * a single tuple.
 *
 * NOTE: caql_begin_CacheList() will assert (Insist!) at runtime if
 * the cql statement does not map to a syscache lookup.
 * NOTE: it may be possible to "collapse" this API into the existing
 * beginscan/getnext/endscan.
 * ----------------------------------------------------------------
 */
struct catclist *caql_begin_CacheList(cqContext *pCtx0, 
									  cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */
	Assert(!pchn->bUpdate); /* UPDATE not allowed */
	Assert(!pchn->bDelete); /* DELETE not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	/* NOTE: for case of cache list search, we must use syscache */
	pCtx->cq_bCacheList = true; 

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */

	/* NOTE: must use the SysCache */
	Insist (pCtx->cq_usesyscache);

	caql_heapclose(pCtx);

	return SearchSysCacheKeyArrayList(pCtx->cq_cacheId, 
									  pCtx->cq_NumKeys, 
									  pCtx->cq_cacheKeys);
}


/* ----------------------------------------------------------------
 * caql_beginscan()
 * Initialize the scan and open relations/acquire locks as necessary
 * ----------------------------------------------------------------
 */
cqContext *caql_beginscan(cqContext *pCtx0, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;

	/* use the provided context, or *allocate* a clean one */
	if (pCtx0)
		pCtx = pCtx0;
	else
	{
		pCtx = (cqContext *) palloc0(sizeof(cqContext)); 
		pCtx->cq_free = true;  /* free this context in caql_endscan */
	}

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	if (pchn->bCount)
		elog(ERROR, 
			 "Cannot scan: %s -- COUNTing or DELETing\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */

	pCtx->cq_bScanBlock = true; /* started a scan block */
	pCtx->cq_freeScan	= true;

	if (pchn->bInsert) /* INSERT allowed, but no subsequent fetches */
	{
		pCtx->cq_freeScan = false; /* didn't allocate a scanner */
		pCtx->cq_EOF	  = true;
	}

	return (pCtx);
}

/* ----------------------------------------------------------------
 * caql_getnext()
 * Return a tuple.  The tuple is only valid until caql_endscan(),
 * or until the next call of caql_getnext().
 * NOTE: this function will return NULL when no tuples remain to 
 * satisfy the caql predicate -- use HeapTupleIsValid() to detect 
 * this condition.
 * ----------------------------------------------------------------
 */
HeapTuple caql_getnext(cqContext *pCtx)
{
	HeapTuple tuple;
	/* set EOF when get invalid tuple */

	if (pCtx->cq_EOF)
		return (NULL);

	if (!pCtx->cq_usesyscache)
	{
		tuple = systable_getnext(pCtx->cq_sysScan); 
		pCtx->cq_EOF = !(HeapTupleIsValid(tuple));
	}
	else
	{
		/* syscache is always 0 or 1 entry */
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);
		
		pCtx->cq_EOF	 = true;  /* at EOF always, because only 0 or 1 */
	}

	disable_catalog_check(pCtx, tuple);

	if (pCtx->cq_setpklock)
		caql_iud_switch(pCtx, 0, tuple, NULL, false /* Wait */);

	pCtx->cq_lasttup = tuple; /* need this for ReleaseSysCache */

	return (tuple);
}

/* ----------------------------------------------------------------
 * caql_getprev()
 * NOTE: similar to caql_getnext(), but backwards.  
 * Usage is rare and potentially dangerous.
 * ----------------------------------------------------------------
 */
HeapTuple caql_getprev(cqContext *pCtx)
{
	HeapTuple tuple;
	/* set EOF when get invalid tuple */

	if (pCtx->cq_EOF)
		return (NULL);

	if (!pCtx->cq_usesyscache)
	{
		tuple = systable_getprev(pCtx->cq_sysScan); 
		pCtx->cq_EOF = !(HeapTupleIsValid(tuple));
	}
	else
	{
		Insist(0); /* XXX XXX: illegal ? */
		/* syscache is always 0 or 1 entry */
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);
		
		pCtx->cq_EOF	 = true;  /* at EOF always, because only 0 or 1 */
	}

	disable_catalog_check(pCtx, tuple);

	if (pCtx->cq_setpklock)
		caql_iud_switch(pCtx, 0, tuple, NULL, false /* Wait */);

	pCtx->cq_lasttup = tuple; /* need this for ReleaseSysCache */

	return (tuple);
}

/* ----------------------------------------------------------------
 * caql_endscan()
 * free all resources associated with the scan, including tuples,
 * tables and locks.
 * NOTE: this function is *not* a "drop-in" replacement for
 * ReleaseSysCache.  ReleaseSysCache is only called for valid tuples,
 * but you must always call endscan, even if getnext never returned a
 * valid tuple.
 * ----------------------------------------------------------------
 */
void caql_endscan(cqContext *pCtx)
{
	if (pCtx->cq_indstate) /* close the indexes if they were open */
		CatalogCloseIndexes(pCtx->cq_indstate);
	pCtx->cq_indstate = NULL;

	pCtx->cq_bScanBlock = false; /* scan block has ended */

	if (pCtx->cq_freeScan)
	{
		if (!pCtx->cq_usesyscache)
			systable_endscan(pCtx->cq_sysScan); 
		else
		{
			/* XXX XXX: no need to release if never fetched a valid tuple */
			if (HeapTupleIsValid(pCtx->cq_lasttup))
				ReleaseSysCache(pCtx->cq_lasttup);
		}
	}
	caql_heapclose(pCtx);

	if (pCtx->cq_free) /* free dynamic context */
		pfree(pCtx);

	pCtx->cq_freeScan = false;
	pCtx->cq_free	  = false;
}

/* ----------------------------------------------------------------
 * caql_UpdateIndexes()

 * For caql_beginscan/caql_endscan block: 
 *   open the index once with CatalogOpenIndexes()
 *   do CatalogIndexInsert() for each tuple heap_insert or heap_update
 *   close the index with CatalogCloseIndexes() at caql_endscan()
 *
 * For all other cases (eg caql_getfirst) just do
 * CatalogUpdateIndexes(), 
 * ----------------------------------------------------------------
 */
static void caql_UpdateIndexes(cqContext	*pCtx, 
							   Relation		 rel, 
							   HeapTuple	 tup)
{
	if (RelationGetForm(rel)->relhasindex) /* check from ExecOpenIndices */
	{
		if (!pCtx->cq_bScanBlock) /* not in beginscan/endscan block */
			CatalogUpdateIndexes(rel, tup);
		else
		{
			/* open the index if necessary, then insert a tuple */
			if (!pCtx->cq_indstate)
				pCtx->cq_indstate = CatalogOpenIndexes(rel);
			CatalogIndexInsert(pCtx->cq_indstate, tup);

			/* index is closed on caql_endscan() */
		}
	}
}

/* ----------------------------------------------------------------
 * caql_delete_current()
 * during beginscan/endscan iteration, delete current tuple 
 * ----------------------------------------------------------------
 */
void caql_delete_current(cqContext *pCtx)
{
	Relation				 rel;

	rel  = pCtx->cq_heap_rel;
	Assert(RelationIsValid(rel));

	disable_catalog_check(pCtx, pCtx->cq_lasttup);
	if (HeapTupleIsValid(pCtx->cq_lasttup))
	{
		caql_iud_switch(pCtx, 0, pCtx->cq_lasttup, NULL, true /* dontWait */);
		simple_heap_delete(rel, &(pCtx->cq_lasttup)->t_self);
	}
}

/* ----------------------------------------------------------------
 * caql_insert()
 * during beginscan/endscan iteration, insert a tuple
 * NOTE: a separate call to CatalogUpdateIndexes after this will 
 * cause an error
 * ----------------------------------------------------------------
 */
Oid caql_insert(cqContext *pCtx, HeapTuple tup)
{
	Relation		 rel;
	Oid				 result;

	rel  = pCtx->cq_heap_rel;
	Assert(RelationIsValid(rel));

	disable_catalog_check(pCtx, tup);

	{
		caql_iud_switch(pCtx, 1, NULL, tup, true /* dontWait */);
		result = simple_heap_insert(rel, tup);

		/* keep the catalog indexes up to date (if has any) */
		caql_UpdateIndexes(pCtx, rel, tup);
	}
	return (result);
}

/* ----------------------------------------------------------------
 * caql_update_current()
 * during beginscan/endscan iteration, update current tuple,
 * and update catalog indexes if necessary 
 * NOTE: a separate call to CatalogUpdateIndexes after this will 
 * cause an error
 * ----------------------------------------------------------------
 */
void caql_update_current(cqContext *pCtx, HeapTuple tup)
{
	Relation				 rel;

	rel  = pCtx->cq_heap_rel;
	Assert(RelationIsValid(rel));

	Insist(HeapTupleIsValid(pCtx->cq_lasttup));

	disable_catalog_check(pCtx, pCtx->cq_lasttup);

	{
		caql_iud_switch(pCtx, 2, pCtx->cq_lasttup, tup, true /* dontWait */);
		simple_heap_update(rel, &(pCtx->cq_lasttup)->t_self, tup);

		/* keep the catalog indexes up to date (if has any) */
		caql_UpdateIndexes(pCtx, rel, tup);
	}

}
/* ----------------------------------------------------------------
 * caql_modify_current()
 * during beginscan/endscan iteration, modify current tuple
 * ----------------------------------------------------------------
 */
HeapTuple caql_modify_current(cqContext *pCtx, Datum *replValues,
							  bool *replIsnull,
							  bool *doReplace)
{
	Relation				 rel;
	HeapTuple				 tuple = NULL;

	rel  = pCtx->cq_heap_rel;
	Assert(RelationIsValid(rel));

	Insist(HeapTupleIsValid(pCtx->cq_lasttup));

	{
		tuple = heap_modify_tuple(pCtx->cq_lasttup,
								  RelationGetDescr(rel), 
								  replValues,
								  replIsnull,
								  doReplace);
	}

	return (tuple);
}
/* ----------------------------------------------------------------
 * caql_form_tuple()
 * during beginscan/endscan iteration, form a tuple
 * ----------------------------------------------------------------
 */
HeapTuple caql_form_tuple(cqContext *pCtx, Datum *replValues,
						  bool *replIsnull)
{
	Relation				 rel;
	HeapTuple				 tuple = NULL;

	rel  = pCtx->cq_heap_rel;
	Assert(RelationIsValid(rel));

	{
		tuple = heap_form_tuple(RelationGetDescr(rel), 
								replValues,
								replIsnull);
	}

	return (tuple);
}

/* ----------------------------------------------------------------
 * caql_getattr()
 * during beginscan/endscan iteration, get a tuple attribute for
 * current tuple
 * ----------------------------------------------------------------
 */

Datum caql_getattr(cqContext *pCtx, AttrNumber attnum, bool *isnull)
{
	Assert(HeapTupleIsValid(pCtx->cq_lasttup));

	return caql_getattr_internal(pCtx, pCtx->cq_lasttup, attnum, isnull);

	/* 
	  NOTE: could this be used if caql is extended to support joins, eg
	  what would attnum be for 
	  "SELECT * FROM pg_resqueue, pg_resqueuecapability ..." ?
	  Potentially, the attnum is just the ordinal position of the combined
	  SELECT list, eg you could reference pg_resqueuecapability.restypid
	  as (Natts_pg_resqueue+Anum_pg_resourcetype_restypid).

	*/

}

/* ----------------------------------------------------------------
 * caql_getattname()
 *
 * The equivalent of SearchSysCacheCopyAttName - 
 * caql_getfirst(pCtx,	
 *    "SELECT * FROM pg_attribute
 *     WHERE attrelid = :relid
 *     AND attname = :attname
 *     AND attisdropped is false"
 *    );
 *
 * That is, find the existing ("undropped") attribute and return
 * a copy.
 * NOTE: need to be careful if this pCtx is used for update...
 * ----------------------------------------------------------------
 */
HeapTuple caql_getattname(cqContext *pCtx, Oid relid, const char *attname)
{
	HeapTuple tup;

	disable_attribute_check(relid);
	tup = SearchSysCacheCopyAttName(relid, attname);

	if (pCtx)
	{
		/* treat as ATTNAME cache lookup */
		pCtx->cq_usesyscache = true;
		pCtx->cq_cacheId      = ATTNAME;
		pCtx->cq_NumKeys = 2;

		/* NOTE: no valid relation for subsequent INSERT/UPDATE/DELETE
		   *unless* an external relation is supplied */
		if (!pCtx->cq_externrel)
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
		}

		if (!pCtx->cq_setidxOK)
			pCtx->cq_useidxOK = true;

		/* for caql_update_current(), etc */
		if (pCtx->cq_setpklock)
			caql_iud_switch(pCtx, 0, tup, NULL, false /* Wait */);

		pCtx->cq_lasttup = tup;
	}   

	return (tup);

}

/* ----------------------------------------------------------------
 * caql_getattname_scan()
 *
 * The equivalent of SearchSysCacheAttName - 
 * caql_beginscan(pCtx,	
 *    "SELECT * FROM pg_attribute
 *     WHERE attrelid = :relid
 *     AND attname = :attname
 *     AND attisdropped is false"
 *    );
 *
 * That is, find the existing ("undropped") attribute and return
 * a context where the tuple is already fetched.  Retrieve the tuple
 * using caql_get_current()
 * NOTE: this is hideous.  My abject apologies.
 * NOTE: need to be careful if this pCtx is used for update...
 * ----------------------------------------------------------------
 */
cqContext *
caql_getattname_scan(cqContext *pCtx0, Oid relid, const char *attname)
{
	cqContext				*pCtx;

	disable_attribute_check(relid);

	/* use the provided context, or *allocate* a clean one */
	if (pCtx0)
		pCtx = pCtx0;
	else
	{
		pCtx = (cqContext *) palloc0(sizeof(cqContext)); 
		pCtx->cq_free = true;  /* free this context in caql_endscan */
	}

	HeapTuple tup;

	tup = SearchSysCacheAttName(relid, attname);

	if (pCtx)
	{
		/* treat as ATTNAME cache lookup */
		pCtx->cq_usesyscache = true;
		pCtx->cq_cacheId      = ATTNAME;
		pCtx->cq_NumKeys = 2;

		/* NOTE: no valid relation for subsequent INSERT/UPDATE/DELETE
		   *unless* an external relation is supplied */
		if (!pCtx->cq_externrel)
		{
			pCtx->cq_externrel = true; /* pretend we have external relation */
			pCtx->cq_heap_rel  = InvalidRelation;
		}

		if (!pCtx->cq_setidxOK)
			pCtx->cq_useidxOK = true;

		pCtx->cq_freeScan = true;
		pCtx->cq_EOF  = true;

		/* for caql_update_current(), etc */
		if (pCtx->cq_setpklock)
			caql_iud_switch(pCtx, 0, tup, NULL, false /* Wait */);

		pCtx->cq_lasttup = tup;
	}   

	return (pCtx);

}

/*
 * from lsyscach.c/get_attnum():
 *
 *		Given the relation id and the attribute name,
 *		return the "attnum" field from the attribute relation.
 *
 *		Returns InvalidAttrNumber if the attr doesn't exist (or is dropped).
 */
AttrNumber caql_getattnumber(Oid relid, const char *attname)
{
	HeapTuple	tp;

	disable_attribute_check(relid);
	tp = SearchSysCacheAttName(relid, attname);
	if (HeapTupleIsValid(tp))
	{
		Form_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);
		AttrNumber	result;

		result = att_tup->attnum;
		ReleaseSysCache(tp);
		return result;
	}
	else
		return InvalidAttrNumber;
}


/* XXX XXX: temp fix for gp_distro reference in getoid_plus */
typedef FormData_gp_policy *Form_gp_distribution_policy;

/* ----------------------------------------------------------------
 * caql_getoid_plus()
 * Return an oid column from the first tuple and end the scan.
 * Note: this works for regproc columns as well, but you should cast
 * the output as RegProcedure.
 * ----------------------------------------------------------------
 */
Oid caql_getoid_plus(cqContext *pCtx0, int *pFetchcount,
					 bool *pbIsNull, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;
	HeapTuple				 tuple;
	Relation				 rel;
	Oid						 result	  = InvalidOid;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */
	rel  = pCtx->cq_heap_rel;

	if (pFetchcount) *pFetchcount = 0;
	if (pbIsNull) *pbIsNull = true;

	/* use the SysCache */
	if (pCtx->cq_usesyscache)
	{
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);
	}
	else
	{
		tuple = systable_getnext(pCtx->cq_sysScan);
	}

	disable_catalog_check(pCtx, tuple);
	if (HeapTupleIsValid(tuple))
	{
		if (pFetchcount) *pFetchcount = 1;
		
		/* if attnum not set, (InvalidAttrNumber == 0)
		 * use tuple oid, else extract oid from column 
		 * (includes ObjectIdAttributeNumber == -2) 
		 */
		if (pchn->attnum <= InvalidAttrNumber) 
		{
			if (pbIsNull) *pbIsNull = false;
			result = HeapTupleGetOid(tuple);
		}
		else /* find oid column */
		{
			
			switch(pCtx->cq_relationId)
			{
				
				case GpPolicyRelationId: /* gp_distribution_policy */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* localoid */
							result = (Oid) 
								((Form_gp_distribution_policy) 
								 GETSTRUCT(tuple))->localoid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end gp_distribution_policy */
					break;
				
				case FastSequenceRelationId: /* gp_fastsequence */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* objid */
							result = (Oid) 
								((Form_gp_fastsequence) 
								 GETSTRUCT(tuple))->objid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end gp_fastsequence */
					break;
				
				case AggregateRelationId: /* pg_aggregate */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* aggfnoid */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggfnoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* aggtransfn */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggtransfn;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* agginvtransfn */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->agginvtransfn;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* aggprelimfn */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggprelimfn;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* agginvprelimfn */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->agginvprelimfn;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* aggfinalfn */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggfinalfn;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* aggsortop */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggsortop;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* aggtranstype */
							result = (Oid) 
								((Form_pg_aggregate) 
								 GETSTRUCT(tuple))->aggtranstype;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_aggregate */
					break;
				
				case AccessMethodRelationId: /* pg_am */
				{
					switch(pchn->attnum)
					{
						
						case 12: /* aminsert */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->aminsert;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 13: /* ambeginscan */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->ambeginscan;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 14: /* amgettuple */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amgettuple;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 15: /* amgetmulti */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amgetmulti;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 16: /* amrescan */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amrescan;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 17: /* amendscan */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amendscan;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 18: /* ammarkpos */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->ammarkpos;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 19: /* amrestrpos */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amrestrpos;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 20: /* ambuild */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->ambuild;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 21: /* ambulkdelete */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->ambulkdelete;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 22: /* amvacuumcleanup */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amvacuumcleanup;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 23: /* amcostestimate */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amcostestimate;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 24: /* amoptions */
							result = (Oid) 
								((Form_pg_am) 
								 GETSTRUCT(tuple))->amoptions;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_am */
					break;
				
				case AccessMethodOperatorRelationId: /* pg_amop */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* amopclaid */
							result = (Oid) 
								((Form_pg_amop) 
								 GETSTRUCT(tuple))->amopclaid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* amopsubtype */
							result = (Oid) 
								((Form_pg_amop) 
								 GETSTRUCT(tuple))->amopsubtype;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* amopopr */
							result = (Oid) 
								((Form_pg_amop) 
								 GETSTRUCT(tuple))->amopopr;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_amop */
					break;
				
				case AccessMethodProcedureRelationId: /* pg_amproc */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* amopclaid */
							result = (Oid) 
								((Form_pg_amproc) 
								 GETSTRUCT(tuple))->amopclaid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* amprocsubtype */
							result = (Oid) 
								((Form_pg_amproc) 
								 GETSTRUCT(tuple))->amprocsubtype;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* amproc */
							result = (Oid) 
								((Form_pg_amproc) 
								 GETSTRUCT(tuple))->amproc;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_amproc */
					break;
				
				case AppendOnlyRelationId: /* pg_appendonly */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* relid */
							result = (Oid) 
								((Form_pg_appendonly) 
								 GETSTRUCT(tuple))->relid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* segrelid */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 10, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 11: /* segidxid */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 11, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 12: /* blkdirrelid */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 12, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 13: /* blkdiridxid */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 13, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_appendonly */
					break;
				
				case AttrDefaultRelationId: /* pg_attrdef */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* adrelid */
							result = (Oid) 
								((Form_pg_attrdef) 
								 GETSTRUCT(tuple))->adrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_attrdef */
					break;
				
				case AttributeRelationId: /* pg_attribute */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* attrelid */
							result = (Oid) 
								((Form_pg_attribute) 
								 GETSTRUCT(tuple))->attrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* atttypid */
							result = (Oid) 
								((Form_pg_attribute) 
								 GETSTRUCT(tuple))->atttypid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_attribute */
					break;
				
				case AttributeEncodingRelationId: /* pg_attribute_encoding */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* attrelid */
							result = (Oid) 
								((Form_pg_attribute_encoding) 
								 GETSTRUCT(tuple))->attrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_attribute_encoding */
					break;
				
				case AuthMemRelationId: /* pg_auth_members */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* roleid */
							result = (Oid) 
								((Form_pg_auth_members) 
								 GETSTRUCT(tuple))->roleid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* member */
							result = (Oid) 
								((Form_pg_auth_members) 
								 GETSTRUCT(tuple))->member;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* grantor */
							result = (Oid) 
								((Form_pg_auth_members) 
								 GETSTRUCT(tuple))->grantor;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_auth_members */
					break;
				
				case AuthTimeConstraintRelationId: /* pg_auth_time_constraint */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* authid */
							result = (Oid) 
								((Form_pg_auth_time_constraint) 
								 GETSTRUCT(tuple))->authid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_auth_time_constraint */
					break;
				
				case AuthIdRelationId: /* pg_authid */
				{
					switch(pchn->attnum)
					{
						
						case 12: /* rolresqueue */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 12, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_authid */
					break;
				
				case CastRelationId: /* pg_cast */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* castsource */
							result = (Oid) 
								((Form_pg_cast) 
								 GETSTRUCT(tuple))->castsource;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* casttarget */
							result = (Oid) 
								((Form_pg_cast) 
								 GETSTRUCT(tuple))->casttarget;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* castfunc */
							result = (Oid) 
								((Form_pg_cast) 
								 GETSTRUCT(tuple))->castfunc;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_cast */
					break;
				
				case RelationRelationId: /* pg_class */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* relnamespace */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relnamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* reltype */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->reltype;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* relowner */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* relam */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relam;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* relfilenode */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relfilenode;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* reltablespace */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->reltablespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* reltoastrelid */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->reltoastrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 11: /* reltoastidxid */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->reltoastidxid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 12: /* relaosegrelid */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relaosegrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 13: /* relaosegidxid */
							result = (Oid) 
								((Form_pg_class) 
								 GETSTRUCT(tuple))->relaosegidxid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_class */
					break;
				
				case CompressionRelationId: /* pg_compression */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* compconstructor */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compconstructor;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* compdestructor */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compdestructor;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* compcompressor */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compcompressor;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* compdecompressor */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compdecompressor;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* compvalidator */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compvalidator;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* compowner */
							result = (Oid) 
								((Form_pg_compression) 
								 GETSTRUCT(tuple))->compowner;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_compression */
					break;
				
				case ConstraintRelationId: /* pg_constraint */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* connamespace */
							result = (Oid) 
								((Form_pg_constraint) 
								 GETSTRUCT(tuple))->connamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* conrelid */
							result = (Oid) 
								((Form_pg_constraint) 
								 GETSTRUCT(tuple))->conrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* contypid */
							result = (Oid) 
								((Form_pg_constraint) 
								 GETSTRUCT(tuple))->contypid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* confrelid */
							result = (Oid) 
								((Form_pg_constraint) 
								 GETSTRUCT(tuple))->confrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_constraint */
					break;
				
				case ConversionRelationId: /* pg_conversion */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* connamespace */
							result = (Oid) 
								((Form_pg_conversion) 
								 GETSTRUCT(tuple))->connamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* conowner */
							result = (Oid) 
								((Form_pg_conversion) 
								 GETSTRUCT(tuple))->conowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* conproc */
							result = (Oid) 
								((Form_pg_conversion) 
								 GETSTRUCT(tuple))->conproc;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_conversion */
					break;
				
				case DatabaseRelationId: /* pg_database */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* datdba */
							result = (Oid) 
								((Form_pg_database) 
								 GETSTRUCT(tuple))->datdba;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* datlastsysoid */
							result = (Oid) 
								((Form_pg_database) 
								 GETSTRUCT(tuple))->datlastsysoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 9: /* dattablespace */
							result = (Oid) 
								((Form_pg_database) 
								 GETSTRUCT(tuple))->dattablespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* dat2tablespace */
							result = (Oid) 
								((Form_pg_database) 
								 GETSTRUCT(tuple))->dat2tablespace;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_database */
					break;
				
				case DependRelationId: /* pg_depend */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* classid */
							result = (Oid) 
								((Form_pg_depend) 
								 GETSTRUCT(tuple))->classid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* objid */
							result = (Oid) 
								((Form_pg_depend) 
								 GETSTRUCT(tuple))->objid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* refclassid */
							result = (Oid) 
								((Form_pg_depend) 
								 GETSTRUCT(tuple))->refclassid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* refobjid */
							result = (Oid) 
								((Form_pg_depend) 
								 GETSTRUCT(tuple))->refobjid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_depend */
					break;
				
				case DescriptionRelationId: /* pg_description */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* objoid */
							result = (Oid) 
								((Form_pg_description) 
								 GETSTRUCT(tuple))->objoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* classoid */
							result = (Oid) 
								((Form_pg_description) 
								 GETSTRUCT(tuple))->classoid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_description */
					break;
				
				case ExtprotocolRelationId: /* pg_extprotocol */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* ptcreadfn */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 2, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 3: /* ptcwritefn */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 3, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 4: /* ptcvalidatorfn */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 4, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
						
						case 5: /* ptcowner */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 5, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_extprotocol */
					break;
				
				case ExtTableRelationId: /* pg_exttable */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* reloid */
							result = (Oid) 
								((Form_pg_exttable) 
								 GETSTRUCT(tuple))->reloid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* fmterrtbl */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 8, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_exttable */
					break;
				
				case FileSpaceRelationId: /* pg_filespace */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* fsowner */
							result = (Oid) 
								((Form_pg_filespace) 
								 GETSTRUCT(tuple))->fsowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* fsfsys */
							result = (Oid) 
								((Form_pg_filespace) 
								 GETSTRUCT(tuple))->fsfsys;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_filespace */
					break;
				
				case FileSpaceEntryRelationId: /* pg_filespace_entry */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* fsefsoid */
							result = (Oid) 
								((Form_pg_filespace_entry) 
								 GETSTRUCT(tuple))->fsefsoid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_filespace_entry */
					break;
				
				case ForeignDataWrapperRelationId: /* pg_foreign_data_wrapper */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* fdwowner */
							result = (Oid) 
								((Form_pg_foreign_data_wrapper) 
								 GETSTRUCT(tuple))->fdwowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* fdwvalidator */
							result = (Oid) 
								((Form_pg_foreign_data_wrapper) 
								 GETSTRUCT(tuple))->fdwvalidator;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_foreign_data_wrapper */
					break;
				
				case ForeignServerRelationId: /* pg_foreign_server */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* srvowner */
							result = (Oid) 
								((Form_pg_foreign_server) 
								 GETSTRUCT(tuple))->srvowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* srvfdw */
							result = (Oid) 
								((Form_pg_foreign_server) 
								 GETSTRUCT(tuple))->srvfdw;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_foreign_server */
					break;
				
				case ForeignTableRelationId: /* pg_foreign_table */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* reloid */
							result = (Oid) 
								((Form_pg_foreign_table) 
								 GETSTRUCT(tuple))->reloid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* server */
							result = (Oid) 
								((Form_pg_foreign_table) 
								 GETSTRUCT(tuple))->server;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_foreign_table */
					break;
				
				case IndexRelationId: /* pg_index */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* indexrelid */
							result = (Oid) 
								((Form_pg_index) 
								 GETSTRUCT(tuple))->indexrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* indrelid */
							result = (Oid) 
								((Form_pg_index) 
								 GETSTRUCT(tuple))->indrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_index */
					break;
				
				case InheritsRelationId: /* pg_inherits */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* inhrelid */
							result = (Oid) 
								((Form_pg_inherits) 
								 GETSTRUCT(tuple))->inhrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* inhparent */
							result = (Oid) 
								((Form_pg_inherits) 
								 GETSTRUCT(tuple))->inhparent;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_inherits */
					break;
				
				case LanguageRelationId: /* pg_language */
				{
					switch(pchn->attnum)
					{
						
						case 4: /* lanplcallfoid */
							result = (Oid) 
								((Form_pg_language) 
								 GETSTRUCT(tuple))->lanplcallfoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* lanvalidator */
							result = (Oid) 
								((Form_pg_language) 
								 GETSTRUCT(tuple))->lanvalidator;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_language */
					break;
				
				case LargeObjectRelationId: /* pg_largeobject */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* loid */
							result = (Oid) 
								((Form_pg_largeobject) 
								 GETSTRUCT(tuple))->loid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_largeobject */
					break;
				
				case NamespaceRelationId: /* pg_namespace */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* nspowner */
							result = (Oid) 
								((Form_pg_namespace) 
								 GETSTRUCT(tuple))->nspowner;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_namespace */
					break;
				
				case OperatorClassRelationId: /* pg_opclass */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* opcamid */
							result = (Oid) 
								((Form_pg_opclass) 
								 GETSTRUCT(tuple))->opcamid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* opcnamespace */
							result = (Oid) 
								((Form_pg_opclass) 
								 GETSTRUCT(tuple))->opcnamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* opcowner */
							result = (Oid) 
								((Form_pg_opclass) 
								 GETSTRUCT(tuple))->opcowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* opcintype */
							result = (Oid) 
								((Form_pg_opclass) 
								 GETSTRUCT(tuple))->opcintype;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* opckeytype */
							result = (Oid) 
								((Form_pg_opclass) 
								 GETSTRUCT(tuple))->opckeytype;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_opclass */
					break;
				
				case OperatorRelationId: /* pg_operator */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* oprnamespace */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprnamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* oprowner */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* oprleft */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprleft;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* oprright */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprright;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* oprresult */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprresult;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 9: /* oprcom */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprcom;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* oprnegate */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprnegate;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 11: /* oprlsortop */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprlsortop;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 12: /* oprrsortop */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprrsortop;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 13: /* oprltcmpop */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprltcmpop;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 14: /* oprgtcmpop */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprgtcmpop;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 15: /* oprcode */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprcode;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 16: /* oprrest */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprrest;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 17: /* oprjoin */
							result = (Oid) 
								((Form_pg_operator) 
								 GETSTRUCT(tuple))->oprjoin;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_operator */
					break;
				
				case PartitionRelationId: /* pg_partition */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* parrelid */
							result = (Oid) 
								((Form_pg_partition) 
								 GETSTRUCT(tuple))->parrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_partition */
					break;
				
				case PartitionEncodingRelationId: /* pg_partition_encoding */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* parencoid */
							result = (Oid) 
								((Form_pg_partition_encoding) 
								 GETSTRUCT(tuple))->parencoid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_partition_encoding */
					break;
				
				case PartitionRuleRelationId: /* pg_partition_rule */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* paroid */
							result = (Oid) 
								((Form_pg_partition_rule) 
								 GETSTRUCT(tuple))->paroid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* parchildrelid */
							result = (Oid) 
								((Form_pg_partition_rule) 
								 GETSTRUCT(tuple))->parchildrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* parparentrule */
							result = (Oid) 
								((Form_pg_partition_rule) 
								 GETSTRUCT(tuple))->parparentrule;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 14: /* partemplatespace */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 14, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_partition_rule */
					break;
				
				case ProcedureRelationId: /* pg_proc */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* pronamespace */
							result = (Oid) 
								((Form_pg_proc) 
								 GETSTRUCT(tuple))->pronamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* proowner */
							result = (Oid) 
								((Form_pg_proc) 
								 GETSTRUCT(tuple))->proowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* prolang */
							result = (Oid) 
								((Form_pg_proc) 
								 GETSTRUCT(tuple))->prolang;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 11: /* prorettype */
							result = (Oid) 
								((Form_pg_proc) 
								 GETSTRUCT(tuple))->prorettype;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_proc */
					break;
				
				case ProcCallbackRelationId: /* pg_proc_callback */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* profnoid */
							result = (Oid) 
								((Form_pg_proc_callback) 
								 GETSTRUCT(tuple))->profnoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* procallback */
							result = (Oid) 
								((Form_pg_proc_callback) 
								 GETSTRUCT(tuple))->procallback;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_proc_callback */
					break;
				
				case ResQueueCapabilityRelationId: /* pg_resqueuecapability */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* resqueueid */
							result = (Oid) 
								((Form_pg_resqueuecapability) 
								 GETSTRUCT(tuple))->resqueueid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_resqueuecapability */
					break;
				
				case RewriteRelationId: /* pg_rewrite */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* ev_class */
							result = (Oid) 
								((Form_pg_rewrite) 
								 GETSTRUCT(tuple))->ev_class;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_rewrite */
					break;
				
				case SharedDependRelationId: /* pg_shdepend */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* dbid */
							result = (Oid) 
								((Form_pg_shdepend) 
								 GETSTRUCT(tuple))->dbid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* classid */
							result = (Oid) 
								((Form_pg_shdepend) 
								 GETSTRUCT(tuple))->classid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* objid */
							result = (Oid) 
								((Form_pg_shdepend) 
								 GETSTRUCT(tuple))->objid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* refclassid */
							result = (Oid) 
								((Form_pg_shdepend) 
								 GETSTRUCT(tuple))->refclassid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 5: /* refobjid */
							result = (Oid) 
								((Form_pg_shdepend) 
								 GETSTRUCT(tuple))->refobjid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_shdepend */
					break;
				
				case SharedDescriptionRelationId: /* pg_shdescription */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* objoid */
							result = (Oid) 
								((Form_pg_shdescription) 
								 GETSTRUCT(tuple))->objoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* classoid */
							result = (Oid) 
								((Form_pg_shdescription) 
								 GETSTRUCT(tuple))->classoid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_shdescription */
					break;
				
				case StatLastOpRelationId: /* pg_stat_last_operation */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* classid */
							result = (Oid) 
								((Form_pg_statlastop) 
								 GETSTRUCT(tuple))->classid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* objid */
							result = (Oid) 
								((Form_pg_statlastop) 
								 GETSTRUCT(tuple))->objid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* stasysid */
							result = (Oid) 
								((Form_pg_statlastop) 
								 GETSTRUCT(tuple))->stasysid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_stat_last_operation */
					break;
				
				case StatLastShOpRelationId: /* pg_stat_last_shoperation */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* classid */
							result = (Oid) 
								((Form_pg_statlastshop) 
								 GETSTRUCT(tuple))->classid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* objid */
							result = (Oid) 
								((Form_pg_statlastshop) 
								 GETSTRUCT(tuple))->objid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 4: /* stasysid */
							result = (Oid) 
								((Form_pg_statlastshop) 
								 GETSTRUCT(tuple))->stasysid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_stat_last_shoperation */
					break;
				
				case StatisticRelationId: /* pg_statistic */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* starelid */
							result = (Oid) 
								((Form_pg_statistic) 
								 GETSTRUCT(tuple))->starelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* staop1 */
							result = (Oid) 
								((Form_pg_statistic) 
								 GETSTRUCT(tuple))->staop1;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 11: /* staop2 */
							result = (Oid) 
								((Form_pg_statistic) 
								 GETSTRUCT(tuple))->staop2;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 12: /* staop3 */
							result = (Oid) 
								((Form_pg_statistic) 
								 GETSTRUCT(tuple))->staop3;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 13: /* staop4 */
							result = (Oid) 
								((Form_pg_statistic) 
								 GETSTRUCT(tuple))->staop4;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_statistic */
					break;
				
				case TableSpaceRelationId: /* pg_tablespace */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* spcowner */
							result = (Oid) 
								((Form_pg_tablespace) 
								 GETSTRUCT(tuple))->spcowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* spcfsoid */
						{
							bool		isnull;
							Datum		d = 
								caql_getattr_internal(pCtx, tuple, 7, &isnull);
						
							if (!isnull)
								result = DatumGetObjectId(d);
						
							if (pbIsNull) *pbIsNull = isnull;
						}
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_tablespace */
					break;
				
				case TriggerRelationId: /* pg_trigger */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* tgrelid */
							result = (Oid) 
								((Form_pg_trigger) 
								 GETSTRUCT(tuple))->tgrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* tgfoid */
							result = (Oid) 
								((Form_pg_trigger) 
								 GETSTRUCT(tuple))->tgfoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* tgconstrrelid */
							result = (Oid) 
								((Form_pg_trigger) 
								 GETSTRUCT(tuple))->tgconstrrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_trigger */
					break;
				
				case TypeRelationId: /* pg_type */
				{
					switch(pchn->attnum)
					{
						
						case 2: /* typnamespace */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typnamespace;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 3: /* typowner */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typowner;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 9: /* typrelid */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typrelid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 10: /* typelem */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typelem;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 11: /* typinput */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typinput;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 12: /* typoutput */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typoutput;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 13: /* typreceive */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typreceive;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 14: /* typsend */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typsend;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 15: /* typanalyze */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typanalyze;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 19: /* typbasetype */
							result = (Oid) 
								((Form_pg_type) 
								 GETSTRUCT(tuple))->typbasetype;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_type */
					break;
				
				case TypeEncodingRelationId: /* pg_type_encoding */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* typid */
							result = (Oid) 
								((Form_pg_type_encoding) 
								 GETSTRUCT(tuple))->typid;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_type_encoding */
					break;
				
				case UserMappingRelationId: /* pg_user_mapping */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* umuser */
							result = (Oid) 
								((Form_pg_user_mapping) 
								 GETSTRUCT(tuple))->umuser;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 2: /* umserver */
							result = (Oid) 
								((Form_pg_user_mapping) 
								 GETSTRUCT(tuple))->umserver;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_user_mapping */
					break;
				
				case WindowRelationId: /* pg_window */
				{
					switch(pchn->attnum)
					{
						
						case 1: /* winfnoid */
							result = (Oid) 
								((Form_pg_window) 
								 GETSTRUCT(tuple))->winfnoid;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 6: /* winfunc */
							result = (Oid) 
								((Form_pg_window) 
								 GETSTRUCT(tuple))->winfunc;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 7: /* winprefunc */
							result = (Oid) 
								((Form_pg_window) 
								 GETSTRUCT(tuple))->winprefunc;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 8: /* winpretype */
							result = (Oid) 
								((Form_pg_window) 
								 GETSTRUCT(tuple))->winpretype;
							if (pbIsNull) *pbIsNull = false;
							break;
						
						case 9: /* winfinfunc */
							result = (Oid) 
								((Form_pg_window) 
								 GETSTRUCT(tuple))->winfinfunc;
							if (pbIsNull) *pbIsNull = false;
							break;
				
					  default:
						elog(ERROR, "column not an oid: %s\nfile: %s, line %d", 
							 caql_str, filenam, lineno);
					}
				} /* end pg_window */
					break;
			
			  default:
				elog(ERROR, "could not get column for relation: %s\nfile: %s, line %d", 
					 caql_str, filenam, lineno);
			}

		}
	} /* end HeapTupleIsValid */

	if (pCtx->cq_usesyscache)
	{  
		if (HeapTupleIsValid(tuple))
			ReleaseSysCache(tuple);
	}
	else
	{	
		if (pFetchcount && HeapTupleIsValid(tuple))
		{				
			if (HeapTupleIsValid(systable_getnext(pCtx->cq_sysScan)))
			{
				*pFetchcount = 2;	
			}
		}
		systable_endscan(pCtx->cq_sysScan); 
	}		
	caql_heapclose(pCtx);

	return (result);
} /* end caql_getoid_plus */

/* ----------------------------------------------------------------
 * caql_getoid_only()
 * Return the oid of the first tuple and end the scan
 * If pbOnly is not NULL, return TRUE if a second tuple is not found,
 * else return FALSE
 * ----------------------------------------------------------------
 */
Oid caql_getoid_only(cqContext *pCtx0, bool *pbOnly, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;
	HeapTuple				 tuple;
	Relation				 rel;
	Oid						 result = InvalidOid;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */
	rel  = pCtx->cq_heap_rel;

	if (pbOnly) *pbOnly = true;

	/* use the SysCache */
	if (pCtx->cq_usesyscache)
	{
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);

		disable_catalog_check(pCtx, tuple);

		if (HeapTupleIsValid(tuple))
		{
			result = HeapTupleGetOid(tuple);
			ReleaseSysCache(tuple);
			/* only one */
		}
		caql_heapclose(pCtx);

		return (result);
	}

	if (HeapTupleIsValid(tuple = systable_getnext(pCtx->cq_sysScan)))
	{
		disable_catalog_check(pCtx, tuple);

		result = HeapTupleGetOid(tuple);

		if (pbOnly)
		{
			*pbOnly = 
				!(HeapTupleIsValid(tuple = 
								   systable_getnext(pCtx->cq_sysScan)));
		}
	}
	systable_endscan(pCtx->cq_sysScan); 
	caql_heapclose(pCtx);
	return (result);
}

/* ----------------------------------------------------------------
 * caql_getcstring_plus()
 * Return a cstring column from the first tuple and end the scan.
 * ----------------------------------------------------------------
 */
char *caql_getcstring_plus(cqContext *pCtx0, int *pFetchcount,
						   bool *pbIsNull, cq_list *pcql)
{
	const char*				 caql_str = pcql->caqlStr;
	const char*				 filenam  = pcql->filename;
	int						 lineno	  = pcql->lineno;
	struct caql_hash_cookie	*pchn	  = cq_lookup(caql_str, strlen(caql_str), pcql);
	cqContext				*pCtx;
	cqContext				 cqc;
	HeapTuple				 tuple;
	Relation				 rel;
	char					*result = NULL;

	if (NULL == pchn)
		elog(ERROR, "invalid caql string: %s\nfile: %s, line %d", 
			 caql_str, filenam, lineno);

	Assert(!pchn->bInsert); /* INSERT not allowed */

	/* use the provided context, or provide a clean local ctx  */
	if (pCtx0)
		pCtx = pCtx0;
	else
		pCtx = cqclr(&cqc);

	pCtx = caql_switch(pchn, pCtx, pcql);
	/* NOTE: caql_switch frees the pcql */
	rel  = pCtx->cq_heap_rel;

	if (pFetchcount) *pFetchcount = 0;
	if (pbIsNull) *pbIsNull = true;

	/* use the SysCache */
	if (pCtx->cq_usesyscache)
	{
		tuple = SearchSysCacheKeyArray(pCtx->cq_cacheId, 
									   pCtx->cq_NumKeys, 
									   pCtx->cq_cacheKeys);
	}
	else
	{
		tuple = systable_getnext(pCtx->cq_sysScan);
	}

	disable_catalog_check(pCtx, tuple);

	if (HeapTupleIsValid(tuple))
	{
		if (pFetchcount) *pFetchcount = 1;
		
		switch(pCtx->cq_relationId)
		{
			
			case GpSegmentConfigRelationId: /* gp_segment_configuration */
			{
				switch(pchn->attnum)
				{
					
					case 8: /* hostname */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 8, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 9: /* address */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 9, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end gp_segment_configuration */
				break;
			
			case AggregateRelationId: /* pg_aggregate */
			{
				switch(pchn->attnum)
				{
					
					case 9: /* agginitval */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 9, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_aggregate */
				break;
			
			case AccessMethodRelationId: /* pg_am */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* amname */
						result = pstrdup(
							NameStr(((Form_pg_am) 
									 GETSTRUCT(tuple))->amname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_am */
				break;
			
			case AppendOnlyRelationId: /* pg_appendonly */
			{
				switch(pchn->attnum)
				{
					
					case 8: /* compresstype */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 8, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_appendonly */
				break;
			
			case AttrDefaultRelationId: /* pg_attrdef */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* adbin */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 4: /* adsrc */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 4, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_attrdef */
				break;
			
			case AttributeRelationId: /* pg_attribute */
			{
				switch(pchn->attnum)
				{
					
					case 2: /* attname */
						result = pstrdup(
							NameStr(((Form_pg_attribute) 
									 GETSTRUCT(tuple))->attname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_attribute */
				break;
			
			case AttributeEncodingRelationId: /* pg_attribute_encoding */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* attoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_attribute_encoding */
				break;
			
			case AuthIdRelationId: /* pg_authid */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* rolname */
						result = pstrdup(
							NameStr(((Form_pg_authid) 
									 GETSTRUCT(tuple))->rolname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 9: /* rolpassword */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 9, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 11: /* rolconfig */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 11, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_authid */
				break;
			
			case RelationRelationId: /* pg_class */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* relname */
						result = pstrdup(
							NameStr(((Form_pg_class) 
									 GETSTRUCT(tuple))->relname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 30: /* reloptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 30, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_class */
				break;
			
			case CompressionRelationId: /* pg_compression */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* compname */
						result = pstrdup(
							NameStr(((Form_pg_compression) 
									 GETSTRUCT(tuple))->compname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_compression */
				break;
			
			case ConstraintRelationId: /* pg_constraint */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* conname */
						result = pstrdup(
							NameStr(((Form_pg_constraint) 
									 GETSTRUCT(tuple))->conname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 14: /* conbin */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 14, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 15: /* consrc */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 15, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_constraint */
				break;
			
			case ConversionRelationId: /* pg_conversion */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* conname */
						result = pstrdup(
							NameStr(((Form_pg_conversion) 
									 GETSTRUCT(tuple))->conname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_conversion */
				break;
			
			case DatabaseRelationId: /* pg_database */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* datname */
						result = pstrdup(
							NameStr(((Form_pg_database) 
									 GETSTRUCT(tuple))->datname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 11: /* datconfig */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 11, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_database */
				break;
			
			case DescriptionRelationId: /* pg_description */
			{
				switch(pchn->attnum)
				{
					
					case 4: /* description */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 4, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_description */
				break;
			
			case ExtprotocolRelationId: /* pg_extprotocol */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* ptcname */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 1, &isnull);
					
						if (!isnull)
							result = pstrdup(
								NameStr(*(DatumGetName(d))));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_extprotocol */
				break;
			
			case ExtTableRelationId: /* pg_exttable */
			{
				switch(pchn->attnum)
				{
					
					case 2: /* location */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 2, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 4: /* fmtopts */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 4, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 5: /* command */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 5, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_exttable */
				break;
			
			case FileSpaceRelationId: /* pg_filespace */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* fsname */
						result = pstrdup(
							NameStr(((Form_pg_filespace) 
									 GETSTRUCT(tuple))->fsname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_filespace */
				break;
			
			case FileSpaceEntryRelationId: /* pg_filespace_entry */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* fselocation */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_filespace_entry */
				break;
			
			case ForeignDataWrapperRelationId: /* pg_foreign_data_wrapper */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* fdwname */
						result = pstrdup(
							NameStr(((Form_pg_foreign_data_wrapper) 
									 GETSTRUCT(tuple))->fdwname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 5: /* fdwoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 5, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_foreign_data_wrapper */
				break;
			
			case ForeignServerRelationId: /* pg_foreign_server */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* srvname */
						result = pstrdup(
							NameStr(((Form_pg_foreign_server) 
									 GETSTRUCT(tuple))->srvname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 4: /* srvtype */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 4, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 5: /* srvversion */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 5, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 7: /* srvoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 7, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_foreign_server */
				break;
			
			case ForeignTableRelationId: /* pg_foreign_table */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* tbloptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_foreign_table */
				break;
			
			case IndexRelationId: /* pg_index */
			{
				switch(pchn->attnum)
				{
					
					case 10: /* indexprs */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 10, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 11: /* indpred */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 11, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_index */
				break;
			
			case LanguageRelationId: /* pg_language */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* lanname */
						result = pstrdup(
							NameStr(((Form_pg_language) 
									 GETSTRUCT(tuple))->lanname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_language */
				break;
			
			case NamespaceRelationId: /* pg_namespace */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* nspname */
						result = pstrdup(
							NameStr(((Form_pg_namespace) 
									 GETSTRUCT(tuple))->nspname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_namespace */
				break;
			
			case OperatorClassRelationId: /* pg_opclass */
			{
				switch(pchn->attnum)
				{
					
					case 2: /* opcname */
						result = pstrdup(
							NameStr(((Form_pg_opclass) 
									 GETSTRUCT(tuple))->opcname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_opclass */
				break;
			
			case OperatorRelationId: /* pg_operator */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* oprname */
						result = pstrdup(
							NameStr(((Form_pg_operator) 
									 GETSTRUCT(tuple))->oprname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_operator */
				break;
			
			case PartitionEncodingRelationId: /* pg_partition_encoding */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* parencattoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_partition_encoding */
				break;
			
			case PartitionRuleRelationId: /* pg_partition_rule */
			{
				switch(pchn->attnum)
				{
					
					case 4: /* parname */
						result = pstrdup(
							NameStr(((Form_pg_partition_rule) 
									 GETSTRUCT(tuple))->parname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 9: /* parrangestart */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 9, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 10: /* parrangeend */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 10, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 11: /* parrangeevery */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 11, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 12: /* parlistvalues */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 12, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 13: /* parreloptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 13, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_partition_rule */
				break;
			
			case PLTemplateRelationId: /* pg_pltemplate */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* tmplname */
						result = pstrdup(
							NameStr(((Form_pg_pltemplate) 
									 GETSTRUCT(tuple))->tmplname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 3: /* tmplhandler */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 4: /* tmplvalidator */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 4, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 5: /* tmpllibrary */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 5, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_pltemplate */
				break;
			
			case ProcedureRelationId: /* pg_proc */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* proname */
						result = pstrdup(
							NameStr(((Form_pg_proc) 
									 GETSTRUCT(tuple))->proname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 16: /* proargnames */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 16, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 17: /* prosrc */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 17, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_proc */
				break;
			
			case ResourceTypeRelationId: /* pg_resourcetype */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* resname */
						result = pstrdup(
							NameStr(((Form_pg_resourcetype) 
									 GETSTRUCT(tuple))->resname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 6: /* resdefaultsetting */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 6, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 7: /* resdisabledsetting */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 7, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_resourcetype */
				break;
			
			case ResQueueRelationId: /* pg_resqueue */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* rsqname */
						result = pstrdup(
							NameStr(((Form_pg_resqueue) 
									 GETSTRUCT(tuple))->rsqname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_resqueue */
				break;
			
			case ResQueueCapabilityRelationId: /* pg_resqueuecapability */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* ressetting */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_resqueuecapability */
				break;
			
			case RewriteRelationId: /* pg_rewrite */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* rulename */
						result = pstrdup(
							NameStr(((Form_pg_rewrite) 
									 GETSTRUCT(tuple))->rulename));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 6: /* ev_qual */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 6, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 7: /* ev_action */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 7, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_rewrite */
				break;
			
			case SharedDescriptionRelationId: /* pg_shdescription */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* description */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_shdescription */
				break;
			
			case StatLastOpRelationId: /* pg_stat_last_operation */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* staactionname */
						result = pstrdup(
							NameStr(((Form_pg_statlastop) 
									 GETSTRUCT(tuple))->staactionname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 5: /* stausename */
						result = pstrdup(
							NameStr(((Form_pg_statlastop) 
									 GETSTRUCT(tuple))->stausename));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 6: /* stasubtype */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 6, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_stat_last_operation */
				break;
			
			case StatLastShOpRelationId: /* pg_stat_last_shoperation */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* staactionname */
						result = pstrdup(
							NameStr(((Form_pg_statlastshop) 
									 GETSTRUCT(tuple))->staactionname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 5: /* stausename */
						result = pstrdup(
							NameStr(((Form_pg_statlastshop) 
									 GETSTRUCT(tuple))->stausename));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 6: /* stasubtype */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 6, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_stat_last_shoperation */
				break;
			
			case StatisticRelationId: /* pg_statistic */
			{
				switch(pchn->attnum)
				{
					
					case 18: /* stavalues1 */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 18, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 19: /* stavalues2 */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 19, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 20: /* stavalues3 */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 20, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 21: /* stavalues4 */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 21, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_statistic */
				break;
			
			case TableSpaceRelationId: /* pg_tablespace */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* spcname */
						result = pstrdup(
							NameStr(((Form_pg_tablespace) 
									 GETSTRUCT(tuple))->spcname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 3: /* spclocation */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 5: /* spcprilocations */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 5, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 6: /* spcmirlocations */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 6, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_tablespace */
				break;
			
			case TriggerRelationId: /* pg_trigger */
			{
				switch(pchn->attnum)
				{
					
					case 2: /* tgname */
						result = pstrdup(
							NameStr(((Form_pg_trigger) 
									 GETSTRUCT(tuple))->tgname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 7: /* tgconstrname */
						result = pstrdup(
							NameStr(((Form_pg_trigger) 
									 GETSTRUCT(tuple))->tgconstrname));
						if (pbIsNull) *pbIsNull = false;
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_trigger */
				break;
			
			case TypeRelationId: /* pg_type */
			{
				switch(pchn->attnum)
				{
					
					case 1: /* typname */
						result = pstrdup(
							NameStr(((Form_pg_type) 
									 GETSTRUCT(tuple))->typname));
						if (pbIsNull) *pbIsNull = false;
						break;
					
					case 22: /* typdefaultbin */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 22, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
					
					case 23: /* typdefault */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 23, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_type */
				break;
			
			case TypeEncodingRelationId: /* pg_type_encoding */
			{
				switch(pchn->attnum)
				{
					
					case 2: /* typoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 2, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_type_encoding */
				break;
			
			case UserMappingRelationId: /* pg_user_mapping */
			{
				switch(pchn->attnum)
				{
					
					case 3: /* umoptions */
					{
						bool		isnull;
						Datum		d = 
							caql_getattr_internal(pCtx, tuple, 3, &isnull);
					
						if (!isnull)
							result = DatumGetCString(
								DirectFunctionCall1(textout, d));
					
						if (pbIsNull) *pbIsNull = isnull;
					}
						break;
			
				  default:
					elog(ERROR, "column not a cstring: %s\nfile: %s, line %d", 
						 caql_str, filenam, lineno);
				}
			} /* end pg_user_mapping */
				break;
		
		  default:
			elog(ERROR, "could not get column for relation: %s\nfile: %s, line %d", 
				 caql_str, filenam, lineno);
		}

	} /* end HeapTupleIsValid */

	if (pCtx->cq_usesyscache)
	{  
		if (HeapTupleIsValid(tuple))
			ReleaseSysCache(tuple);
	}
	else
	{	
		if (pFetchcount && HeapTupleIsValid(tuple))
		{				
			if (HeapTupleIsValid(systable_getnext(pCtx->cq_sysScan)))
			{
				*pFetchcount = 2;	
			}
		}
		systable_endscan(pCtx->cq_sysScan); 
	}		
	caql_heapclose(pCtx);

	return (result);
} /* end caql_getcstring_plus */


void
caql_logquery(const char *funcname, const char *filename, int lineno,
			  int uniqquery_code, Oid arg1)
{
}

